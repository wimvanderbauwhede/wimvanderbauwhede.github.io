<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Writing faster Raku code â€¢ Wim Vanderbauwhede</title>
    <meta name="description" content="Sometimes you want your Raku code to be faster. What does it take?">
    <meta name="keywords" content="coding, hacking, programming, raku, perl">
    

    <link rel="canonical" href="https://wimvanderbauwhede.github.io/articles/writing-faster-raku/">

    <link href="https://wimvanderbauwhede.github.io/atom.xml" type="application/atom+xml" rel="alternate" title="Wim Vanderbauwhede Atom Feed">
    <link href="https://wimvanderbauwhede.github.io/sitemap.xml" type="application/xml" rel="sitemap" title="Sitemap">

    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="cleartype" content="on">
    <meta name="p:domain_verify" content="e31ad34d4267c0ac4d997da5cb5ea898"/>
    <meta http-equiv="X-Clacks-Overhead" content="GNU Natalie Nguyen" />
    <!-- <style>
    .sliding-menu-content {
      top: 0;
      right: 0;
      text-align: center;
      visibility: hidden;
      height: 100%;
      width: 100%;
      -webkit-transform: translateX(100%);
      -moz-transform: translateX(100%);
      -ms-transform: translateX(100%);
      -o-transform: translateX(100%);
      transform: translateX(100%);
    }
    </style> -->

    <link rel="stylesheet" href="https://wimvanderbauwhede.github.io/css/main.css">
    <!-- <link rel="stylesheet" href="https://wimvanderbauwhede.github.io/css/bjqs.css"> -->
    <!-- <link rel="stylesheet" href="https://wimvanderbauwhede.github.io/tipuesearch/tipuesearch.css"> -->
    <!-- HTML5 Shiv and Media Query Support for IE -->
    <!--[if lt IE 9]>
      <script src="https://wimvanderbauwhede.github.io/js/vendor/html5shiv.min.js"></script>
      <script src="https://wimvanderbauwhede.github.io/js/vendor/respond.min.js"></script>
    <![endif]-->
    <!-- Include the jQuery library (local or CDN) -->
    <!-- <script src="https://wimvanderbauwhede.github.io/js/plugins/jquery-1.7.1.min.js"></script> -->

    <!-- Include the plugin *after* the jQuery library -->
    <!-- <script src="https://wimvanderbauwhede.github.io/js/plugins/bjqs-1.3.min.js"></script> -->
        
  </head>

  <body>
    <header id="masthead">
  <div class="inner-wrap">
<a href="https://wimvanderbauwhede.github.io" class="site-title">&nbsp;</a>
    <nav role="navigation" class="menu top-menu">
        <ul class="menu-item">
	<li class="home"><a href="/">Wim Vanderbauwhede</a></li>
	

</ul>

    </nav>
<!-- <form style="float: right;" action="https://wimvanderbauwhede.github.io/search.html" ><input type="text" name="q" id="tipue_search_input" autocomplete="off" required></form> -->
  </div><!-- /.inner-wrap -->
</header><!-- /.masthead -->

    <!-- <nav role="navigation" class="js-menu sliding-menu-content">
	<ul class="menu-item">
		
	</ul>
</nav>
<button type="button" class="js-menu-trigger sliding-menu-button menulines-button x2" role="button" aria-label="Toggle Navigation">
	<span class="menulines"></span>
</button>

<div class="js-menu-screen menu-screen"></div>
 -->

    <div id="page-wrapper">

      <div id="main" role="main">
	<article class="wrap" itemscope itemtype="http://schema.org/Article">
		
		<div class="page-feature">
			<div class="page-image">
				<img src="https://wimvanderbauwhede.github.io/images/writing-faster-raku_1600x600.avif" class="page-feature-image" alt="Writing faster Raku code" itemprop="image">
				
			</div><!-- /.page-image -->
		</div><!-- /.page-feature -->
		
		<nav class="breadcrumbs">
  <a href="https://wimvanderbauwhede.github.io">Home</a> <span class="divider">/</span> <a href="https://wimvanderbauwhede.github.io/articles/">Articles</a> <span class="divider">/</span>
</nav><!-- /.breadcrumbs -->
		<div class="page-title">
			<h1>Writing faster Raku code</h1>
		</div>
		<div class="inner-wrap">
			<nav class="toc"></nav><!-- /.toc -->
			<div id="content" class="page-content" itemprop="articleBody">
				<p>In <a href="https://wimvanderbauwhede.github.io/articles/writing-faster-perl">an earlier article</a>, I discussed the result of my attempts to optimize the performance of an expression parser which is part of my Perl-based <a href="https://github.com/wimvanderbauwhede/RefactorF4Acc">Fortran source-to-source compiler</a>. An expression parser takes strings representing expressions in a programming language (in my case Fortran) and turns it into a data structure called a parse tree, which the compiler uses for further analysis and code generation.</p>

<p>I have recently been writing quite a bit of <a href="https://raku.org/">Raku</a> code but so far I had not looked at its performance. Out of curiosity I decided to rewrite and optimise this Fortran expression parser in Raku.</p>

<h2 id="expression-parsing">Expression parsing</h2>

<p>What I loosely call an expression parser is actually a combination of a <a href="https://en.wikipedia.org/wiki/Lexical_analysis">lexer</a> and a <a href="https://en.wikipedia.org/wiki/Parsing#Parser">parser</a>: it turns a string of source code into a tree-like data structure which expresses the structure of the expression and the purpose of its constituents. For example if the expression is <code class="language-plaintext highlighter-rouge">2*v+1</code>, the result of the expression parser will be a data structure which identifies the top-level expression as a sum of a multiplication with  the integer constant <code class="language-plaintext highlighter-rouge">1</code>, and the multiplication of an integer constant <code class="language-plaintext highlighter-rouge">2</code> with a variable <code class="language-plaintext highlighter-rouge">v</code>.</p>

<p>So how do we build a fast expression parser in Raku? It is not my intention to go into the computing science details, but instead to discuss the choices and trade-offs to be considered.</p>

<h2 id="raku-performance-testing">Raku performance testing</h2>

<p>An easily-made argument is that if you want performance, you should not write your code in Raku but in C/C++. And it is of course true that compiled code will almost always be faster. However, often, rewriting in a compiled language is not an option, so it is important to know how to get the best possible performance in Raku.</p>

<p>The Raku documentation has <a href="https://docs.raku.org/language/performance">a page on performance</a> which offers good advice in general terms. But for my needs I did not find the answers about the specific trade-offs that I might have to make. So I created some simple test cases to find out more. I used Raku version  <code class="language-plaintext highlighter-rouge">2020.09</code> built on MoarVM version <code class="language-plaintext highlighter-rouge">2020.09</code>, the most recent one when I ran the tests, but the results should be quite similar for slightly earlier and later versions.</p>

<p>I test the performance using a series of small test benches with different cases, controlled by a command line argument, using the <code class="language-plaintext highlighter-rouge">time</code> command to obtain the wall clock time, and taking the average over 5 runs. For example,</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">time </span>raku test_hash_vs_regex.raku 1
</code></pre></div></div>

<h2 id="there-is-more-than-one-way-to-do-it-but-only-one-will-be-the-fastest">There is more than one way to do it, but only one will be the fastest</h2>

<p>Parsing involves taking strings and turning them into other data structures, so there are many decisions to be made about the data structures and the ways to turn strings into them and manipulate them. Here are some results of performance comparisons that influenced design decisions for the compiler. I was curious to see if they would turn out different in Raku.</p>

<h3 id="hash-key-testing-is-faster-than-regexp-matching">Hash key testing is faster than regexp matching</h3>

<p>Fortran code essentially consists of a list of statements which can contain expressions, and in my compiler the statement parser labels each of the statements once using a hashmap. Every parsed line of code is stored as a pair of the original string <code class="language-plaintext highlighter-rouge">$src_line</code> with this hashmap, called <code class="language-plaintext highlighter-rouge">$info</code>:</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">my</span> <span class="nv">$parsed_line</span> <span class="o">=</span> <span class="p">[</span> <span class="nv">$src_line</span><span class="p">,</span> <span class="nv">$info</span> <span class="p">];</span>
</code></pre></div></div>

<p>The labels and values stored in <code class="language-plaintext highlighter-rouge">$info</code> depend on the type of statement. It is not <em>a priori</em> clear if matching a pattern in <code class="language-plaintext highlighter-rouge">$src_line</code> using a regex is faster or slower than looking up the corresponding label in <code class="language-plaintext highlighter-rouge">$info</code>. So I tested the performance of hash key testing versus regexp matching, using some genuine FORTRAN 77 code, a <code class="language-plaintext highlighter-rouge">READ</code> I/O call, labelled in <code class="language-plaintext highlighter-rouge">$info</code> as <code class="language-plaintext highlighter-rouge">ReadCall</code>:</p>

<pre><code class="language-perl6">my $str = lc('READ( 1, 2, ERR=8, END=9, IOSTAT=N ) X');
my $info = {};   
if ($str~~/read/) {
    $info&lt;ReadCall&gt; = 1;
}
my $count=0;

constant NITERS = 10_000_000;
if CASE==1 {
    for 1..NITERS -&gt; $i {
# regexp        
        if ($str~~/read/) { 
            $count+=$i;
        }
    }
} elsif CASE==2 {
    for 1..NITERS -&gt; $i {
# hash lookup        
            if ($info&lt;ReadCall&gt;:exists) {
                $count+=$i;
            }
    }   
} elsif CASE==3 {
    for 1..NITERS -&gt; $i {
# overhead        
                $count+=$i;
    }    
}
</code></pre>

<p>Without the <code class="language-plaintext highlighter-rouge">if</code>-condition in its body (CASE==3), the <code class="language-plaintext highlighter-rouge">for 1..NITERS</code> loop takes 3 s on my laptop. The loop with with the hash key existence test takes 5 s; the regexp match condition takes 53 s. So the actual condition evaluation takes 2 s for hash key existence check and 50 s for regexp match. So testing hash keys is 25 times faster than simple regexp matching. So we trade some memory for computation: we identify the statement once using a regexp, an store the identifying label in <code class="language-plaintext highlighter-rouge">$info</code> for subsequent passes.</p>

<p><b>Result:</b> Testing hash keys is 25 times faster than simple regexp matching. So we trade some memory for computation: we identify the statement once using a regexp, an store the identifying label in <code class="language-plaintext highlighter-rouge">$info</code> for subsequent passes.</p>

<h3 id="a-fast-data-structure-for-the-parse-tree-integer-versus-string-comparison">A fast data structure for the parse tree: integer versus string comparison</h3>

<p>The choice of the data structure for the parsed expression matters. As we need a tree-like ordered data structure, it would have to either an object or a list-like data structure. But objects in are slow, so I use a nested array.</p>

<pre><code class="language-perl6">['+',
    ['*',
        2,
        ['$','v']
    ],
    1
]
</code></pre>

<!-- ### Integer comparison is faster than string comparison -->

<p>This data structure is fine if you donâ€™t need to do a lot of work on it. However, because every node is labelled with a string, testing against the node type is a string comparison. Simply testing against a constant string or integer is not good enough as the compiler might optimise this away. So I tested this as follows to make sure <code class="language-plaintext highlighter-rouge">$str</code> and <code class="language-plaintext highlighter-rouge">$c</code> get a new value on every iteration:</p>

<pre><code class="language-perl6">if CASE==1 { # 7.3 - 5.3 = 2 s net
    for 1 .. NITERS -&gt; $i {
# string equality        
        my $str = chr($i % 43);
        if $str eq '*' {
            $count+=$i;
        }
    }
} 
elsif CASE==2 { # 3.3 - 3.1 = 0.3
    for 1..NITERS -&gt; $i {
# int equality        
        my $c = $i % 43;
        if $c == 42 {
            $count+=$i;
        }
    }
} elsif CASE==3 { # 5.3
    for 1..NITERS -&gt; $i {
# string equality overhead        
        my $str = chr($i % 43);
    }
} elsif CASE==4 { # 3.1
    for 1..NITERS -&gt; $i {
# int equality overhead
        my $c = $i % 43;
    }
}
</code></pre>

<p>I populate the string or integer based on the loop iterator and then perform a comparison to a constant string or integer. By subtracting the time taken for the assignment (cases 3 and 4) I obtain the actual time for the comparison.</p>

<p>On my laptop, the version with string comparison takes 2 s net, the integer comparison 0.3 s. So doing string comparisons is at least 5 times slower than doing integer comparisons. Therefore my data structure uses integer labels. Also, I label the constants so that I can have different labels for string, integer and real constants, and because in this way all nodes are arrays. This avoids having to test if a node is an array or a scalar, which is a slow operation.</p>

<p>So the example becomes :</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span> <span class="mi">3</span><span class="p">,</span>
  <span class="p">[</span> <span class="mi">5</span><span class="p">,</span>
    <span class="p">[</span> <span class="mi">29</span><span class="p">,</span> <span class="p">'</span><span class="s1">2</span><span class="p">'</span> <span class="p">],</span>
    <span class="p">[</span> <span class="mi">2</span><span class="p">,</span> <span class="p">'</span><span class="s1">v</span><span class="p">'</span> <span class="p">]</span>
  <span class="p">],</span>
  <span class="p">[</span> <span class="mi">29</span><span class="p">,</span> <span class="p">'</span><span class="s1">1</span><span class="p">'</span> <span class="p">]</span>
<span class="p">]</span>
</code></pre></div></div>

<p>Less readable, but faster and easier to extend. In what follows, what I call the <em>parse tree</em> is this data structure.</p>

<p><b>Result:</b> String comparisons is at least 5 times slower than doing integer comparisons.</p>

<h3 id="custom-tree-traversals-are-faster">Custom tree traversals are faster</h3>

<p>I tested the cost of using higher-order functions for parse tree traversal (recursive descent). Basically, this is the choice between a generic traversal using a higher-order function which takes an arbitrary function that operates on the parse tree nodes:</p>

<pre><code class="language-perl6">sub _traverse_ast_with_action($ast_, $acc_, &amp;f) {
    my $ast=$ast_; my $acc=$acc_;
    if &lt;cond&gt; { 
        $acc=&amp;f($ast,$acc);
    } else { 
        $acc=&amp;f($ast,$acc);
        for  1 .. $ast.elems - 1  -&gt; $idx {
            (my $entry, $acc) = 
                _traverse_ast_with_action($ast[$idx],$acc, &amp;f);
            $ast[$idx] = $entry;
        }
    }
    return ($ast, $acc);
} 
</code></pre>

<p>or a custom traversal:</p>

<pre><code class="language-perl6">sub _traverse_ast_custom($ast_, $acc_) {
    my $ast=$ast_; my $acc=$acc_;
    if &lt;cond&gt; { 
        $acc=&lt; custom code acting on $ast and $acc&gt;;
    } else { 
    $acc=&lt; custom code acting on $ast and $acc&gt;;
        for 1 .. $ast.elems - 1  -&gt; $idx {
            (my $entry, $acc) = 
                _traverse_ast_custom($ast[$idx],$acc);
            $ast[$idx] = $entry;
        }
    }
    return ($ast, $acc);
} 

</code></pre>

<p>For the case of the parse tree data structures in my compiler, the higher-order implementation takes more than twice as long as the custom traversal, so for performance this is not a good choice. Therefore I donâ€™t use higher-order functions in the parser, but I do use them in the later refactoring passes.</p>

<p><b>Result:</b> Higher-order implementations of recursive descent take more than twice as long as custom traversals.</p>

<h3 id="the-fastest-way-to-process-a-list">The fastest way to process a list</h3>

<p>The internal representation of a Fortran program in my compiler is an list of <code class="language-plaintext highlighter-rouge">[ $src_line, $info ]</code> pairs and the <code class="language-plaintext highlighter-rouge">$info</code> hash stores the parse tree as a nested array. So iterating through lists and arrays is a major factor in the performance.</p>

<p>Raku has several ways to iterate through a list-like data structure. I tested six of them, as follows:</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">constant</span> <span class="nv">NITERS</span> <span class="o">=</span> <span class="mi">2_000_000</span><span class="p">;</span>
<span class="k">if</span> <span class="nv">CASE</span><span class="o">==</span><span class="mi">0</span> <span class="p">{</span> <span class="c1"># 6.2 s</span>
<span class="c1"># map</span>
    <span class="k">my</span> <span class="nv">@src</span> <span class="o">=</span> <span class="nb">map</span> <span class="p">{</span><span class="vg">$_</span><span class="p">},</span> <span class="mi">1</span> <span class="o">..</span> <span class="nv">NITERS</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">@res</span> <span class="o">=</span> <span class="nb">map</span> <span class="p">{</span><span class="mi">2</span><span class="o">*</span><span class="vg">$_</span><span class="o">+</span><span class="mi">1</span><span class="p">},</span> <span class="nv">@src</span><span class="p">;</span>
<span class="p">}</span> <span class="k">elsif</span> <span class="nv">CASE</span><span class="o">==</span><span class="mi">1</span> <span class="p">{</span> <span class="c1"># 7.9 s</span>
<span class="c1"># for each elt in list</span>
    <span class="k">my</span> <span class="nv">@res</span><span class="o">=</span><span class="p">();</span>
    <span class="k">my</span> <span class="nv">@src</span><span class="o">=</span><span class="p">();</span>
    <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="nv">NITERS</span> <span class="o">-&gt;</span> <span class="nv">$elt</span> <span class="p">{</span>
        <span class="nb">push</span> <span class="nv">@src</span><span class="p">,</span> <span class="nv">$elt</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nv">@src</span> <span class="o">-&gt;</span> <span class="nv">$elt</span> <span class="p">{</span>
        <span class="nb">push</span> <span class="nv">@res</span><span class="p">,</span> <span class="mi">2</span><span class="nv">*$elt</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="k">elsif</span> <span class="nv">CASE</span><span class="o">==</span><span class="mi">2</span> <span class="p">{</span> <span class="c1"># 6.2 s</span>
<span class="c1"># for with index</span>
    <span class="k">my</span> <span class="nv">@res</span><span class="o">=</span><span class="p">();</span>
    <span class="k">my</span> <span class="nv">@src</span><span class="o">=</span><span class="p">();</span>
    <span class="k">for</span> <span class="mi">0</span><span class="o">..</span><span class="nv">NITERS</span><span class="o">-</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="nv">$idx</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$elt</span><span class="o">=</span><span class="nv">$idx</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
        <span class="nv">@src</span><span class="p">[</span><span class="nv">$idx</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$elt</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="mi">0</span><span class="o">..</span><span class="nv">NITERS</span><span class="o">-</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="nv">$idx</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$elt</span><span class="o">=</span><span class="nv">@src</span><span class="p">[</span><span class="nv">$idx</span><span class="p">];</span>
        <span class="nv">@res</span><span class="p">[</span><span class="nv">$idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="nv">*$elt</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="k">elsif</span> <span class="nv">CASE</span><span class="o">==</span><span class="mi">3</span> <span class="p">{</span> <span class="c1"># 11.0</span>
<span class="c1"># loop (C-style)</span>
    <span class="k">my</span> <span class="nv">@res</span><span class="o">=</span><span class="p">();</span>
    <span class="k">my</span> <span class="nv">@src</span><span class="o">=</span><span class="p">();</span>
    <span class="nv">loop</span> <span class="p">(</span><span class="k">my</span> <span class="nv">$idx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nv">$idx</span> <span class="o">&lt;</span> <span class="nv">NITERS</span><span class="p">;</span><span class="o">++</span><span class="nv">$idx</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$elt</span><span class="o">=</span><span class="nv">$idx</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
        <span class="nv">@src</span><span class="p">[</span><span class="nv">$idx</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$elt</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nv">loop</span> <span class="p">(</span><span class="k">my</span> <span class="nv">$idx2</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nv">$idx2</span> <span class="o">&lt;</span> <span class="nv">NITERS</span><span class="p">;</span><span class="o">++</span><span class="nv">$idx2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$elt</span><span class="o">=</span><span class="nv">@src</span><span class="p">[</span><span class="nv">$idx2</span><span class="p">];</span>
        <span class="nv">@res</span><span class="p">[</span><span class="nv">$idx2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="nv">*$elt</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="k">elsif</span> <span class="nv">CASE</span><span class="o">==</span><span class="mi">4</span> <span class="p">{</span> <span class="c1"># 3.7 s</span>
<span class="c1"># postfix for with push</span>
    <span class="k">my</span> <span class="nv">@src</span> <span class="o">=</span> <span class="p">();</span>
    <span class="k">my</span> <span class="nv">@res</span><span class="o">=</span><span class="p">();</span>
    <span class="nb">push</span> <span class="nv">@src</span><span class="p">,</span> <span class="vg">$_</span> <span class="k">for</span> <span class="mi">1</span> <span class="o">..</span> <span class="nv">NITERS</span><span class="p">;</span>
    <span class="nb">push</span> <span class="nv">@res</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="vg">$_</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="nv">@src</span><span class="p">;</span>
<span class="p">}</span> <span class="k">elsif</span> <span class="nv">CASE</span><span class="o">==</span><span class="mi">5</span> <span class="p">{</span> <span class="c1"># 3.5 s</span>
<span class="c1"># comprehension</span>
    <span class="k">my</span> <span class="nv">@src</span> <span class="o">=</span> <span class="p">(</span><span class="vg">$_</span> <span class="k">for</span> <span class="mi">1</span> <span class="o">..</span> <span class="nv">NITERS</span><span class="p">);</span>
    <span class="k">my</span> <span class="nv">@res</span><span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="vg">$_</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="nv">@src</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The fastest way is to use list comprehension (case 5, 3.5 s), very closely followed by the suffix-style <code class="language-plaintext highlighter-rouge">for</code> (case 4, 3.7 s). The C-style <code class="language-plaintext highlighter-rouge">loop</code> construct (case 3) is the slowest (11 s). The <code class="language-plaintext highlighter-rouge">map</code> version performs the same as the index-based <code class="language-plaintext highlighter-rouge">for</code> loop (both 6.2 s). It is a bit odd that the list-based for loop, probably the most common loop construct, is slower than these two (7.9 s).</p>

<p><b>Result:</b> List comprehensions are fastest, almost twice as fast as <code class="language-plaintext highlighter-rouge">for</code>-loops or <code class="language-plaintext highlighter-rouge">map</code>s. C-style <code class="language-plaintext highlighter-rouge">loop</code> is very slow.</p>

<h3 id="parsing-regular-expressions-string-comparisons-or-list-operations">Parsing: regular expressions, string comparisons or list operations?</h3>

<p>Finally, we have to decide how to parse the expression string. The traditional way to build an expression parser is using a Finite State Machine, consuming one character at a time (if needed with one or more characters look-ahead) and keeping track of the identified portion of the string. This is very fast in a language such as C but in Raku I was not too sure, because in Raku a character is actually a string of length one, so every test against a character is a string comparison. On the other hand, Raku has a sophisticated regular expression engine. Yet another way is to turn the string into an array, and parse using list operations. Many possibilities to be tested:</p>

<pre><code class="language-perl6">constant NITERS = 100_000;
my $str='This means we need a stack per type of operation and run until the end of the expression';
my @chrs =  $str.comb;
if (CASE==0) { # 5.8 s
    for 1 .. NITERS -&gt; $ct {
# map on an array of characters        
        my @words=();
        my $word='';
        map(-&gt; \c { 
            if (c ne ' ') {
                $word ~= c;
            } else {
                push @words, $word;
                $word='';
            }
        }, @chrs);
        push @words, $word;
    }
} elsif CASE==1 { # 2.7 s    
     for 1 .. NITERS -&gt; $ct {
# while with index through a string        
        my @words=();
        my $str='This means we need a stack per type of operation and run until the end of the expression';
        while my $idx=$str.index( ' ' ) {
            push @words, $str.substr(0,$idx);
            $str .= substr($idx+1);
        }
        push @words, $str;
    }         
} elsif CASE==2 {  # 11.7 s
    for 1 .. NITERS -&gt; $ct {
# while on an array of characters        
        my @words=();
        my @chrs_ = @chrs; 
        my $word='';      
        while @chrs_ {
            my $chr = shift @chrs_;
            if ($chr ne ' ') {
                $word~=$chr;
            } else {
                push @words, $word;
                $word='';
            }
        }
        push @words, $word;
    }
} elsif CASE==3 { # 101 s
    for 1 .. NITERS -&gt; $ct {
# while on a string using a regexp        
        my @words=();
        my $str='This means we need a stack per type of operation and run until the end of the expression';
        while $str.Bool {
            $str ~~ s/^$&lt;w&gt; = [ \w+ ]//;
            if ($&lt;w&gt;.Bool) {
                push @words, $&lt;w&gt;.Str;
            }
            else {
                $str ~~ s/^\s+//;
            } 
        }
    }   
} elsif CASE==4 { # 64 s
    for 1 .. NITERS -&gt; $ct {
# reduce on an array of characters        
        my \res = reduce(
        -&gt; \acc, \c { 
            if (c ne ' ') {
                acc[0],acc[1] ~ c;
            } else {
                ( |acc[0], acc[1] ),'';
            }
        }, ((),''), |@chrs);
        my @words = |res[0],res[1];
}
</code></pre>

<p>For the list-based version, the overhead is 1.6 s; for the string-based versions, 0.8s.</p>

<p>The results are rather striking. Clearly the regexp version is by far the slowest. This was a surprise because in my Perl implementation, the regexp version was twice as fast as next best choice. From the other implementations, the string-based FSM which uses the <code class="language-plaintext highlighter-rouge">index</code> and <code class="language-plaintext highlighter-rouge">substr</code> methods is by far the fastest, without the overhead it takes 1.9s s, which is more that 50 times faster than the regexp version. The <code class="language-plaintext highlighter-rouge">map</code> based version comes second but is nearly twice as slow. What is surprising, and actually a bit disappointing, is that the <code class="language-plaintext highlighter-rouge">reduce</code> based version, which works the same as the <code class="language-plaintext highlighter-rouge">map</code> based one but works on immutable data, is also very slow, 64 s.</p>

<p>In any case, the choice is clear. It is possible to make the fastest version  marginally faster (1.6 s instead of 1.9 s) by not reducing the string but instead moving the index through the string. However, for the full parser I want to have the convenience of the <code class="language-plaintext highlighter-rouge">trim-leading</code> and <code class="language-plaintext highlighter-rouge">starts-with</code> methods, so I choose to consume the string.</p>

<p><b>Result:</b> Using <code class="language-plaintext highlighter-rouge">index</code> and <code class="language-plaintext highlighter-rouge">substr</code> methods is much faster than using regexps.</p>

<h2 id="a-faster-expression-parser">A faster expression parser</h2>

<p>With the choices of string parsing and data structure made, I focused on the structure of the overall algorithm. The basic approach is to loop trough a number of states and in every state perform a specific action. In the Perl version this was very simple because we use regular expressions to identify tokens, so most of the state transitions are implicit. I wanted to keep this structure so I emulate the regexp <code class="language-plaintext highlighter-rouge">s///</code> operation with comparisons, indexing and substring operations.</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">my</span> <span class="nv">$prev_lev</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$lev</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">@ast</span><span class="o">=</span><span class="p">();</span>
<span class="k">my</span> <span class="nv">$op</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$state</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="nb">length</span><span class="p">(</span><span class="nv">$str</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="c1"># Match unary prefix operations</span>
     <span class="c1"># Match terms</span>
     <span class="c1"># Add prefix operations if matched</span>
     <span class="c1"># Match binary operators</span>
     <span class="c1"># Append to the AST</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The matching rules and operations are very simple (I use <code class="language-plaintext highlighter-rouge">&lt;pattern&gt;</code> and <code class="language-plaintext highlighter-rouge">&lt;integer&gt;</code> as placeholders for the actual values). Here is the Perl version for reference:</p>

<ul>
  <li>prefix operations:</li>
</ul>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span> <span class="nv">$str</span><span class="o">=~</span><span class="sr">s/^&lt;pattern&gt;//</span> <span class="p">)</span> <span class="p">{</span> <span class="nv">$state</span><span class="o">=&lt;</span><span class="nv">integer</span><span class="o">&gt;</span><span class="p">;</span> <span class="p">}</span> 
</code></pre></div></div>

<ul>
  <li>terms:</li>
</ul>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span> <span class="nv">$str</span><span class="o">=~</span><span class="sr">s/^(&lt;pattern&gt;)//</span> <span class="p">)</span> <span class="p">{</span> <span class="nv">$expr_ast</span><span class="o">=</span><span class="p">[</span><span class="o">&lt;</span><span class="nv">integer</span><span class="o">&gt;</span><span class="p">,</span><span class="err">$</span><span class="mi">1</span><span class="p">];</span> <span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>operators:</li>
</ul>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$prev_lev</span><span class="o">=</span><span class="nv">$lev</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span> <span class="nv">$str</span><span class="o">=~</span><span class="sr">s/^&lt;pattern&gt;//</span> <span class="p">)</span> <span class="p">{</span> <span class="nv">$lev</span><span class="o">=&lt;</span><span class="nv">integer</span><span class="o">&gt;</span><span class="p">;</span> <span class="nv">$op</span><span class="o">=&lt;</span><span class="nv">integer</span><span class="o">&gt;</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div>

<p>In the Raku version I used the <code class="language-plaintext highlighter-rouge">given</code>/<code class="language-plaintext highlighter-rouge">when</code> construct, which is as fast as an <code class="language-plaintext highlighter-rouge">if</code> statement but a bit neater.</p>

<ul>
  <li>prefix operations:</li>
</ul>

<pre><code class="language-perl6">given $str {
    when .starts-with(&lt;token&gt;) { 
        .=substr(&lt;length of token&gt;); 
        $state&lt;integer&gt;; }
</code></pre>

<ul>
  <li>terms:</li>
</ul>

<pre><code class="language-perl6">given $str
    when .starts-with(&lt;token start&gt;) { 
        $expr_ast=[&lt;integer&gt;,$term]; }
</code></pre>

<ul>
  <li>operators:</li>
</ul>

<pre><code class="language-perl6">given $str {
    when .starts-with(&lt;token&gt;) { 
        .=substr(&lt;length of token&gt;); 
        $lev=&lt;integer&gt;; 
        $op=&lt;integer&gt;; 
    }
</code></pre>

<p>One of the more complex patterns to match is the case of an identifier followed by an opening parenthesis with optional whitespace. Using regular expressions this pattern would be:</p>

<pre><code class="language-perl6">if  $str ~~ s:i/^ $&lt;token&gt; = [ [a .. z] \w*] \s* \( // { 
    my $var=$&lt;token&gt;.Str;
    ... 
}
</code></pre>

<p>Without regular expressions, we first check for a character between â€˜aâ€™ and â€˜zâ€™ using <code class="language-plaintext highlighter-rouge">'a' le .substr(0,1).lc le 'z'</code>. If that matches, we remove it from <code class="language-plaintext highlighter-rouge">$str</code> and add it to <code class="language-plaintext highlighter-rouge">$var</code>. Then we go in a <code class="language-plaintext highlighter-rouge">while</code> loop for as long as there are characters that are alphanumeric or â€˜_â€™. Then we strip any whitespace and test for â€˜(â€˜.</p>

<pre><code class="language-perl6">when 'a' le (my $var = .substr(0,1)).lc le 'z' {
    my $idx=1;
    my $c = .substr($idx,1);
    while 'a' le $c.lc le 'z' or $c eq '_' 
        or '0' le $c le '9' {
        $var~=$c;
        $c = .substr(++$idx,1);
    }
    .=substr($idx);
    .=trim-leading;
    if .starts-with('(') {
        ...
    }
}
</code></pre>

<p>Another complex pattern is that for a floating point number. In Fortran, the pattern is more complicated because the sub-pattern <code class="language-plaintext highlighter-rouge">.e</code> can be part of a floating-point constant but could also be the part of the equality operator <code class="language-plaintext highlighter-rouge">.eq.</code>. Furthermore, the separator between the mantissa and the exponent can be not just <code class="language-plaintext highlighter-rouge">e</code> but also <code class="language-plaintext highlighter-rouge">d</code> or <code class="language-plaintext highlighter-rouge">q</code>. So the regular expression is rather involved:</p>

<pre><code class="language-perl6">if (                    	
    (
        !($str~~rx:i/^\d+\.eq/) and
        $str~~s:i/^([\d*\.\d*][[e|d|q][\-|\+]?\d+]?)//        
    )        	
    or 
    $str~~s:i/^(\d*[e|d|q][\-|\+]?\d+)//
) {
    $real_const_str=$/.Str;
} 
</code></pre>

<p>Without regular expression, the implementation is as follows. We first detect a character between 0 and 9 or a dot. Then we try to match the mantissa, separator, sign and exponent. The latter three are optional; if they are not present and the mantissa does not contain a dot, we have matched an integer.</p>

<pre><code class="language-perl6">when '0' le .substr(0,1) le '9' or .substr(0,1) eq '.' { 
    my $sep='';
    my $sgn='';
    my $exp='';
    my $real_const_str='';

    # first char of mantissa
    my $mant = .substr(0,1);
    # try and match more chars of mantissa
    my $idx=1;
    $h = .substr($idx,1);
    while '0' le $h le '9' or $h eq '.' {
        $mant ~=$h;
        $h = .substr(++$idx,1);
    }
    $str .= substr($idx);

    # reject .eq.
    if not ($mant.ends-with('.') and .starts-with('eq',:i)) { 
        if $h.lc eq 'e' | 'd' | 'q' {
            # we found a valid separator
            $sep = $h;            
            my $idx=1;
            $h =.substr(1,1);
            # now check if there is a sign
            if $h eq '-' or $h eq '+' {
                ++$idx;
                $sgn = $h;
                $h =.substr($idx,1);
            }
            # now check if there is an exponent            
            while '0' le $h le '9' {
                ++$idx;
                $exp~=$h;
                $h =.substr($idx,1);
            }
            $str .= substr($idx);
            if $exp ne '' {
            $real_const_str="$mant$sep$sgn$exp";
            $expr_ast=[30,$real_const_str];
            } else {
                # parse error
            }
        } elsif index($mant,'.').Bool {
            # a mantissa-only real number
            $real_const_str=$mant;
            $expr_ast=[30,$real_const_str];
        }
        else { # no dot and no sep, so an integer
            $expr_ast=[29,$mant];   
        }
    } else { # .eq., backtrack and carry on
        $str ="$mant$str";        
        proceed;
    }            
}
</code></pre>

<p>A final example of how to handle patterns is the case of whitespace in comparison and logical operators. Fortran has operators of the form <code class="language-plaintext highlighter-rouge">&lt;dot word dot&gt;</code>, for example <code class="language-plaintext highlighter-rouge">.lt.</code> and <code class="language-plaintext highlighter-rouge">.xor.</code>. But annoyingly, it allows whitespace between the dot and the word, e.g. <code class="language-plaintext highlighter-rouge">. not .</code>. Using regular expressions, this is of course easy to handle, for example:</p>

<pre><code class="language-perl6">if $str~~s/^\.\s*ge\s*\.//) {
    $lev=6;
    $op=20;
} 
</code></pre>

<p>I check for a pattern starting with a dot and which contains a space before the next dot. Then I remove all spaces from that substring using <code class="language-plaintext highlighter-rouge">trans</code> and replace this original string with this trimmed version.</p>

<pre><code class="language-perl6">when .starts-with('.') and  .index( ' ' ) 
    and (.index( ' ' ) &lt; (my $eidx = .index('.',2 ))) {
    
    # Find the keyword with spaces
    my $match = .substr(0, $eidx+1);
    # remove the spaces
    $match .= trans( ' ' =&gt; '' );
    # update the string
    $str = $match ~ .substr( $eidx+1);
    proceed;
}
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Overall the optimised expression parser in Raku is still very close to the Perl version. The key difference is that the Raku version does not use regular expressions. With the above examples I wanted to illustrate how it is possible to write code with the same functionality as a regular expression <code class="language-plaintext highlighter-rouge">s///</code> operation, using some of Rakuâ€™s built-in string operations:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">substr</code> : substring</li>
  <li><code class="language-plaintext highlighter-rouge">index</code> : location a a substring in a string</li>
  <li><code class="language-plaintext highlighter-rouge">trim-leading</code> : strip leading whitespace</li>
  <li><code class="language-plaintext highlighter-rouge">starts-with</code></li>
  <li><code class="language-plaintext highlighter-rouge">ends-with</code></li>
  <li><code class="language-plaintext highlighter-rouge">trans</code> : used to remove whitespace using the <code class="language-plaintext highlighter-rouge">' ' =&gt; ''</code> pattern</li>
  <li><code class="language-plaintext highlighter-rouge">lc</code> : used in range tests instead of testing against both upper and lower case</li>
  <li><code class="language-plaintext highlighter-rouge">le</code>, <code class="language-plaintext highlighter-rouge">lt</code>, <code class="language-plaintext highlighter-rouge">ge</code>, <code class="language-plaintext highlighter-rouge">gt</code>: for very handy range comparisons, e.g. <code class="language-plaintext highlighter-rouge">'a' le $str le 'z'</code></li>
</ul>

<p>The resulting code is of course much longer but arguably more readable than regular expressions, and currently four times faster.</p>

<p>I ran a lot more tests, and compared performance against Perl and Python as well, but that is another story. All code for the tests is available in <a href="https://github.com/wimvanderbauwhede/raku-examples/tree/master/Performance-analysis">my GitHub repo</a>.</p>

<!-- Operators have precedence and associativity, and Fortran requires twelve precedence levels. In the "Append to AST" state, the parser uses `$lev` and `$prev_lev` to work out how the previously matched `$expr_ast` and `$op` should be appended to the `@ast` array. The prefix operations are handled by setting a state which is checked after term matching. The actual code is a bit more complicated because we need to parse array index expressions and function calls as well. This is done recursively during term matching; if a function call has multiple arguments, the parser is put into a new `$state`. 

So the end result is a minimally recursive parser, i.e. it only uses recursion when it is really necessary. 

There is a lot of repetition of the patterns for matching terms and operators because if I would instead abstract the `<pattern>` and `<integer>` values by e.g. storing them in an array, the array accesses would considerably reduce the performance. I do store the precedence levels in an array because there are so many of them that the logic for appending terms to the AST would otherwise become very hard to read and update. -->

<!-- ## Expression parser performance

I tested the new expression parser on a set of 50 different expressions taken from a weather simulation code. The old expression parser takes 45 s to run this test a thousand times; the new expression parser takes only 2 s. In other words, the new parser is *more than twenty times faster* than the old one. 

It is also quite easy to maintain and adapt despite its minimal use of abstractions, and because it is Fortran-specific, the rest of the code has become a lot cleaner too. You can find the code in [my GitHub repo](https://github.com/wimvanderbauwhede/RefactorF4Acc/blob/devel/RefactorF4Acc/Parser/Expressions.pm). -->

<!-- Here is a summary of all optimisations I tested. The tests were run using Perl v5.28 on a MacBook Pro (late 2013), timings are averages over 5 runs and measured using `time`.

<table>
  <thead>
<tr>
<th>
Optimisation
</th>
<th>
Speed-up
</th>

</tr>
  </thead>
   <tbody>
<tr>
<td> Hash key testing is faster than regexp matching </td><td> 3&times; </td>
</tr>
<tr>
<td> Custom tree traversals are faster than generic ones </td><td> 2&times; </td>
</tr>
<tr>
<td> `foreach` is faster than `map` </td><td> 1.3&times; </td>
</tr>
<tr>
<td> `foreach` is faster than indexed `for` </td><td> 1.4&times; </td>
</tr>
<tr>
<td> `foreach` is faster than C-style `for` </td><td> 1.7&times; </td>
</tr>
<tr>
<td> Integer comparison is faster than string comparison </td><td> 1.5&times; </td>
</tr>
<tr>
<td> Regexp matching is faster than successive string comparisons </td><td> 2.2&times; </td>
</tr>

 </tbody>
<table> -->

				<hr />
				<footer class="page-footer">
					

<!--
<div class="author-image">
	<img src="https://wimvanderbauwhede.github.io/images/" alt="Wim Vanderbauwhede">
</div>
-->
<!-- ./author-image -->
<div class="author-content">
	<h3 class="author-name" >Written by <a href="http://www.dcs.gla.ac.uk/~wim" itemprop="author">Wim Vanderbauwhede</a></h3>
	<p class="author-bio"></p>
</div><!-- ./author-content -->

                    <div class="inline-btn">
    <a href="https://wimvanderbauwhede.github.io/atom.xml"><i class="fa fa-rss"></i></a>
</div><!-- /.follow-us -->

					
					<div class="page-meta">
	<p>Updated <time datetime="2020-12-02T00:00:00Z" itemprop="dateModified">December 02, 2020</time>
</div><!-- /.page-meta -->
				</footer><!-- /.footer -->
				<aside>
					
				</aside>
			</div><!-- /.content -->
		</div><!-- /.inner-wrap -->
		
	</article><!-- ./wrap -->
</div><!-- /#main -->


      <footer role="contentinfo" id="site-footer">
	<nav role="navigation" class="menu bottom-menu">
		<ul class="menu-item">
		
      
			<li><a href="https://wimvanderbauwhede.github.io/" >Wim Vanderbauwhede</a></li>
		
      
			<li><a href="https://wimvanderbauwhede.github.io/about/" >About</a></li>
		
		</ul>
	</nav><!-- /.bottom-menu -->
	<p class="copyright">&#169; 2025 <a href="https://wimvanderbauwhede.github.io">Wim Vanderbauwhede</a> <a rel="me" href="https://scholar.social/@wim_v12e">&nbsp;</a><br> <a href="http://jekyllrb.com">Jekyll</a> theme <a href="http://mmistakes.github.io/skinny-bones-jekyll/">Skinny Bones</a></p>

<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
var sc_project=10807901;
var sc_invisible=1;
var sc_security="7dfdbc2d";
var scJsHost = (("https:" == document.location.protocol) ?
"https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" +
scJsHost+
"statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript><div class="statcounter"><a title="web stats"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="http://c.statcounter.com/10807901/0/7dfdbc2d/1/"
alt="web stats"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->

</footer>

    </div>

    <!-- <script src="https://wimvanderbauwhede.github.io/js/vendor/jquery-1.9.1.min.js"></script> -->
    <!-- <script src="https://wimvanderbauwhede.github.io/js/main.js"></script> -->

    

  </body>

</html>
