<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Roles as Algebraic Data Types in Raku • Wim Vanderbauwhede</title>
    <meta name="description" content="Algebraic data types are great for building complex data structures, and easy to implement in Raku using roles.">
    <meta name="keywords" content="coding, hacking, programming, raku">
    
    	<!-- Twitter Cards -->
	<meta name="twitter:title" content="Roles as Algebraic Data Types in Raku">
	<meta name="twitter:description" content="Algebraic data types are great for building complex data structures, and easy to implement in Raku using roles.">
	<meta name="twitter:site" content="@wim_v12e">
	<meta name="twitter:creator" content="@wim_v12e">
	
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:image" content="https://wimvanderbauwhede.github.io/images/roles-as-adts-in-raku_1600x600.jpg">
	
	<!-- Open Graph -->
	<meta property="og:locale" content="en_GB">
	<meta property="og:type" content="article">
	<meta property="og:site_name" content="Wim Vanderbauwhede">
	<meta property="og:url" content="https://wimvanderbauwhede.github.io/articles/roles-as-adts-in-raku/#">
	<meta property="og:title" content="Roles as Algebraic Data Types in Raku">
	<meta property="og:description" content="Algebraic data types are great for building complex data structures, and easy to implement in Raku using roles.">
	<meta property="og:image" content="https://wimvanderbauwhede.github.io/images/roles-as-adts-in-raku_1600x600.jpg" />

    

    <link rel="canonical" href="https://wimvanderbauwhede.github.io/articles/roles-as-adts-in-raku/">

    <link href="https://wimvanderbauwhede.github.io/atom.xml" type="application/atom+xml" rel="alternate" title="Wim Vanderbauwhede Atom Feed">
    <link href="https://wimvanderbauwhede.github.io/sitemap.xml" type="application/xml" rel="sitemap" title="Sitemap">

    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="cleartype" content="on">
    <meta name="p:domain_verify" content="e31ad34d4267c0ac4d997da5cb5ea898"/>
    <meta http-equiv="X-Clacks-Overhead" content="GNU Natalie Nguyen" />
    <style>
    .sliding-menu-content {
      top: 0;
      right: 0;
      text-align: center;
      visibility: hidden;
      height: 100%;
      width: 100%;
      -webkit-transform: translateX(100%);
      -moz-transform: translateX(100%);
      -ms-transform: translateX(100%);
      -o-transform: translateX(100%);
      transform: translateX(100%);
    }
    </style>

    <link rel="stylesheet" href="https://wimvanderbauwhede.github.io/css/main.css">
    <link rel="stylesheet" href="https://wimvanderbauwhede.github.io/css/bjqs.css">
    <link rel="stylesheet" href="https://wimvanderbauwhede.github.io/tipuesearch/tipuesearch.css">
    <!-- HTML5 Shiv and Media Query Support for IE -->
    <!--[if lt IE 9]>
      <script src="https://wimvanderbauwhede.github.io/js/vendor/html5shiv.min.js"></script>
      <script src="https://wimvanderbauwhede.github.io/js/vendor/respond.min.js"></script>
    <![endif]-->
<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-73376688-1', 'auto');
  ga('send', 'pageview');

</script>
<!--
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-19948710-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
-->
    <!-- Include the jQuery library (local or CDN) -->
    <script src="https://wimvanderbauwhede.github.io/js/plugins/jquery-1.7.1.min.js"></script>

    <!-- Include the plugin *after* the jQuery library -->
    <script src="https://wimvanderbauwhede.github.io/js/plugins/bjqs-1.3.min.js"></script>
        
  </head>

  <body>
    <div id="fb-root"></div>
    <script>(function(d, s, id) {
      var js, fjs = d.getElementsByTagName(s)[0];
      if (d.getElementById(id)) return;
      js = d.createElement(s); js.id = id;
      js.src = "//connect.facebook.net/en_GB/sdk.js#xfbml=1&version=v2.5";
      fjs.parentNode.insertBefore(js, fjs);
    }(document, 'script', 'facebook-jssdk'));</script>
    <header id="masthead">
  <div class="inner-wrap">
<a href="https://wimvanderbauwhede.github.io" class="site-title">&nbsp;</a>
    <nav role="navigation" class="menu top-menu">
        <ul class="menu-item">
	<li class="home"><a href="/">Wim Vanderbauwhede</a></li>
	

</ul>

    </nav>
<form style="float: right;" action="https://wimvanderbauwhede.github.io/search.html" ><input type="text" name="q" id="tipue_search_input" autocomplete="off" required></form>
  </div><!-- /.inner-wrap -->
</header><!-- /.masthead -->

    <nav role="navigation" class="js-menu sliding-menu-content">
	<ul class="menu-item">
		
	</ul>
</nav>
<button type="button" class="js-menu-trigger sliding-menu-button menulines-button x2" role="button" aria-label="Toggle Navigation">
	<span class="menulines"></span>
</button>

<div class="js-menu-screen menu-screen"></div>


    <div id="page-wrapper">

      <div id="main" role="main">
	<article class="wrap" itemscope itemtype="http://schema.org/Article">
		
		<div class="page-feature">
			<div class="page-image">
				<img src="https://wimvanderbauwhede.github.io/images/roles-as-adts-in-raku_1600x600.jpg" class="page-feature-image" alt="Roles as Algebraic Data Types in Raku" itemprop="image">
				
			</div><!-- /.page-image -->
		</div><!-- /.page-feature -->
		
		<nav class="breadcrumbs">
  <a href="https://wimvanderbauwhede.github.io">Home</a> <span class="divider">/</span> <a href="https://wimvanderbauwhede.github.io/articles/">Articles</a> <span class="divider">/</span>
</nav><!-- /.breadcrumbs -->
		<div class="page-title">
			<h1>Roles as Algebraic Data Types in Raku</h1>
		</div>
		<div class="inner-wrap">
			<nav class="toc"></nav><!-- /.toc -->
			<div id="content" class="page-content" itemprop="articleBody">
				<p>I have been a <a href="https://andrewshitov.com/2015/05/05/interview-with-audrey-tang/">lambdacamel</a>, one of those who like <a href="https://www.perl.org/">Perl</a> and functional programming, especially in <a href="https://www.haskell.org/">Haskell</a>, for a long time. I still write most of my code in either of these languages.</p>

<p>I&#39;ve also been a fan of <a href="https://raku.org/">Raku</a> from long before it was called Raku, but I&#39;d never used it much in real life. Recently though, I&#39;ve been moving increasingly to Raku for code that I don&#39;t have to share with other people. It&#39;s a lovely language, and its functional heritage is very strong. It was therefore only natural to me to explore the limits of Raku&#39;s type system. </p>

<h2>Is this article for you?</h2>

<p>In this article I will introduce <a href="https://www.cs.kent.ac.uk/people/staff/dat/miranda/nancypaper.pdf">algebraic data types</a>, a kind of static type system used in functional languages like Haskell, and a powerful mechanism for creating complex data structures. I will show a way to implement them in Raku using <em>roles</em>. You don&#39;t need to know Haskell at all and I only assume a slight familiarity with Raku, but I do assume you are familiar with basic programming. You may find this article interesting if you are curious about functional-style static typing or if your would like an alternative to object-oriented programming. </p>

<h2>Algebraic Data Types</h2>

<p>Datatypes (types for short) are just labels or containers for values in a program. Algebraic data types are composite types, they are formed by combining other types.
They are called algebraic because they consist of alternatives (sums, also called disjoint unions) and record (products) of types. For more details see <a href="https://codewords.recurse.com/issues/three/algebra-and-calculus-of-algebraic-data-types">[1]</a> or <a href="https://gist.github.com/gregberns/5e9da0c95a9a8d2b6338afe69310b945">[2]</a>. </p>

<p>To give a rough intuition for the terms &quot;sum type&quot; and &quot;product type&quot;: in Raku,  with booleans <code>$a</code>, <code>$b</code> and <code>$c</code>, you can write <code>$a or $b or $c</code> but you could also write <code>$a + $b + $c</code> and evaluate it as <code>True</code> or <code>False</code>. Similarly, <code>$a and $b and $c</code> can be written as <code>$a * $b * $c</code>. In other words, <code>and</code> and <code>or</code> behave in the same way as <code>+</code> and <code>*</code>. In a generalised way, the types in algebraic data type system can be composed using similar rules.</p>

<h3>A few examples.</h3>

<p>Let&#39;s first give a few examples of algebraic data types. In this section I am not using a specific programming language syntax. Instead I use a minimal notation to illustrate the concepts. I use the <code>datatype</code> keyword to indicate that what follows is a declaration for an algebraic data type; for a sum type, I&#39;ll separate the alternatives with &#39;|&#39;; for a product type, I separate the components with a space. To declare a variable to be of some type, I will write the type name in front of it.</p>

<p>We can define a boolean value purely as a type:</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span>    <span class="n">datatype</span> <span class="kt">Bool</span> <span class="ow">=</span>  <span class="kt">True</span> <span class="o">|</span> <span class="kt">False</span>
</code></pre></div>
<p>And we can use this as</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span>    <span class="kt">Bool</span> <span class="n">ok</span> <span class="ow">=</span> <span class="kt">True</span>
</code></pre></div>
<p>This means that <code>ok</code> is a variable of type <code>Bool</code> with a value of <code>True</code>. In an algebraic data type, the labels are called &#39;constructors&#39;. So <code>True</code> is a constructor that takes no arguments.</p>

<p>For a product type, we could for example create a type for an RGB colour triplet:</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span>    <span class="n">datatype</span> <span class="kt">RGBColour</span> <span class="ow">=</span> <span class="kt">RGB</span> <span class="kt">Int</span> <span class="kt">Int</span> <span class="kt">Int</span>
</code></pre></div>
<p>The <code>RGB</code> label on the right-hand side is the constructor of the type. It takes three arguments of type <code>Int</code>:</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span>    <span class="kt">RGBColour</span> <span class="n">aquamarine</span> <span class="ow">=</span> <span class="kt">RGB</span> <span class="mi">127</span> <span class="mi">255</span> <span class="mi">212</span>
</code></pre></div>
<p>So <code>aquamarine</code> is a variable of type <code>RGBColour</code> with a value of <code>RGB 127 255 212</code>. </p>

<p>The constructor identifies the type. Suppose we also have an HSL colour type</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span>    <span class="n">datatype</span> <span class="kt">HSLColour</span> <span class="ow">=</span> <span class="kt">HSL</span> <span class="kt">Int</span> <span class="kt">Int</span> <span class="kt">Int</span>
</code></pre></div>
<p>with a variable <code>chocolate</code> of that type:</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span>    <span class="kt">HSLColour</span> <span class="n">chocolate</span> <span class="ow">=</span> <span class="kt">HSL</span> <span class="mi">25</span> <span class="mi">75</span> <span class="mi">47</span>
</code></pre></div>
<p>then both <code>RGB</code> and <code>HSL</code> are triplets of <code>Int</code> but because of the different type constructors they are not the same type. </p>

<p>Let&#39;s say we create an RGB Pixel type:</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span>    <span class="n">datatype</span> <span class="kt">XYCoord</span> <span class="ow">=</span> <span class="kt">XY</span> <span class="kt">Int</span> <span class="kt">Int</span>
    <span class="n">datatype</span> <span class="kt">RGBPixel</span>  <span class="ow">=</span> <span class="kt">Pixel</span> <span class="kt">RGBColour</span> <span class="kt">XYCoord</span>
</code></pre></div>
<p>then </p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span>    <span class="kt">RGBPixel</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">Pixel</span> <span class="n">aquamarine</span> <span class="p">(</span><span class="kt">XY</span> <span class="mi">42</span> <span class="mi">24</span><span class="p">)</span>
</code></pre></div>
<p>is fine but</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span>    <span class="kt">RGBPixel</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">Pixel</span> <span class="n">chocolate</span> <span class="p">(</span><span class="kt">XY</span> <span class="mi">42</span> <span class="mi">24</span><span class="p">)</span>
</code></pre></div>
<p>will be a type error because <code>chocolate</code> is of type <code>HSLColour</code>, not <code>RGBColour</code>. </p>

<p>We could support both RGB and HSL using a sum type:</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span>    <span class="n">datatype</span> <span class="kt">Colour</span> <span class="ow">=</span> <span class="kt">HSL</span> <span class="kt">HSLColour</span> <span class="o">|</span> <span class="kt">RGB</span> <span class="kt">RGBColour</span>
</code></pre></div>
<p>and change make a Pixel type definition:</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span>    <span class="n">datatype</span> <span class="kt">Pixel</span> <span class="ow">=</span> <span class="kt">Pixel</span> <span class="kt">Colour</span> <span class="kt">XYCoord</span>
</code></pre></div>
<p>And now we can say </p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span>    <span class="kt">Pixel</span> <span class="n">p_rgb</span> <span class="ow">=</span> <span class="kt">Pixel</span> <span class="p">(</span><span class="kt">RGB</span> <span class="n">aquamarine</span><span class="p">)</span> <span class="p">(</span><span class="kt">XY</span> <span class="mi">42</span> <span class="mi">24</span><span class="p">)</span>
    <span class="kt">Pixel</span> <span class="n">p_hsl</span> <span class="ow">=</span> <span class="kt">Pixel</span> <span class="p">(</span><span class="kt">HSL</span> <span class="n">chocolate</span><span class="p">)</span> <span class="p">(</span><span class="kt">XY</span> <span class="mi">42</span> <span class="mi">24</span><span class="p">)</span>
</code></pre></div>
<h3>Integers and strings, recursion and polymorphism</h3>

<p>I can hear you say: but what about <code>Int</code>, it doesn&#39;t have constructors? And what about a string, how can that be an algebraic data type? These are interesting questions as they allow me to introduce two more concepts: <em>recursive</em> and <em>polymorphic</em> types.</p>

<h4>The type of an integer and recursive types</h4>

<p>From a type perspective, you can look at an integer in two ways: if it is a fixed-size integer then the <code>Int</code> type can be seen as a sum type. For example, the type for an 8-bit unsigned integer could be</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span>    <span class="n">datatype</span> <span class="kt">UInt8</span> <span class="ow">=</span> <span class="mi">0</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">|</span> <span class="o">...</span> <span class="o">|</span> <span class="mi">255</span>
</code></pre></div>
<p>In other words, every number is actually the name of a type constructor, as a generalisation of the <code>Bool</code> type.</p>

<p>However, in the mathematical sense, integers are not finite. If we consider the case of the natural numbers, we can construct a type for them as follows:</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span>    <span class="n">datatype</span> <span class="kt">Nat</span> <span class="ow">=</span> <span class="kt">Z</span> <span class="o">|</span> <span class="kt">S</span> <span class="kt">Nat</span>
</code></pre></div>
<p>The <code>Z</code> stands for &quot;zero&quot;, the <code>S</code> for &quot;successor of&quot;. This is a <em>recursive</em> type, because the <code>S</code> constructor takes a <code>Nat</code> as argument. With this type, we can now create any natural number:</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span>    <span class="kt">Nat</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kt">Z</span>
    <span class="kt">Nat</span> <span class="mi">1</span> <span class="ow">=</span> <span class="kt">S</span> <span class="kt">Z</span>
    <span class="kt">Nat</span> <span class="mi">2</span> <span class="ow">=</span> <span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">)</span>
    <span class="kt">Nat</span> <span class="mi">3</span> <span class="ow">=</span> <span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">))</span>
    <span class="o">...</span>
</code></pre></div>
<p>This way of constructing the natural numbers is called <a href="https://www.britannica.com/science/Peano-axioms">Peano numbers</a>.</p>

<h4>The type of a string and polymorphic types</h4>

<p>Now, what about strings? Enumerating all possible strings of any length is not practical. But from a type perspective, a string is a list of characters. So the question is then: what is the type of a list? For one thing, a list must be able to contain values of any type. (In the context of algebraic datatypes, all values must be the same, so our list is more like a typed array in Raku.) But that means we need types that can be parameterised by other types. This is called <em>parametric polymorphism</em>. So a list type must look something like</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span>    <span class="n">datatype</span> <span class="kt">List</span> <span class="n">a</span> <span class="ow">=</span> <span class="o">...</span>
</code></pre></div>
<p>where <code>a</code> is a type variable, i.e. it can be replaced by an arbitrary type. For example, assuming we define the <code>Char</code> type simply by enumerating all characters in the alphabet (because of course, at machine level, every character is represented by an integer number):</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span>    <span class="n">datatype</span> <span class="kt">Char</span> <span class="ow">=</span> <span class="sc">&#39;a&#39;</span> <span class="o">|</span> <span class="sc">&#39;b&#39;</span> <span class="o">|</span> <span class="sc">&#39;c&#39;</span> <span class="o">|</span> <span class="o">...</span> <span class="o">|</span> <span class="sc">&#39;z&#39;</span>
</code></pre></div>
<p>Then we can type our string as: </p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span>    <span class="kt">List</span> <span class="kt">Char</span> <span class="n">str</span> <span class="ow">=</span> <span class="o">...</span>
</code></pre></div>
<p>But what about <code>List</code>? We use a similar approach as for <code>Nat</code> above, using a recursive sum type:</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span>    <span class="n">datatype</span> <span class="kt">List</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">EmptyList</span> <span class="o">|</span> <span class="kt">Cons</span> <span class="n">a</span> <span class="p">(</span><span class="kt">List</span> <span class="n">a</span><span class="p">)</span>
</code></pre></div>
<p>Now we can create a list of any length:</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span>    <span class="kt">List</span> <span class="kt">Char</span> <span class="n">str</span> <span class="ow">=</span> 
         <span class="kt">Cons</span> <span class="sc">&#39;h&#39;</span> 
        <span class="p">(</span><span class="kt">Cons</span> <span class="sc">&#39;e&#39;</span> 
        <span class="p">(</span><span class="kt">Cons</span> <span class="sc">&#39;l&#39;</span> 
        <span class="p">(</span><span class="kt">Cons</span> <span class="sc">&#39;l&#39;</span> 
        <span class="p">(</span><span class="kt">Cons</span> <span class="sc">&#39;o&#39;</span> 
        <span class="kt">EmptyList</span><span class="p">))))</span>
</code></pre></div>
<p>Using the typical syntactic sugar for lists, we can write this as     </p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span>    <span class="kt">List</span> <span class="kt">Char</span> <span class="n">str</span> <span class="ow">=</span> <span class="p">[</span> <span class="sc">&#39;h&#39;</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="sc">&#39;l&#39;</span><span class="p">,</span> <span class="sc">&#39;l&#39;</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span> <span class="p">]</span>
</code></pre></div>
<p>If I now invent an alias <code>Str</code> for <code>List Char</code>, and use double quotes instead of list notation, I can write    </p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span>    <span class="kt">Str</span> <span class="n">str</span> <span class="ow">=</span> <span class="s">&quot;hello&quot;</span>
</code></pre></div>
<p>So integers and strings can be expressed as algebraic data types, and now we have introduced recursive and parameterised types. Time to move on to Raku!</p>

<h3>What are algebraic data types good for?</h3>

<p>These may seem like rather contrived examples, after all a language like Raku already has an Int and a Str type that work very well. So what is the use of these  algebraic data types? Of course the purpose of static types is to provide type safety and make debugging easier. But using algebraic data types also makes a different, more functional style of programming possible.<br>
One common use case is a list where you want to store values of different types: you can create a sum type that has an alternative for each of these types. Another common case is a recursive type, such as a tree. Finally, the polymorphism provides a convenient way to create custom containers. I will give examples of each of these in the next section.</p>

<h2>Algebraic data types in Raku</h2>

<p>Raku has <a href="https://raku.guide/">gradual typing</a>: it allows both static and dynamic typing. That&#39;s a good start because we need static typing to support algebraic data types. It also has <a href="https://docs.raku.org/language/variables">immutable variables</a> and <a href="https://raku.guide/#_anonymous_functions">anonymous functions</a>, and even <a href="https://docs.raku.org/language/list#index-entry-laziness_in_Iterable_objects">(limited) laziness</a>. And of course <a href="https://raku.guide/#_functional_programming">functions are first-class citizens</a>, so we have everything we need for pure, statically-typed functional programming. But what about the algebraic data types?</p>

<p>In Raku, <code>enum</code>s are sum types:</p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span>    <span class="k">enum</span> <span class="nb">Bool</span> <span class="s">&lt;False True&gt;</span>
</code></pre></div>
<p>However, they are limited to type constructors that don&#39;t take any arguments. </p>

<p>Classes can be seen as product types:</p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span>    <span class="k">class</span> <span class="n">BoolAndInt</span> {
        <span class="k">has</span> <span class="nb">Bool</span> <span class="nv">$.bool</span>;
        <span class="k">has</span> <span class="nb">Int</span> <span class="nv">$.int</span>;
    }
</code></pre></div>
<p>However, classes do not support parametric polymorphism. </p>

<p>This is where <em>roles</em> come in. According to the <a href="https://docs.raku.org/language/objects#Roles">Raku documentation</a>:</p>

<blockquote>
Roles are a collection of attributes and methods; however, unlike classes, roles are meant for describing only parts of an object's behavior; this is why, in general, roles are intended to be mixed in classes and objects. In general, classes are meant for managing objects and roles are meant for managing behavior and code reuse within objects.
</blockquote>

<p>Roles use the keyword <code>role</code> preceding the name of the role that is declared. Roles are mixed in using the <code>does</code> keyword preceding the name of the role that is mixed in. </p>

<p>In particular, roles can be mixed into other roles, and that is one of the key features I will exploit. Furthermore, role constructors can take arguments <em>and</em> they are parametric. So we have everything we need to create proper algebraic data types. Let&#39;s look at a few examples.</p>

<h3>A few simple examples</h3>

<h4>An opinionated boolean</h4>

<p>This is the example of a sum type for a boolean as above, but implemented with roles. The first line declares the type as an empty role, this corresponds to the data type name on the left-hand side. The next lines define the alternatives, each alternative uses <code>does OpinionatedBool</code> to tie it to the <code>OpinionatedBool</code> role which functions purely as the type name.  </p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="k">role</span> <span class="n">OpinionatedBool</span> {}
<span class="k">role</span> <span class="n">AbsolutelyTrue</span> <span class="nb">does</span> <span class="n">OpinionatedBool</span> {}
<span class="k">role</span> <span class="n">TotallyFalse</span> <span class="nb">does</span> <span class="n">OpinionatedBool</span> {}
</code></pre></div>
<p>In Raku, types are values; and for a role with an empty body, you don&#39;t need the <code>.new</code> constructor call:</p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="k">my</span> <span class="n">OpinionatedBool</span> \<span class="n">bt</span> = <span class="n">AbsolutelyTrue</span>;
</code></pre></div>
<p>Sum types can be used in combination with Raku&#39;s <code>multi sub</code> feature: Raku lets you provide several definitions for a function, with the same name but different signatures. With multi subs we can do what is known as pattern matching on types:</p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="k">multi</span> <span class="k">sub</span> <span class="n">p</span>(<span class="n">AbsolutelyTrue</span> <span class="nv">$b</span>) {
    <span class="nb">say</span> <span class="s">&#39;True&#39;</span>;
}
<span class="k">multi</span> <span class="k">sub</span> <span class="n">p</span>(<span class="n">TotallyFalse</span> <span class="nv">$b</span>) {
    <span class="nb">say</span> <span class="s">&#39;False&#39;</span>;
}

<span class="c1"># Trying it out:</span>
<span class="n">p</span>(<span class="n">bt</span>); <span class="c1"># prints True</span>
<span class="n">p</span>(<span class="n">bi</span>); <span class="c1"># also prints True</span>
</code></pre></div>
<p>Because we use a type as a value, to test if a value is <code>AbsolutelyTrue</code> or <code>TotallyFalse</code>, we can use either the smart match <code>~~</code>, the container identity <code>=:=</code> or the value identity <code>===</code>! If we would create an instance like <code>AbsolutelyTrue.new</code> See the <a href="https://github.com/wimvanderbauwhede/raku-examples/blob/master/roles_types_and_instances.raku">code example</a> for more details.</p>

<h4>The Colour, XYCoord and Pixel types</h4>

<p>Here is the implementation of the <code>Colour</code>, <code>XYCoord</code> and <code>Pixel</code> types from above. The <code>RGBColour</code> type is an example of a product type. There are two differences with my notation from above:</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span><span class="nf">datatype</span> <span class="kt">RGBColour</span> <span class="ow">=</span> <span class="kt">RGB</span> <span class="kt">Int</span> <span class="kt">Int</span> <span class="kt">Int</span>
</code></pre></div>
<ol>
<li>Because the role serves both as the type (<code>RGBColour</code>) and the instance constructor (<code>RGB</code>), they must have the same name. I only named them differently to make it easier to distinguish them so this is not an issue.</li>
<li>The types that make up each field must be named with unique names in the role&#39;s argument list, and need to have a corresponding attributes declared. That is again not really a limitation, because acessors for record type fields are handy. So it looks like:</li>
</ol>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="k">role</span> <span class="n">RGBColour</span>[<span class="nb">Int</span> \<span class="n">r</span>, <span class="nb">Int</span> \<span class="n">g</span>, <span class="nb">Int</span> \<span class="n">b</span>] {
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">$.r</span> = <span class="n">r</span>;
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">$.g</span> = <span class="n">g</span>;
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">$.b</span> = <span class="n">b</span>; 
}
</code></pre></div>
<p>And we create <code>aquamarine</code> like this:</p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="k">my</span> <span class="n">RGBColour</span> \<span class="n">aquamarine</span> = <span class="n">RGBColour</span>[ <span class="mi">127</span>, <span class="mi">255</span>, <span class="mi">212</span>].<span class="nb">new</span>;
</code></pre></div>
<p>The definitions of <code>HSLColour</code> and <code>XYCoord</code> are analogous, you can find them in the <a href="https://github.com/wimvanderbauwhede/raku-examples/blob/master/role_as_adt_colour_example.raku">code example</a>. Let&#39;s look at the sum type to combine the RGB and HSL colour types:</p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="k">role</span> <span class="n">Colour</span> {}
<span class="k">role</span> <span class="n">HSL</span>[ <span class="n">HSLColour</span> \<span class="n">hsl</span>] <span class="nb">does</span> <span class="n">Colour</span> {
    <span class="k">has</span> <span class="n">HSLColour</span> <span class="nv">$.hsl</span> = <span class="n">hsl</span>;
};
<span class="k">role</span> <span class="n">RGB</span>[ <span class="n">RGBColour</span> \<span class="n">rgb</span>] <span class="nb">does</span> <span class="n">Colour</span> {
    <span class="k">has</span> <span class="n">RGBColour</span> <span class="nv">$.rgb</span> = <span class="n">rgb</span>;
};
</code></pre></div>
<p>This is essentially the same approach as for the opinionated boolean, but we don&#39;t have empty roles: the <code>HSL</code> alternative takes an argument of type <code>HSLColour</code>, and the <code>RGB</code> alternative takes an argument of type <code>RGBColour</code>.
As in the product type, we use the role as a container to hold the values. The <code>Pixel</code> type from above looks like: </p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="k">role</span> <span class="n">Pixel</span>[ <span class="n">Colour</span> \<span class="n">c</span>, <span class="n">XYCoord</span> \<span class="n">xy</span> ] {
    <span class="k">has</span> <span class="n">Colour</span> <span class="nv">$.c</span> = <span class="n">c</span>;
    <span class="k">has</span> <span class="n">XYCoord</span> <span class="nv">$.xy</span> = <span class="n">xy</span>;
}
</code></pre></div>
<p>And now we can create pixels with RGB and HSL colours:</p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="k">my</span> <span class="n">Pixel</span> \<span class="n">p_rgb</span> = <span class="n">Pixel</span>[ <span class="n">RGB</span>[ <span class="n">aquamarine</span>].<span class="nb">new</span> , <span class="n">XYCoord</span>[ <span class="mi">42</span>, <span class="mi">24</span>].<span class="nb">new</span> ].<span class="nb">new</span>;
<span class="k">my</span> <span class="n">Pixel</span> \<span class="n">p_hsl</span> = <span class="n">Pixel</span>[ <span class="n">HSL</span>[ <span class="n">chocolate</span> ].<span class="nb">new</span> , <span class="n">XYCoord</span>[ <span class="mi">42</span>, <span class="mi">24</span>].<span class="nb">new</span> ].<span class="nb">new</span>;
</code></pre></div>
<h4>Recursion and polymorphism</h4>

<p>Above, I showed the Peano number type to illustrate type-level recursion. This works just fine with roles in Raku too:</p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="k">role</span> <span class="n">Nat</span>{}    
<span class="k">role</span> <span class="o">Z</span> <span class="nb">does</span> <span class="n">Nat</span> {}
<span class="k">role</span> <span class="n">S</span>[<span class="n">Nat</span> <span class="nv">$n</span>] <span class="nb">does</span> <span class="n">Nat</span> {}  
</code></pre></div>
<p>And we can combine this with type parameters as in the list example:</p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="k">role</span> <span class="nb">List</span>[::<span class="n">a</span>] {}
<span class="k">role</span> <span class="n">EmptyList</span>[::<span class="n">a</span>] <span class="nb">does</span> <span class="nb">List</span>[<span class="n">a</span>] {}
<span class="k">role</span> <span class="n">Cons</span>[ ::<span class="n">a</span> \<span class="n">elt</span>, <span class="nb">List</span> \<span class="n">lst</span> ] <span class="nb">does</span> <span class="nb">List</span>[<span class="n">a</span>] {
    <span class="k">has</span> <span class="nv">$.elt</span> = <span class="n">elt</span>;
    <span class="k">has</span> <span class="nv">$.lst</span> = <span class="n">lst</span>;
}
</code></pre></div>
<h5>Issues with current raku</h5>

<p>There are some issues here: </p>

<ul>
<li>The <code>EmptyList</code> alternative must either be declared as above, with a type parameter, or as</li>
</ul>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="k">role</span> <span class="n">EmptyList</span> <span class="nb">does</span> <span class="nb">List</span> {}
</code></pre></div>
<p>where the type also doesn&#39;t take a type variable. We can&#39;t write</p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="k">role</span> <span class="n">EmptyList</span> <span class="nb">does</span> <span class="nb">List</span>[::<span class="n">a</span>] {}
</code></pre></div>
<p>This is of course only a minor issue, resulting only in some redundancy.</p>

<ul>
<li>A more serious issue is that the type of <code>lst</code> must be <code>List</code> (or <code>List[]</code>) instead of <code>List[a]</code>. That is actually a problem, as it weakens the type checking. So it must be a bug in the current version of raku (2020.01). If I provide List[a] I get the following error:</li>
</ul>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    Could not instantiate role &#39;Cons&#39;:
    Internal error: inconsistent bind result
    in any protect at gen/moar/stage2/NQPCORE.setting line 1216
    in block &lt;unit&gt; at list-adt.raku line 12
</code></pre></div>
<h3>A few more useful examples</h3>

<h4>A multi-type array</h4>

<p>For the first example, I want to store values of different types in a typed array. They elements can be strings, labeled lists of strings, or undefined. I call this type <code>Matches</code>. Using the notation from above, it would be</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span><span class="nf">datatype</span> <span class="kt">Matches</span> <span class="ow">=</span> 
      <span class="kt">Match</span> <span class="kt">Str</span> 
    <span class="o">|</span> <span class="kt">TaggedMatches</span> <span class="kt">Str</span> <span class="p">(</span><span class="kt">List</span> <span class="kt">Matches</span><span class="p">)</span> 
    <span class="o">|</span> <span class="kt">UndefinedMatch</span>
</code></pre></div>
<p>In Raku, it is defined as follows:</p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span>    <span class="k">role</span> <span class="n">Matches</span> {}
    <span class="k">role</span> <span class="n">UndefinedMatch</span> <span class="nb">does</span> <span class="n">Matches</span> {}
    <span class="k">role</span> <span class="nb">Match</span>[<span class="nb">Str</span> <span class="nv">$str</span>] <span class="nb">does</span> <span class="n">Matches</span> {
        <span class="k">has</span> <span class="nb">Str</span> <span class="nv">$.match</span>=<span class="nv">$str</span>;
    } 
    <span class="k">role</span> <span class="n">TaggedMatches</span>[<span class="nb">Str</span> <span class="nv">$tag</span>, <span class="n">Matches</span> <span class="nv">@ms</span>] <span class="nb">does</span> <span class="n">Matches</span> {
        <span class="k">has</span> <span class="nb">Str</span> <span class="nv">$.tag</span> = <span class="nv">$tag</span>;
        <span class="k">has</span> <span class="n">Matches</span> <span class="nv">@.matches</span> = <span class="nv">@ms</span>;
    } 
</code></pre></div>
<p>This type uses type constructors with 0 (<code>UndefinedMatch</code>), 1 (<code>Match</code>) and 2 (<code>TaggedMatches</code>) arguments, and the latter is a recursive type: the second argument is a list of <code>Matches</code>. With this definition, we can create an array of matches like this:</p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span>    <span class="k">my</span> <span class="n">Matches</span> <span class="nv">@ms</span> = <span class="nb">Array</span>[<span class="n">Matches</span>].<span class="nb">new</span>(
        <span class="nb">Match</span>[<span class="s">&quot;hello&quot;</span>].<span class="nb">new</span>,
        <span class="n">TaggedMatches</span>[
            <span class="s">&quot;Adjectives&quot;</span>,
            <span class="nb">Array</span>[<span class="n">Matches</span>].<span class="nb">new</span>(
                <span class="nb">Match</span>[<span class="s">&quot;brave&quot;</span>].<span class="nb">new</span>,
                <span class="nb">Match</span>[<span class="s">&quot;new&quot;</span>].<span class="nb">new</span>) 
                ].<span class="nb">new</span>,
        <span class="nb">Match</span>[<span class="s">&quot;world&quot;</span>].<span class="nb">new</span>
        );
</code></pre></div>
<p>As you can see, the typed values are actually constructed by calling <code>.new</code>. It is a bit nicer to create constructor functions, and once Raku has a more developped macro system, we might be able to generate these automatically.</p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span>    <span class="k">my</span> <span class="n">Matches</span> <span class="nv">@ms</span> = <span class="n">mkMatches</span>(
        <span class="n">mkMatch</span> <span class="s">&quot;hello&quot;</span>,
        <span class="n">mkTaggedMatches</span>(
            <span class="s">&quot;Adjectives&quot;</span>,
            <span class="n">mkMatches</span>(
                <span class="n">mkMatch</span> <span class="s">&quot;brave&quot;</span>,
                <span class="n">mkMatch</span> <span class="s">&quot;new&quot;</span> 
                )
        ),
        <span class="n">mkMatch</span> &quot;<span class="n">world</span>)
        );
</code></pre></div>
<p><a href="https://github.com/wimvanderbauwhede/raku-examples/blob/master/roles_as_types.raku">Code for this example</a></p>

<h4>A generic tuple</h4>

<p>For the next example, I want to define a type called <code>Either</code>. This is a parametric sum type with two parameters, so a kind of generic tuple:</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span><span class="nf">datatype</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Right</span> <span class="n">b</span>
</code></pre></div>
<p>In Raku, this can be done through the use of type variables as parameters for the role:</p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span>    <span class="k">role</span> <span class="n">Either</span>[::<span class="n">a</span>,::<span class="n">b</span>] { }
    <span class="k">role</span> <span class="n">Left</span>[::<span class="n">a</span> \<span class="n">l</span>,::<span class="n">b</span>] <span class="nb">does</span> <span class="n">Either</span>[<span class="n">a</span>,<span class="n">b</span>] { 
        <span class="k">has</span> <span class="n">a</span> <span class="nv">$.left</span> = <span class="n">l</span>;
    }
    <span class="k">role</span> <span class="n">Right</span>[::<span class="n">a</span>,::<span class="n">b</span> \<span class="n">r</span>] <span class="nb">does</span> <span class="n">Either</span>[<span class="n">a</span>,<span class="n">b</span>] { 
        <span class="k">has</span> <span class="n">b</span> <span class="nv">$.right</span> = <span class="n">r</span>;
    }
</code></pre></div>
<p>Because Raku expects both type variables to be declared in each constructor, it is a little bit less nice than my more abstract notation. We can pattern match on this type with a <code>multi sub</code>: </p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="k">multi</span> <span class="k">sub</span> <span class="n">test</span> (<span class="n">Left</span>[<span class="nb">Int</span>,<span class="nb">Str</span>] <span class="nv">$v</span>) { <span class="nb">say</span> <span class="s">&#39;Left: &#39;</span>~<span class="nv">$v</span>.<span class="n">left</span> }
<span class="k">multi</span> <span class="k">sub</span> <span class="n">test</span> (<span class="n">Right</span>[<span class="nb">Int</span>,<span class="nb">Str</span>] <span class="nv">$v</span>) {<span class="nb">say</span> <span class="s">&#39;Right: &#39;</span>~<span class="nv">$v</span>.<span class="n">right</span> }
</code></pre></div>
<p>So we can write</p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="k">my</span> <span class="n">Either</span>[<span class="nb">Int</span>,<span class="nb">Str</span>] \<span class="n">iv</span> = <span class="n">Left</span>[<span class="mi">42</span>,<span class="nb">Str</span>].<span class="nb">new</span>;
<span class="k">my</span> <span class="n">Either</span>[<span class="nb">Int</span>,<span class="nb">Str</span>] \<span class="n">sv</span> = <span class="n">Right</span>[<span class="nb">Int</span>,<span class="s">&#39;forty-two&#39;</span>].<span class="nb">new</span>;

<span class="n">test</span>(<span class="n">iv</span>); <span class="c1"># prints &#39;Left: 42&#39;</span>
<span class="n">test</span>(<span class="n">sv</span>); <span class="c1"># prints &#39;Right: forty-two&#39;</span>
</code></pre></div>
<p><a href="https://github.com/wimvanderbauwhede/raku-examples/blob/master/either.raku">Code for this example</a></p>

<h4>A parameterised binary tree</h4>

<p>As a final example, here is a simple binary tree. First, let&#39;s look at an example implementation using a role from the <a href="https://docs.raku.org/language/objects#index-entry-Parameterized_Roles">Raku documentation</a>:</p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="k">role</span> <span class="n">BinaryTree</span>[::<span class="n">Type</span>] {
    <span class="k">has</span> <span class="n">BinaryTree</span>[<span class="n">Type</span>] <span class="nv">$.left</span>;
    <span class="k">has</span> <span class="n">BinaryTree</span>[<span class="n">Type</span>] <span class="nv">$.right</span>;
    <span class="k">has</span> <span class="n">Type</span> <span class="nv">$.node</span>;

    <span class="k">method</span> <span class="n">visit-preorder</span>(<span class="nv">&amp;cb</span>) {
        <span class="n">cb</span> <span class="nv">$.node</span>;
        <span class="k">for</span> <span class="nv">$.left</span>, <span class="nv">$.right</span> -&gt; <span class="nv">$branch</span> {
            <span class="nv">$branch</span>.<span class="n">visit-preorder</span>(<span class="nv">&amp;cb</span>) <span class="k">if</span> <span class="nb">defined</span> <span class="nv">$branch</span>;
        }
    }
    <span class="k">method</span> <span class="n">visit-postorder</span>(<span class="nv">&amp;cb</span>) {
        <span class="k">for</span> <span class="nv">$.left</span>, <span class="nv">$.right</span> -&gt; <span class="nv">$branch</span> {
            <span class="nv">$branch</span>.<span class="n">visit-postorder</span>(<span class="nv">&amp;cb</span>) <span class="k">if</span> <span class="nb">defined</span> <span class="nv">$branch</span>;
        }
        <span class="n">cb</span> <span class="nv">$.node</span>;
    }
    <span class="k">method</span> <span class="n">new-from-list</span>(<span class="vg">::?CLASS</span>:<span class="n">U:</span> *<span class="nv">@el</span>) {
        <span class="k">my</span> <span class="nv">$middle-index</span> = <span class="nv">@el</span>.<span class="nb">elems</span> <span class="o">div</span> <span class="mi">2</span>;
        <span class="k">my</span> <span class="nv">@left</span>         = <span class="nv">@el</span>[<span class="mi">0</span> .. <span class="nv">$middle-index</span> - <span class="mi">1</span>];
        <span class="k">my</span> <span class="nv">$middle</span>       = <span class="nv">@el</span>[<span class="nv">$middle-index</span>];
        <span class="k">my</span> <span class="nv">@right</span>        = <span class="nv">@el</span>[<span class="nv">$middle-index</span> + <span class="mi">1</span> .. *];
        <span class="k">self</span>.<span class="nb">new</span>(
            <span class="n">node</span>    =&gt; <span class="nv">$middle</span>,
            <span class="n">left</span>    =&gt; <span class="nv">@left</span>  ?? <span class="k">self</span>.<span class="n">new-from-list</span>(<span class="nv">@left</span>)  !! <span class="k">self</span>,
            <span class="n">right</span>   =&gt; <span class="nv">@right</span> ?? <span class="k">self</span>.<span class="n">new-from-list</span>(<span class="nv">@right</span>) !! <span class="k">self</span>,
        );
    }
}

<span class="k">my</span> <span class="nv">$t</span> = <span class="n">BinaryTree</span>[<span class="nb">Int</span>].<span class="n">new-from-list</span>(<span class="mi">4</span>, <span class="mi">5</span>, <span class="mi">6</span>);
<span class="nv">$t</span>.<span class="n">visit-preorder</span>(<span class="nv">&amp;say</span>);    <span class="c1"># OUTPUT: «5␤4␤6␤» </span>
<span class="nv">$t</span>.<span class="n">visit-postorder</span>(<span class="nv">&amp;say</span>);   <span class="c1"># OUTPUT: «4␤6␤5␤» </span>
</code></pre></div>
<p>This example is written in Raku&#39;s object-oriented style, with methods acting on the attributes of the role. Let&#39;s see how we can write this in a functional style.</p>

<p>The algebraic data type for this binary tree is:</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span><span class="nf">datatype</span> <span class="kt">BinaryTree</span> <span class="n">a</span> <span class="ow">=</span> 
      <span class="kt">Node</span> <span class="p">(</span><span class="kt">BinaryTree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">BinaryTree</span> <span class="n">a</span><span class="p">)</span> <span class="n">a</span> 
    <span class="o">|</span> <span class="kt">Tip</span>
</code></pre></div>
<p>The <code>Tip</code> alternative is for the empty leaf nodes of the tree, which in the above example are left undefined. In Raku, we can implement this type as: </p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="k">role</span> <span class="n">BinaryTree</span>[::<span class="n">Type</span>] { }
<span class="k">role</span> <span class="n">Node</span>[::<span class="n">Type</span>,  \<span class="n">l</span>,  \<span class="n">r</span>, \<span class="n">n</span>] <span class="nb">does</span> <span class="n">BinaryTree</span>[<span class="n">Type</span>] { 
    <span class="k">has</span> <span class="n">BinaryTree</span>[<span class="n">Type</span>] <span class="nv">$.left</span> = <span class="n">l</span>;
    <span class="k">has</span> <span class="n">BinaryTree</span>[<span class="n">Type</span>] <span class="nv">$.right</span> = <span class="n">r</span>;
    <span class="k">has</span> <span class="n">Type</span> <span class="nv">$.node</span> = <span class="n">n</span>;
}
<span class="k">role</span> <span class="n">Tip</span>[::<span class="n">Type</span>] <span class="nb">does</span> <span class="n">BinaryTree</span>[<span class="n">Type</span>] { }
</code></pre></div>
<p>Instead of the methods we use functions, implemented as <code>multi sub</code>s. Most of the code is of course identical, but there is no need for conditionals to check if a leaf node has been reached. I have also used sigil-less immutable variables.</p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="k">multi</span> <span class="k">sub</span> <span class="n">visit-preorder</span>(<span class="n">Node</span> \<span class="n">n</span>,<span class="nv">&amp;cb</span>) {
    <span class="n">cb</span> <span class="n">n</span>.<span class="n">node</span>;
    <span class="k">for</span> <span class="n">n</span>.<span class="n">left</span>, <span class="n">n</span>.<span class="n">right</span> -&gt; \<span class="n">branch</span> {
        <span class="n">visit-preorder</span>(<span class="n">branch</span>,<span class="nv">&amp;cb</span>)
    }
}
<span class="k">multi</span> <span class="k">sub</span> <span class="n">visit-preorder</span>(<span class="n">Tip</span>,<span class="nv">&amp;cb</span>) { }

<span class="k">multi</span> <span class="k">sub</span> <span class="n">visit-postorder</span>(<span class="n">Node</span> \<span class="n">n</span>,<span class="nv">&amp;cb</span>) {    
    <span class="k">for</span> <span class="n">n</span>.<span class="n">left</span>, <span class="n">n</span>.<span class="n">right</span> -&gt; \<span class="n">branch</span> {
        <span class="n">visit-postorder</span>(<span class="n">branch</span>,<span class="nv">&amp;cb</span>)
    }
    <span class="n">cb</span> <span class="n">n</span>.<span class="n">node</span>;
}
<span class="k">multi</span> <span class="k">sub</span> <span class="n">visit-postorder</span>(<span class="n">Tip</span>,<span class="nv">&amp;cb</span>) { }

<span class="k">multi</span> <span class="k">sub</span> <span class="n">new-from-list</span>(::<span class="n">T</span>,[]) {
    <span class="n">Tip</span>[<span class="nb">Int</span>].<span class="nb">new</span>    
}
<span class="k">multi</span> <span class="k">sub</span> <span class="n">new-from-list</span>(::<span class="n">T</span>,\<span class="n">el</span>) {
    <span class="k">my</span> \<span class="n">middle-index</span> = <span class="n">el</span>.<span class="nb">elems</span> <span class="o">div</span> <span class="mi">2</span>;
    <span class="k">my</span> \<span class="n">left</span>         = <span class="n">el</span>[<span class="mi">0</span> .. <span class="n">middle-index</span> - <span class="mi">1</span>];
    <span class="k">my</span> \<span class="n">middle</span>       = <span class="n">el</span>[<span class="n">middle-index</span>];
    <span class="k">my</span> \<span class="n">right</span>        = <span class="n">el</span>[<span class="n">middle-index</span> + <span class="mi">1</span> .. *];    
    <span class="n">Node</span>[<span class="n">T</span>,
        <span class="n">new-from-list</span>(<span class="n">T</span>,<span class="n">left</span>),
        <span class="n">new-from-list</span>(<span class="n">T</span>,<span class="n">right</span>),
        <span class="n">middle</span>            
    ].<span class="nb">new</span>;
}

<span class="k">my</span> <span class="n">BinaryTree</span>[<span class="nb">Int</span>] \<span class="n">t</span> = <span class="n">new-from-list</span>(<span class="nb">Int</span>,[<span class="mi">4</span>, <span class="mi">5</span>, <span class="mi">6</span>]);
<span class="n">visit-preorder</span>(<span class="n">t</span>,<span class="nv">&amp;say</span>);    <span class="c1"># OUTPUT: «5␤4␤6␤» </span>
<span class="n">visit-postorder</span>(<span class="n">t</span>,<span class="nv">&amp;say</span>);   <span class="c1"># OUTPUT: «4␤6␤5␤» </span>
</code></pre></div>
<p>One thing to note is that in the <code>multi sub</code>s we don&#39;t have to match against the full type, for example in <code>visit-preorder</code> we match against <code>Tip</code> and <code>Node</code> rather than the full <code>Tip[a]</code> and <code>Node[::a,BinaryTree[a],BinaryTree[a],a]</code>. </p>

<p><a href="https://github.com/wimvanderbauwhede/raku-examples/blob/master/binary_tree_2.p6">Code for this example</a></p>

<h2>Wrap-up</h2>

<p>Creating algebraic data types with Raku&#39;s roles is very straightforward. Any product type is simply a role with a number of typed attributes. The key idea for the sum type is to create an empty role and mix it in with other roles that become the type constructors for your alternatives. Because roles accept type parameters, we can have parametric polymorphism. And because a role can have attributes of its own type, we have recursive types as well. Combined with Raku&#39;s other functional programming features, this makes writing pure, statically typed functional code in Raku great fun.  </p>

<h3>References</h3>

<p>[1] <a href="https://codewords.recurse.com/issues/three/algebra-and-calculus-of-algebraic-data-types">&quot;The algebra (and calculus!) of algebraic data types&quot;, by Joel Burget</a>
<br/>
[2] <a href="https://gist.github.com/gregberns/5e9da0c95a9a8d2b6338afe69310b945">&quot;The Algebra of Algebraic Data Types, Part 1&quot;, by Chris Taylor</a></p>

				<hr />
				<footer class="page-footer">
					

<!--
<div class="author-image">
	<img src="https://wimvanderbauwhede.github.io/images/" alt="Wim Vanderbauwhede">
</div>
-->
<!-- ./author-image -->
<div class="author-content">
	<h3 class="author-name" >Written by <a href="http://www.dcs.gla.ac.uk/~wim" itemprop="author">Wim Vanderbauwhede</a></h3>
	<p class="author-bio"></p>
</div><!-- ./author-content -->

					
					<div class="page-meta">
	<p>Updated <time datetime="2020-06-05T00:00:00Z" itemprop="dateModified">June 05, 2020</time>
</div><!-- /.page-meta -->
				</footer><!-- /.footer -->
				<aside>
					
				</aside>
			</div><!-- /.content -->
		</div><!-- /.inner-wrap -->
		
	</article><!-- ./wrap -->
</div><!-- /#main -->


      <footer role="contentinfo" id="site-footer">
	<nav role="navigation" class="menu bottom-menu">
		<ul class="menu-item">
		
      
			<li><a href="https://wimvanderbauwhede.github.io/" >Wim Vanderbauwhede</a></li>
		
      
			<li><a href="https://wimvanderbauwhede.github.io/about/" >About</a></li>
		
		</ul>
	</nav><!-- /.bottom-menu -->
	<p class="copyright">&#169; 2020 <a href="https://wimvanderbauwhede.github.io">Wim Vanderbauwhede</a> <br> <a href="http://jekyllrb.com">Jekyll</a> theme <a href="http://mmistakes.github.io/skinny-bones-jekyll/">Skinny Bones</a></p>

<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
var sc_project=10807901;
var sc_invisible=1;
var sc_security="7dfdbc2d";
var scJsHost = (("https:" == document.location.protocol) ?
"https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" +
scJsHost+
"statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript><div class="statcounter"><a title="web stats"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="http://c.statcounter.com/10807901/0/7dfdbc2d/1/"
alt="web stats"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->

</footer>

    </div>

    <script src="https://wimvanderbauwhede.github.io/js/vendor/jquery-1.9.1.min.js"></script>
    <script src="https://wimvanderbauwhede.github.io/js/main.js"></script>

    

  </body>

</html>
