<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>A universal interpreter • Wim Vanderbauwhede</title>
    <meta name="description" content="The Böhm-Berarducci encoding of a type can be considered as a universal interpreter. We illustrate this in Raku with an evaluator and pretty printer.">
    <meta name="keywords" content="coding, hacking, programming, raku">
    
    	<!-- Twitter Cards -->
	<meta name="twitter:title" content="A universal interpreter">
	<meta name="twitter:description" content="The Böhm-Berarducci encoding of a type can be considered as a universal interpreter. We illustrate this in Raku with an evaluator and pretty printer.">
	<meta name="twitter:site" content="@wim_v12e">
	<meta name="twitter:creator" content="@wim_v12e">
	
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:image" content="https://wimvanderbauwhede.github.io/images/universal-interpreter-part-2_1600x600.jpg">
	
	<!-- Open Graph -->
	<meta property="og:locale" content="en_GB">
	<meta property="og:type" content="article">
	<meta property="og:site_name" content="Wim Vanderbauwhede">
	<meta property="og:url" content="https://wimvanderbauwhede.github.io/articles/universal-interpreter-part-2/#">
	<meta property="og:title" content="A universal interpreter">
	<meta property="og:description" content="The Böhm-Berarducci encoding of a type can be considered as a universal interpreter. We illustrate this in Raku with an evaluator and pretty printer.">
	<meta property="og:image" content="https://wimvanderbauwhede.github.io/images/universal-interpreter-part-2_1600x600.jpg" />

    

    <link rel="canonical" href="https://wimvanderbauwhede.github.io/articles/universal-interpreter-part-2/">

    <link href="https://wimvanderbauwhede.github.io/atom.xml" type="application/atom+xml" rel="alternate" title="Wim Vanderbauwhede Atom Feed">
    <link href="https://wimvanderbauwhede.github.io/sitemap.xml" type="application/xml" rel="sitemap" title="Sitemap">

    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="cleartype" content="on">
    <meta name="p:domain_verify" content="e31ad34d4267c0ac4d997da5cb5ea898"/>
    <meta http-equiv="X-Clacks-Overhead" content="GNU Natalie Nguyen" />
    <style>
    .sliding-menu-content {
      top: 0;
      right: 0;
      text-align: center;
      visibility: hidden;
      height: 100%;
      width: 100%;
      -webkit-transform: translateX(100%);
      -moz-transform: translateX(100%);
      -ms-transform: translateX(100%);
      -o-transform: translateX(100%);
      transform: translateX(100%);
    }
    </style>

    <link rel="stylesheet" href="https://wimvanderbauwhede.github.io/css/main.css">
    <link rel="stylesheet" href="https://wimvanderbauwhede.github.io/css/bjqs.css">
    <link rel="stylesheet" href="https://wimvanderbauwhede.github.io/tipuesearch/tipuesearch.css">
    <!-- HTML5 Shiv and Media Query Support for IE -->
    <!--[if lt IE 9]>
      <script src="https://wimvanderbauwhede.github.io/js/vendor/html5shiv.min.js"></script>
      <script src="https://wimvanderbauwhede.github.io/js/vendor/respond.min.js"></script>
    <![endif]-->
<!-- Google Analytics -->
<!-- WV: NO!
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-73376688-1', 'auto');
  ga('send', 'pageview');

</script>
-->
<!--
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-19948710-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
-->
    <!-- Include the jQuery library (local or CDN) -->
    <script src="https://wimvanderbauwhede.github.io/js/plugins/jquery-1.7.1.min.js"></script>

    <!-- Include the plugin *after* the jQuery library -->
    <script src="https://wimvanderbauwhede.github.io/js/plugins/bjqs-1.3.min.js"></script>
        
  </head>

  <body>
	  <!-- WV: NO!
    <div id="fb-root"></div>
    <script>(function(d, s, id) {
      var js, fjs = d.getElementsByTagName(s)[0];
      if (d.getElementById(id)) return;
      js = d.createElement(s); js.id = id;
      js.src = "//connect.facebook.net/en_GB/sdk.js#xfbml=1&version=v2.5";
      fjs.parentNode.insertBefore(js, fjs);
    }(document, 'script', 'facebook-jssdk'));</script>
    -->
    <header id="masthead">
  <div class="inner-wrap">
<a href="https://wimvanderbauwhede.github.io" class="site-title">&nbsp;</a>
    <nav role="navigation" class="menu top-menu">
        <ul class="menu-item">
	<li class="home"><a href="/">Wim Vanderbauwhede</a></li>
	

</ul>

    </nav>
<form style="float: right;" action="https://wimvanderbauwhede.github.io/search.html" ><input type="text" name="q" id="tipue_search_input" autocomplete="off" required></form>
  </div><!-- /.inner-wrap -->
</header><!-- /.masthead -->

    <nav role="navigation" class="js-menu sliding-menu-content">
	<ul class="menu-item">
		
	</ul>
</nav>
<button type="button" class="js-menu-trigger sliding-menu-button menulines-button x2" role="button" aria-label="Toggle Navigation">
	<span class="menulines"></span>
</button>

<div class="js-menu-screen menu-screen"></div>


    <div id="page-wrapper">

      <div id="main" role="main">
	<article class="wrap" itemscope itemtype="http://schema.org/Article">
		
		<div class="page-feature">
			<div class="page-image">
				<img src="https://wimvanderbauwhede.github.io/images/universal-interpreter-part-2_1600x600.jpg" class="page-feature-image" alt="A universal interpreter" itemprop="image">
				
			</div><!-- /.page-image -->
		</div><!-- /.page-feature -->
		
		<nav class="breadcrumbs">
  <a href="https://wimvanderbauwhede.github.io">Home</a> <span class="divider">/</span> <a href="https://wimvanderbauwhede.github.io/articles/">Articles</a> <span class="divider">/</span>
</nav><!-- /.breadcrumbs -->
		<div class="page-title">
			<h1>A universal interpreter</h1>
		</div>
		<div class="inner-wrap">
			<nav class="toc"></nav><!-- /.toc -->
			<div id="content" class="page-content" itemprop="articleBody">
				<p>In <a href="https://wimvanderbauwhede.github.io/articles/universal-interpreter-part-1">the previous article</a> I explained the basic idea behind a technique called <a href="http://okmij.org/ftp/tagless-final/course/Boehm-Berarducci.html">Böhm-Berarducci encoding</a> of algebraic data types, and showed a way to implement this technique in <a href="https://raku.org/">Raku</a>. Unless you are already familiar with this formalism, I recommend you read that article first. </p>

<p>In this article I want to illustrate how the Böhm-Berarducci (BB) encoding of a data structure based on algebraic data types can be considered as a universal interpreter. What this means is that it is easy to perform computations that turn the data structure into something else. As an example, I will demonstrate how to create an evaluator and pretty-printer for a parsed polynomial expression.</p>

<h2>A parse tree type</h2>

<p>Consider expressions of the form <code>a*x^2+b*x+c</code> or <code>x^3+1</code> or <code>x*y^2-x^2*y</code>. Let&#39;s assume we have a parser for such an expression, for example built using <a href="https://wimvanderbauwhede.github.io/articles/list-based-parser-combinators/">parser combinators</a>. Let&#39;s also assume that this parser returns the parsed data as an algebraic data type, defined in Haskell as:</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span><span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> 
      <span class="kt">Var</span> <span class="kt">String</span>
    <span class="o">|</span> <span class="kt">Par</span> <span class="kt">String</span> 
    <span class="o">|</span> <span class="kt">Const</span> <span class="kt">Int</span>
    <span class="o">|</span> <span class="kt">Pow</span> <span class="kt">Term</span> <span class="kt">Int</span>
    <span class="o">|</span> <span class="kt">Add</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span>
    <span class="o">|</span> <span class="kt">Mult</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span>
</code></pre></div>
<p>and in Raku:</p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="k">role</span> <span class="n">Term</span> {}
<span class="k">role</span> <span class="n">Var</span> [<span class="nb">Str</span> \<span class="n">v</span>] <span class="nb">does</span> <span class="n">Term</span> {
    <span class="k">has</span> <span class="nb">Str</span> <span class="nv">$.var</span> = <span class="n">v</span>;
}
<span class="k">role</span> <span class="n">Par</span> [<span class="nb">Str</span> \<span class="n">p</span>] <span class="nb">does</span> <span class="n">Term</span> {
    <span class="k">has</span> <span class="nb">Str</span> <span class="nv">$.par</span> = <span class="n">p</span>;
}
<span class="k">role</span> <span class="n">Const</span> [<span class="nb">Int</span> \<span class="n">c</span>] <span class="nb">does</span> <span class="n">Term</span> {
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">$.const</span> = <span class="n">c</span>;
}
<span class="k">role</span> <span class="n">Pow</span> [<span class="n">Term</span> \<span class="n">t</span>, <span class="nb">Int</span> \<span class="n">n</span>] <span class="nb">does</span> <span class="n">Term</span> {
    <span class="k">has</span> <span class="n">Term</span> <span class="nv">$.term</span> = <span class="n">t</span>;
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">$.exp</span> = <span class="n">n</span>;
}
<span class="k">role</span> <span class="n">Add</span> [<span class="nb">Array</span>[<span class="n">Term</span>] \<span class="n">ts</span>] <span class="nb">does</span> <span class="n">Term</span> {
    <span class="k">has</span> <span class="nb">Array</span>[<span class="n">Term</span>] <span class="nv">$.terms</span> = <span class="n">ts</span>;
}
<span class="k">role</span> <span class="n">Mult</span> [<span class="nb">Array</span>[<span class="n">Term</span>] \<span class="n">ts</span>] <span class="nb">does</span> <span class="n">Term</span> {
    <span class="k">has</span> <span class="nb">Array</span>[<span class="n">Term</span>] <span class="nv">$.terms</span> = <span class="n">ts</span>;
}
</code></pre></div>
<p>The additional complexity compared to the types discussed in <a href="https://wimvanderbauwhede.github.io/articles/universal-interpreter-part-1">the previous article</a> is that this type is recursive: the <code>Pow</code>, <code>Add</code> and <code>Mult</code> roles take parameters of type <code>Term</code>. </p>

<p>Before we look at the BB encoding, let&#39;s first write a pretty-printer for this type, using recursive <code>multi sub</code>s. </p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="c1"># Pretty-print a Term </span>
<span class="k">multi</span> <span class="k">sub</span> <span class="n">ppTerm</span>(<span class="n">Var</span> \<span class="n">t</span>) { <span class="n">t</span>.<span class="n">var</span> }
<span class="k">multi</span> <span class="k">sub</span> <span class="n">ppTerm</span>(<span class="n">Par</span> \<span class="n">c</span>) { <span class="n">c</span>.<span class="n">par</span> }
<span class="k">multi</span> <span class="k">sub</span> <span class="n">ppTerm</span>(<span class="n">Const</span> \<span class="n">n</span>) { <span class="s">&quot;{n.const}&quot;</span> }
<span class="k">multi</span> <span class="k">sub</span> <span class="n">ppTerm</span>(<span class="n">Pow</span> \<span class="n">pw</span>){ 
    <span class="n">ppTerm</span>(<span class="n">pw</span>.<span class="n">term</span>) ~ <span class="s">&#39;^&#39;</span> ~ <span class="s">&quot;{pw.exp}&quot;</span> 
}
<span class="k">multi</span> <span class="k">sub</span> <span class="n">ppTerm</span>(<span class="n">Add</span> \<span class="n">t</span>) { 
    <span class="k">my</span> <span class="nv">@pts</span> = <span class="nb">map</span> {<span class="n">ppTerm</span>(<span class="nv">$_</span>)}, |<span class="n">t</span>.<span class="n">terms</span>;
    <span class="s">&quot;(&quot;</span>~<span class="nb">join</span>( <span class="s">&quot; + &quot;</span>, <span class="nv">@pts</span>)~<span class="s">&quot;)&quot;</span>
}
<span class="k">multi</span> <span class="k">sub</span> <span class="n">ppTerm</span>(<span class="n">Mult</span> \<span class="n">t</span>){ 
    <span class="k">my</span> <span class="nv">@pts</span> = <span class="nb">map</span> {<span class="n">ppTerm</span>(<span class="nv">$_</span>)}, |<span class="n">t</span>.<span class="n">terms</span>;
    <span class="nb">join</span>( <span class="s">&quot; * &quot;</span>, <span class="nv">@pts</span>)
}
</code></pre></div>
<p>In the same way we can write an evaluator for this type:</p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="c1"># Evaluate a Term </span>
<span class="k">multi</span> <span class="k">sub</span> <span class="n">evalTerm</span>(<span class="nv">%vars</span>,  <span class="nv">%pars</span>, <span class="n">Var</span> \<span class="n">t</span>) { <span class="nv">%vars</span>{<span class="n">t</span>.<span class="n">var</span>} }
<span class="k">multi</span> <span class="k">sub</span> <span class="n">evalTerm</span>(<span class="nv">%vars</span>,  <span class="nv">%pars</span>,<span class="n">Par</span> \<span class="n">c</span>) { <span class="nv">%pars</span>{<span class="n">c</span>.<span class="n">par</span>} }
<span class="k">multi</span> <span class="k">sub</span> <span class="n">evalTerm</span>(<span class="nv">%vars</span>,  <span class="nv">%pars</span>,<span class="n">Const</span> \<span class="n">n</span>) { <span class="n">n</span>.<span class="n">const</span> }
<span class="k">multi</span> <span class="k">sub</span> <span class="n">evalTerm</span>(<span class="nv">%vars</span>,  <span class="nv">%pars</span>,<span class="n">Pow</span> \<span class="n">pw</span>){ 
    <span class="n">evalTerm</span>(<span class="nv">%vars</span>,  <span class="nv">%pars</span>,<span class="n">pw</span>.<span class="n">term</span>) ** <span class="n">pw</span>.<span class="nb">exp</span> 
}
<span class="k">multi</span> <span class="k">sub</span> <span class="n">evalTerm</span>(<span class="nv">%vars</span>,  <span class="nv">%pars</span>,<span class="n">Add</span> \<span class="n">t</span>) { 
    <span class="k">my</span> <span class="nv">@pts</span> = <span class="nb">map</span> {<span class="n">evalTerm</span>(<span class="nv">%vars</span>,  <span class="nv">%pars</span>,<span class="nv">$_</span>)}, |<span class="n">t</span>.<span class="n">terms</span>;
    [+] <span class="nv">@pts</span>
}
<span class="k">multi</span> <span class="k">sub</span> <span class="n">evalTerm</span>(<span class="nv">%vars</span>,  <span class="nv">%pars</span>,<span class="n">Mult</span> \<span class="n">t</span>){ 
    <span class="k">my</span> <span class="nv">@pts</span> = <span class="nb">map</span> {<span class="n">evalTerm</span>(<span class="nv">%vars</span>,  <span class="nv">%pars</span>,<span class="nv">$_</span>)}, |<span class="n">t</span>.<span class="n">terms</span>;
    [*] <span class="nv">@pts</span>
}
</code></pre></div>
<h3>Example parse trees</h3>

<p>As an example, let&#39;s create the parse tree for a few expressions using the <code>Term</code> type.</p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="c1"># a*x^2 + b*x + x</span>
<span class="k">my</span> \<span class="n">qterm1</span> = <span class="n">Add</span>[ 
    <span class="nb">Array</span>[<span class="n">Term</span>].<span class="nb">new</span>(
    <span class="n">Mult</span>[ <span class="nb">Array</span>[<span class="n">Term</span>].<span class="nb">new</span>(
        <span class="n">Par</span>[ <span class="s">&quot;a&quot;</span>].<span class="nb">new</span>, 
        <span class="n">Pow</span>[ <span class="n">Var</span>[ <span class="s">&quot;x&quot;</span>].<span class="nb">new</span>, <span class="mi">2</span>].<span class="nb">new</span>) 
        ].<span class="nb">new</span>,
    <span class="n">Mult</span>[
        <span class="nb">Array</span>[<span class="n">Term</span>].<span class="nb">new</span>(
            <span class="n">Par</span>[ <span class="s">&quot;b&quot;</span>].<span class="nb">new</span>, 
            <span class="n">Var</span>[ <span class="s">&quot;x&quot;</span>].<span class="nb">new</span>) 
        ].<span class="nb">new</span>,
    <span class="n">Par</span>[ <span class="s">&quot;c&quot;</span>].<span class="nb">new</span>
    )
    ].<span class="nb">new</span>;

<span class="c1">#   x^3 + 1    </span>
<span class="k">my</span> \<span class="n">qterm2</span> = <span class="n">Add</span>[ 
    <span class="nb">Array</span>[<span class="n">Term</span>].<span class="nb">new</span>(
        <span class="n">Pow</span>[ <span class="n">Var</span>[ <span class="s">&quot;x&quot;</span>].<span class="nb">new</span>, <span class="mi">3</span>].<span class="nb">new</span>, 
        <span class="n">Const</span>[ <span class="mi">1</span>].<span class="nb">new</span>
    )
    ].<span class="nb">new</span>;

<span class="c1">#   qterm1 * qterm2    </span>
<span class="k">my</span> \<span class="n">qterm</span> = <span class="n">Mult</span>[ 
    <span class="nb">Array</span>[<span class="n">Term</span>].<span class="nb">new</span>(
        <span class="n">qterm1</span>, <span class="n">qterm2</span>
    )
    ].<span class="nb">new</span>;
</code></pre></div>
<p>Calling the pretty-printer and evaluator on this term: </p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="nb">say</span> <span class="n">ppTerm</span>( <span class="n">qterm</span>); <span class="c1"># =&gt; (a * x^2 + b * x + c) * (x^3 + 1)</span>

<span class="nb">say</span> <span class="n">evalTerm</span>(
    {<span class="s">&quot;x&quot;</span> =&gt; <span class="mi">2</span>}, {<span class="s">&quot;a&quot;</span> =&gt;<span class="mi">2</span>,<span class="s">&quot;b&quot;</span>=&gt;<span class="mi">3</span>,<span class="s">&quot;c&quot;</span>=&gt;<span class="mi">4</span>},  <span class="n">qterm</span>
); <span class="c1"># =&gt; 162</span>
</code></pre></div>
<h2>BB encoding of the parse tree type</h2>

<p>The BB encoding of the <code>Term</code> algebraic data type in Raku is pleasingly compact:</p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="k">role</span> <span class="n">TermBB</span>[<span class="nv">&amp;f</span>] {
    <span class="k">method</span> <span class="n">unTermBB</span>(
        <span class="nv">&amp;var:</span>(<span class="nb">Str</span> --&gt; <span class="nb">Any</span>),
        <span class="nv">&amp;par:</span>(<span class="nb">Str</span> --&gt; <span class="nb">Any</span>),
        <span class="nv">&amp;const:</span>(<span class="nb">Int</span> --&gt; <span class="nb">Any</span>),
        <span class="nv">&amp;pow:</span>(<span class="nb">Any</span>,<span class="nb">Int</span> --&gt; <span class="nb">Any</span>),
        <span class="nv">&amp;add:</span>(<span class="nb">Array</span>[<span class="nb">Any</span>] --&gt; <span class="nb">Any</span>),
        <span class="nv">&amp;mult:</span>(<span class="nb">Array</span>[<span class="nb">Any</span>] --&gt; <span class="nb">Any</span>) 
        --&gt; <span class="nb">Any</span>
    ) {
        <span class="n">f</span>(<span class="nv">&amp;var</span>,<span class="nv">&amp;par</span>,<span class="nv">&amp;const</span>,<span class="nv">&amp;pow</span>,<span class="nv">&amp;add</span>,<span class="nv">&amp;mult</span>);
    }
}
</code></pre></div>
<p>It would of course be even more compact without the signatures, but then we&#39;d have no information about the encoded type.</p>

<p>We could of course use this type directly, but instead I want to look at how we can convert between <code>Term</code> and <code>TermBB</code>. </p>

<p>As before, we create our little helpers. Each of the functions below is a constructor which generates the <code>TermBB</code> instance for the corresponding alternative in the <code>Term</code> algebraic data type. (When Raku&#39;s macro language is more developed, we will be able to generate these automatically.)</p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="k">sub</span> <span class="n">VarBB</span>(<span class="nb">Str</span> \<span class="o">s</span> --&gt; <span class="n">TermBB</span>) { 
    <span class="n">TermBB</span>[ 
        <span class="k">sub</span> (\<span class="n">v</span>, \<span class="n">c</span>, \<span class="n">n</span>, \<span class="n">p</span>, \<span class="n">a</span>, \<span class="sr">m) { v.(s)</span> }
    ].<span class="nb">new</span>;
    }
<span class="k">sub</span> <span class="n">ParBB</span>(<span class="nb">Str</span> \<span class="o">s</span> --&gt; <span class="n">TermBB</span>) { 
    <span class="n">TermBB</span>[ 
        <span class="k">sub</span> (\<span class="n">v</span>, \<span class="n">c</span>, \<span class="n">n</span>, \<span class="n">p</span>, \<span class="n">a</span>, \<span class="sr">m) { c.(s)</span> }
    ].<span class="nb">new</span>;
    }
<span class="k">sub</span> <span class="n">ConstBB</span>(<span class="nb">Int</span> \<span class="n">i</span> --&gt; <span class="n">TermBB</span>) { 
    <span class="n">TermBB</span>[ 
        <span class="k">sub</span> (\<span class="n">v</span>, \<span class="n">c</span>, \<span class="n">n</span>, \<span class="n">p</span>, \<span class="n">a</span>, \<span class="sr">m) { n.(i)</span> }
    ].<span class="nb">new</span>;
    }    
<span class="k">sub</span> <span class="n">PowBB</span>( <span class="n">TermBB</span> \<span class="n">t</span>, <span class="nb">Int</span> \<span class="n">i</span> --&gt; <span class="n">TermBB</span>) {
    <span class="n">TermBB</span>[  <span class="k">sub</span> (\<span class="n">v</span>, \<span class="n">c</span>, \<span class="n">n</span>, \<span class="n">p</span>, \<span class="n">a</span>, \<span class="sr">m) { </span>
<span class="sr">        p.( t.unTermBB( v, c, n, p, a, m )</span>, <span class="n">i</span>);
    }
    ].<span class="nb">new</span>;
}
<span class="k">sub</span> <span class="n">AddB</span>( <span class="nb">Array</span>[<span class="n">TermBB</span>] \<span class="n">ts</span> --&gt; <span class="n">TermBB</span>) {
    <span class="n">TermBB</span>[  <span class="k">sub</span> (\<span class="n">v</span>, \<span class="n">c</span>, \<span class="n">n</span>, \<span class="n">p</span>, \<span class="n">a</span>, \<span class="sr">m) { </span>
<span class="sr">        a.( map {.unTermBB( v, c, n, p, a, m )</span>}, <span class="n">ts</span> )
    }
    ].<span class="nb">new</span>;
}
<span class="k">sub</span> <span class="n">MultBB</span>(  <span class="nb">Array</span>[<span class="n">TermBB</span>] \<span class="n">ts</span> --&gt; <span class="n">TermBB</span>) { 
    <span class="n">TermBB</span>[  <span class="k">sub</span> (\<span class="n">v</span>, \<span class="n">c</span>, \<span class="n">n</span>, \<span class="n">p</span>, \<span class="n">a</span>, \<span class="sr">m) { </span>
<span class="sr">        m.( map {.unTermBB( v, c, n, p, a, m )</span>}, <span class="n">ts</span> )
    }
    ].<span class="nb">new</span>;
}
</code></pre></div>
<p>The interesting generators are <code>PowBB</code>, <code>AddBB</code> and <code>MultBB</code> because they are recursive. In <code>PowBB</code>, the function passed as parameter to the <code>TermBB</code> role constructor calls <code>p</code> which has a signature of <code>:(Any,Int --&gt; Any)</code>, but actually requires an argument of the same type as the return value (we need <code>a -&gt; Int -&gt; a</code>). The argument <code>t</code>  is of type <code>TermBB</code> which is a wrapper around a function which, when applied, will return the right type. In the Raku implementation, this function is the method <code>unTermBB</code>. So we need to call <code>t.unTermBB( ... )</code>.
In <code>AddBB</code> and <code>MultBB</code>, we have an <code>Array[TermBB]</code> so we need to call <code>unTermBB</code> on every element, hence the <code>map</code> call.</p>

<p>Using these generators we can write a single function to convert the algebraic data type into its BB encoding. Unsurprisingly, it is very similar to the pretty-printer and evaluator we wrote for <code>Term</code> instances:</p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="c1"># Turn a Term into a BB Term</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="n">termToBB</span>(<span class="n">Var</span> \<span class="n">t</span>  ) { <span class="n">VarBB</span>(<span class="n">t</span>.<span class="n">var</span>)}
<span class="k">multi</span> <span class="k">sub</span> <span class="n">termToBB</span>(<span class="n">Par</span> \<span class="n">c</span>  ) { <span class="n">ParBB</span>( <span class="n">c</span>.<span class="n">par</span>)}
<span class="k">multi</span> <span class="k">sub</span> <span class="n">termToBB</span>(<span class="n">Const</span> \<span class="n">n</span>) {<span class="n">ConstBB</span>(<span class="n">n</span>.<span class="n">const</span>)}
<span class="k">multi</span> <span class="k">sub</span> <span class="n">termToBB</span>(<span class="n">Pow</span> \<span class="n">pw</span> ) { 
    <span class="n">PowBB</span>( <span class="n">termToBB</span>(<span class="n">pw</span>.<span class="n">term</span>), <span class="n">pw</span>.<span class="nb">exp</span>)
}
<span class="k">multi</span> <span class="k">sub</span> <span class="n">termToBB</span>(<span class="n">Add</span> \<span class="n">t</span>  ) { 
    <span class="n">AddBB</span>( <span class="n">typed-map</span>( <span class="n">TermBB</span>, <span class="n">t</span>.<span class="n">terms</span>, <span class="nv">&amp;termToBB</span> ))
}
<span class="k">multi</span> <span class="k">sub</span> <span class="n">termToBB</span>(<span class="n">Mult</span> \<span class="n">t</span> ) { 
    <span class="n">MultBB</span>( <span class="n">typed-map</span>( <span class="n">TermBB</span>, <span class="n">t</span>.<span class="n">terms</span>, <span class="nv">&amp;termToBB</span> ))
}

<span class="c1"># map &amp;f and return in an Array of type T</span>
<span class="k">sub</span> <span class="n">typed-map</span> (\<span class="n">T</span>,\<span class="n">lst</span>,<span class="nv">&amp;f</span>) {
    <span class="nb">Array</span>[<span class="n">T</span>].<span class="nb">new</span>(<span class="nb">map</span> {<span class="n">f</span>(<span class="nv">$_</span>) }, |<span class="n">lst</span> )
}
</code></pre></div>
<p>Because <code>PowBB</code>, <code>AddBB</code> and <code>MultBB</code> require a <code>TermBB</code>, we need to call <code>termToBB</code> on the <code>Term</code> fields. And because  <code>AddBB</code> and <code>MultBB</code> take an array of <code>Term</code>,  we need a <code>map</code>. However, Raku&#39;s <code>map</code> returns values of type <code>Seq</code>, so we need an explicit conversion into <code>Array</code>.</p>

<p>We can now convert any data structure of type <code>Term</code> into its BB encoding:</p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="k">my</span> \<span class="n">qtermbb</span> = <span class="n">termToBB</span>( <span class="n">qterm</span>);

<span class="nb">say</span> <span class="n">qtermbb</span>.<span class="n">raku</span>; <span class="c1"># =&gt; TermBB[Sub].new</span>
</code></pre></div>
<h3>Interpreter 1: Pretty-printer with BB encoding</h3>

<p>To create a pretty-printer for the BB-encoded type, we write implementations for each alternative, and the <code>unTermBB</code> call magically combines these.</p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="k">sub</span> <span class="n">ppTermBB</span>(<span class="n">TermBB</span> \<span class="n">t</span> --&gt; <span class="nb">Str</span>){ 
    <span class="k">sub</span> <span class="n">var</span>( \<span class="o">x</span> ) { <span class="o">x</span> }
    <span class="k">sub</span> <span class="n">par</span>( \<span class="o">x</span> ) { <span class="o">x</span> }
    <span class="k">sub</span> <span class="n">const</span>(\<span class="o">x</span> ) { <span class="s">&quot;{x}&quot;</span> }
    <span class="k">sub</span> <span class="n">pow</span>( \<span class="n">t</span>, \<span class="sr">m ) { t ~ &quot;^{m}&quot; } </span>
<span class="sr">    sub add( \ts )</span> { <span class="s">&quot;(&quot;</span>~<span class="nb">join</span>( <span class="s">&quot; + &quot;</span>, <span class="n">ts</span>)~<span class="s">&quot;)&quot;</span> }
    <span class="k">sub</span> <span class="n">mult</span>( \<span class="n">ts</span> ) { <span class="nb">join</span>( <span class="s">&quot; * &quot;</span>, <span class="n">ts</span>) }
    <span class="n">t</span>.<span class="n">unTermBB</span>( <span class="nv">&amp;var</span>, <span class="nv">&amp;par</span>, <span class="nv">&amp;const</span>, <span class="nv">&amp;pow</span>, <span class="nv">&amp;add</span>, <span class="nv">&amp;mult</span>);
}
</code></pre></div>
<p>Compared with <code>ppTerm</code> (copied below for convenience), the main differences are that there is no recursion and no need to <code>map</code> anything. We also don&#39;t need a <code>multi sub</code> to pattern match on the constructors, and there is no need to unpack the values stored in the type using attribute accessors. As a result, the BB version is markedly less cluttered.</p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="k">multi</span> <span class="k">sub</span> <span class="n">ppTerm</span>(<span class="n">Var</span> \<span class="n">t</span> --&gt; <span class="nb">Str</span>) { <span class="n">t</span>.<span class="n">var</span> }
<span class="k">multi</span> <span class="k">sub</span> <span class="n">ppTerm</span>(<span class="n">Par</span> \<span class="n">c</span> --&gt; <span class="nb">Str</span>) { <span class="n">c</span>.<span class="n">par</span> }
<span class="k">multi</span> <span class="k">sub</span> <span class="n">ppTerm</span>(<span class="n">Const</span> \<span class="n">n</span> --&gt; <span class="nb">Str</span>) { <span class="s">&quot;{n.const}&quot;</span> }
<span class="k">multi</span> <span class="k">sub</span> <span class="n">ppTerm</span>(<span class="n">Pow</span> \<span class="n">pw</span> --&gt; <span class="nb">Str</span>){ 
    <span class="n">ppTerm</span>(<span class="n">pw</span>.<span class="n">term</span>) ~ <span class="s">&#39;^&#39;</span> ~ <span class="s">&quot;{pw.exp}&quot;</span> 
}
<span class="k">multi</span> <span class="k">sub</span> <span class="n">ppTerm</span>(<span class="n">Add</span> \<span class="n">t</span> --&gt; <span class="nb">Str</span>) { 
    <span class="k">my</span> <span class="nv">@pts</span> = <span class="nb">map</span> {<span class="n">ppTerm</span>(<span class="nv">$_</span>)}, |<span class="n">t</span>.<span class="n">terms</span>;
    <span class="s">&quot;(&quot;</span>~<span class="nb">join</span>( <span class="s">&quot; + &quot;</span>, <span class="nv">@pts</span>)~<span class="s">&quot;)&quot;</span>
}
<span class="k">multi</span> <span class="k">sub</span> <span class="n">ppTerm</span>(<span class="n">Mult</span> \<span class="n">t</span> --&gt; <span class="nb">Str</span>){ 
    <span class="k">my</span> <span class="nv">@pts</span> = <span class="nb">map</span> {<span class="n">ppTerm</span>(<span class="nv">$_</span>)}, |<span class="n">t</span>.<span class="n">terms</span>;
    <span class="nb">join</span>( <span class="s">&quot; * &quot;</span>, <span class="nv">@pts</span>)
}
</code></pre></div>
<h3>Interpreter 2: Evaluator with BB encoding</h3>

<p>And an evaluator is equally simple:</p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="k">sub</span> <span class="n">evalTermBB</span>( <span class="nv">%vars</span>,  <span class="nv">%pars</span>, \<span class="n">t</span>) {
    <span class="n">t</span>.<span class="n">unTermBB</span>( 
        -&gt; \<span class="o">x</span> { <span class="nv">%vars</span>{<span class="o">x</span>} }, 
        -&gt; \<span class="o">x</span> { <span class="nv">%pars</span>{<span class="o">x</span>} },
        -&gt; \<span class="o">x</span> {<span class="o">x</span>},
        -&gt; \<span class="n">t</span>,\<span class="sr">m { t ** m}</span>,
        -&gt; \<span class="n">ts</span> { [+] <span class="n">ts</span>},
        -&gt; \<span class="n">ts</span> { [*] <span class="n">ts</span>}
    );
}
</code></pre></div>
<p>As with <code>evalTerm</code> below, we pass hashes for variable and parameter definitions as arguments to provide context for the evaluation. In the BB version we need to do this only once, rather than for every multi variant, so I have written it below using a <code>given/when</code>. Even then, the BB version is a lot cleaner, for the same reasons as above. </p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="k">sub</span> <span class="n">evalTerm</span>(<span class="nv">%vars</span>,  <span class="nv">%pars</span>, <span class="n">Term</span> \<span class="n">t</span>) {
    <span class="k">given</span> <span class="n">t</span> {
        <span class="k">when</span> <span class="n">Var</span> { <span class="nv">%vars</span>{<span class="n">t</span>.<span class="n">var</span>} }
        <span class="k">when</span> <span class="n">Par</span> { <span class="nv">%pars</span>{<span class="n">t</span>.<span class="n">par</span>} }
        <span class="k">when</span> <span class="n">Const</span> { <span class="n">t</span>.<span class="n">const</span> }
        <span class="k">when</span> <span class="n">Pow</span> { <span class="n">evalTerm</span>(<span class="nv">%vars</span>,  <span class="nv">%pars</span>,<span class="n">t</span>.<span class="n">term</span>) ** <span class="n">t</span>.<span class="nb">exp</span> }
        <span class="k">when</span> <span class="n">Add</span> {
            <span class="k">my</span> <span class="nv">@pts</span> = <span class="nb">map</span> {
                <span class="n">evalTerm</span>(<span class="nv">%vars</span>,  <span class="nv">%pars</span>,<span class="nv">$_</span>)
                }, |<span class="n">t</span>.<span class="n">terms</span>;
            [+] <span class="nv">@pts</span>
        }
        <span class="k">when</span> <span class="n">Mult</span> { 
            <span class="k">my</span> <span class="nv">@pts</span> = <span class="nb">map</span> {
                <span class="n">evalTerm</span>(<span class="nv">%vars</span>,  <span class="nv">%pars</span>,<span class="nv">$_</span>)
                }, |<span class="n">t</span>.<span class="n">terms</span>;
            [*] <span class="nv">@pts</span>
        }
    }
}
</code></pre></div>
<!-- ### Interpreter 3: Pretty-printer and evaluator combined

Now we can do one better and combine these two interpreters.

```perl6
sub evalAndppTermBB(%vars,  %pars, TermBB \t ){ 
    t.unTermBB( 
        -> \x {[%vars{x},x]}, 
        -> \x {[%pars{x},x]},
        -> \x {[x,"{x}"]},
        -> \t,\m {[t[0] ** m, t[1] ~ "^{m}"] },
        -> \ts { 
            my \p = 
                reduce { [ $^a[0] + $^b[0], $^a[1] ~ " + " ~ $^b[1]] }, ts[0],  |ts[1..*];
            [ p[0], "("~p[1]~")" ]; 
        }, 
        -> \ts { 
            reduce { [ $^a[0] * $^b[0], $^a[1] ~ " * " ~ $^b[1]] }, ts[0],  |ts[1..*]
        }
    )
}

say ppTermBB( qtermbb);
say evalTermBB(
    {"x" => 2}, {"a" =>2,"b"=>3,"c"=>4},  qtermbb
);
say evalAndppTermBB(
    {"x" => 2}, {"a" =>2,"b"=>3,"c"=>4},  qtermbb
);
``` -->

<h3>Interpreter 3: Converting <code>TermBB</code> to <code>Term</code></h3>

<p>Finally, let&#39;s look at converting <code>TermBB</code> to <code>Term</code>. This is yet another type of interpreter so we can follow exactly the same approach as before: </p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="k">sub</span> <span class="n">toTerm</span>(<span class="n">TermBB</span> \<span class="n">t</span> --&gt; <span class="n">Term</span>){ 
        <span class="k">sub</span> <span class="n">var</span>( \<span class="o">x</span> ) { <span class="n">Var</span>[<span class="o">x</span>].<span class="nb">new</span> }
        <span class="k">sub</span> <span class="n">par</span>( \<span class="o">x</span> ) { <span class="n">Par</span>[<span class="o">x</span>].<span class="nb">new</span> }
        <span class="k">sub</span> <span class="n">const</span>( <span class="nv">$x</span> ) { <span class="n">Const</span>[<span class="nv">$x</span>].<span class="nb">new</span> }
        <span class="k">sub</span> <span class="n">pow</span>( \<span class="n">t</span>, <span class="nv">$m</span> ) { <span class="n">Pow</span>[ <span class="n">t</span>, <span class="nv">$m</span>].<span class="nb">new</span> } 
        <span class="k">sub</span> <span class="n">add</span>( \<span class="n">ts</span> ) { <span class="n">Add</span>[ <span class="n">ts</span> ].<span class="nb">new</span> }
        <span class="k">sub</span> <span class="n">mult</span>( \<span class="n">ts</span> ) { <span class="n">Mult</span>[ <span class="n">ts</span> ].<span class="nb">new</span>) }
        <span class="n">t</span>.<span class="n">unTermBB</span>( <span class="nv">&amp;var</span>, <span class="nv">&amp;par</span>, <span class="nv">&amp;const</span>, <span class="nv">&amp;pow</span>, <span class="nv">&amp;add</span>, <span class="nv">&amp;mult</span>);
}

<span class="nb">say</span> <span class="n">toTerm</span>(<span class="n">qtermbb</span>).<span class="n">raku</span>;
</code></pre></div>
<h2>Using the BB type directly</h2>

<p>In the examples above I have created the data structures using the <code>Term</code> type and converted the result to a <code>TermBB</code> type. We can of course also directly use the BB type. If we don&#39;t use strict typing and make the argument of <code>Add</code> and <code>Mult</code> slurpy, we get a nice and clean representation:</p>
<div class="highlight"><pre><code class="language-perl6" data-lang="perl6"><span></span><span class="c1"># a*x^2 + b*x + x</span>
<span class="k">my</span> \<span class="n">qtermbb1</span> = <span class="n">AddBB</span>(
    <span class="n">MultBB</span>( 
        <span class="n">ParBB</span>( <span class="s">&quot;a&quot;</span>), 
        <span class="n">PowBB</span>( <span class="n">VarBB</span>( <span class="s">&quot;x&quot;</span>), <span class="mi">2</span>) 
        ),
    <span class="n">MultBB</span>(
        <span class="n">ParBB</span>( <span class="s">&quot;b&quot;</span>), 
        <span class="n">VarBB</span>( <span class="s">&quot;x&quot;</span>) 
        ),
    <span class="n">ParBB</span>( <span class="s">&quot;c&quot;</span>)
);

<span class="c1">#   x^3 + 1    </span>
<span class="k">my</span> \<span class="n">qtermbb2</span> = <span class="n">AddBB</span>( 
    <span class="n">PowBB</span>( <span class="n">VarBB</span>( <span class="s">&quot;x&quot;</span>), <span class="mi">3</span>), 
    <span class="n">ConstBB</span>(<span class="mi">1</span>)
);

<span class="c1">#   qterm1 * qterm2    </span>
<span class="k">my</span> \<span class="n">qtermbb3</span> = <span class="n">MultBB</span>( 
    <span class="n">qterm1</span>, <span class="n">qterm2</span>
);
</code></pre></div>
<p>This is structurally very similar to the examples using the <code>Term</code> type. We can obtain exactly the same representation by using a slurpy helper function to wrap the role constructors for <code>Term</code>. See the code in <a href="https://github.com/wimvanderbauwhede/raku-examples/blob/master/no-bb-timing.raku">no-b-timing.raku`</a> and <a href="https://github.com/wimvanderbauwhede/raku-examples/blob/master/ubb-timing.raku">ubb-timing.raku</a> for details. </p>

<p>The code as presented above is not entirely correct: I have not always typed everything explicitly, but the explicit signatures in the role definition will cause type errors unless everything is explicitly typed. See the code in <a href="https://github.com/wimvanderbauwhede/raku-examples/blob/master/tbb-timing.raku">tbb-timing.raku</a> for details.</p>

<p>The code in <code>no-bb-timing</code> and <code>ubb-timing</code> is comparable in terms of complexity. I ran a timing test, and the BB implementation of the algebraic data type is about 20% slower than the &#39;ordinary&#39; implementation. However, the fully-typed version <code>tbb-timing</code> is three times slower. Types in Raku are clearly not zero-cost abstractions. </p>

<p>For info, here are the profiling reports (<code>raku --profile</code>) for <a href="https://wimvanderbauwhede.github.io/articles/no-bb-timing.html">no-bb-timing</a> and <a href="https://wimvanderbauwhede.github.io/articles/ubb-timing.html">ubb-timing</a>. Profiling <code>tbb-timing</code> proved infeasible.</p>

<p>On the other hand, somewhat paradoxically, we don&#39;t really need this explicit typing. It is useful to write down the function types for the BB encoding, and I think it helps with the explanations, but the actual type safety comes from the algebraic data types that we created. </p>

<h2>Conclusion</h2>

<p>In this article and <a href="https://wimvanderbauwhede.github.io/articles/universal-interpreter-part-1">the previous one</a> I have shown another way to implement algebraic data types in Raku. As with the approach discussed in <a href="https://wimvanderbauwhede.github.io/articles/roles-as-adts-in-raku/">&#39;Roles as Algebraic Data Types in Raku&#39;</a>, I use a role to create the type. However, in this approach the entire data structure is encoded as a function using the <a href="http://okmij.org/ftp/tagless-final/course/Boehm-Berarducci.html">Böhm-Berarducci encoding</a>. From a type theoretical perspective, both approaches are precisely equivalent. In terms of coding effort and performance, both approaches are comparable. </p>

<p>The advantage of the BB approach is that because the data is encoded as a function, it becomes easier to create interpreters for the data type, and I have illustrated this with a pretty-printer and evaluator for a parsed expression. All interpreters for BB types have the same structure, which is why I call it a universal interpreter. The key feature is that these interpreters do not require any explicit recursion. </p>

<p>The complete code for both articles is in <a href="https://github.com/wimvanderbauwhede/raku-examples/blob/master/universal-interpreter.raku">universal-interpreter.raku</a></p>

<!-- 

### Bonus: parsing the expression

In the article []() I presented a parser combinator library which uses the role-based algebraic data types.  The parser returns the following type:

```perl6
role TaggedEntry {}
# A string value
role Val[Str @v] does TaggedEntry {
    has Str @.val=@v;
} 
# A list of TaggedEntry values tagged with a string label
role ValMap [  @vm] does TaggedEntry {
    has @.valmap = @vm; 
}
```

It is quite straightforward to transform a data structure of this type into our `Term` type:

```perl6
multi sub taggedEntryToTerm (Var , Val \val_strs) { Var[ val_strs.val.head].new }
multi sub taggedEntryToTerm (Par , Val \par_strs) { Par[ par_strs.val.head].new }
multi sub taggedEntryToTerm (Const ,\const_strs) {Const[ Int(const_strs.val.head)].new } 
# multi sub taggedEntryToTerm (Pow , ValMap [t1,(_,Val [v2])]) { Pow[ taggedEntryToTerm(...,....), Int(...)].new}        
# multi sub taggedEntryToTerm (Add , ValMap hmap) = Add $ map taggedEntryToTerm hmap
# multi sub taggedEntryToTerm (Mult , ValMap hmap) = Mult $ map taggedEntryToTerm hmap
```


```perl6
my Str @val_strs = "42";
my \v = taggedEntryToTerm(Const, Val[@val_strs].new);
say v.raku; 
```

 -->

				<hr />
				<footer class="page-footer">
					

<!--
<div class="author-image">
	<img src="https://wimvanderbauwhede.github.io/images/" alt="Wim Vanderbauwhede">
</div>
-->
<!-- ./author-image -->
<div class="author-content">
	<h3 class="author-name" >Written by <a href="http://www.dcs.gla.ac.uk/~wim" itemprop="author">Wim Vanderbauwhede</a></h3>
	<p class="author-bio"></p>
</div><!-- ./author-content -->

					
					<div class="page-meta">
	<p>Updated <time datetime="2020-09-13T00:00:00Z" itemprop="dateModified">September 13, 2020</time>
</div><!-- /.page-meta -->
				</footer><!-- /.footer -->
				<aside>
					
				</aside>
			</div><!-- /.content -->
		</div><!-- /.inner-wrap -->
		
	</article><!-- ./wrap -->
</div><!-- /#main -->


      <footer role="contentinfo" id="site-footer">
	<nav role="navigation" class="menu bottom-menu">
		<ul class="menu-item">
		
      
			<li><a href="https://wimvanderbauwhede.github.io/" >Wim Vanderbauwhede</a></li>
		
      
			<li><a href="https://wimvanderbauwhede.github.io/about/" >About</a></li>
		
		</ul>
	</nav><!-- /.bottom-menu -->
	<p class="copyright">&#169; 2020 <a href="https://wimvanderbauwhede.github.io">Wim Vanderbauwhede</a> <br> <a href="http://jekyllrb.com">Jekyll</a> theme <a href="http://mmistakes.github.io/skinny-bones-jekyll/">Skinny Bones</a></p>

<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
var sc_project=10807901;
var sc_invisible=1;
var sc_security="7dfdbc2d";
var scJsHost = (("https:" == document.location.protocol) ?
"https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" +
scJsHost+
"statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript><div class="statcounter"><a title="web stats"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="http://c.statcounter.com/10807901/0/7dfdbc2d/1/"
alt="web stats"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->

</footer>

    </div>

    <script src="https://wimvanderbauwhede.github.io/js/vendor/jquery-1.9.1.min.js"></script>
    <script src="https://wimvanderbauwhede.github.io/js/main.js"></script>

    

  </body>

</html>
