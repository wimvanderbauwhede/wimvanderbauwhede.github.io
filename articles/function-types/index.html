<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Function types • Wim Vanderbauwhede</title>
    <meta name="description" content="A brief introduction into function types, with a way to implement them in Raku and examples in many languages.">
    <meta name="keywords" content="coding, hacking, programming, raku">
    

    <link rel="canonical" href="https://wimvanderbauwhede.github.io/articles/function-types/">

    <link href="https://wimvanderbauwhede.github.io/atom.xml" type="application/atom+xml" rel="alternate" title="Wim Vanderbauwhede Atom Feed">
    <link href="https://wimvanderbauwhede.github.io/sitemap.xml" type="application/xml" rel="sitemap" title="Sitemap">

    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="cleartype" content="on">
    <meta name="p:domain_verify" content="e31ad34d4267c0ac4d997da5cb5ea898"/>
    <meta http-equiv="X-Clacks-Overhead" content="GNU Natalie Nguyen" />
    <!-- <style>
    .sliding-menu-content {
      top: 0;
      right: 0;
      text-align: center;
      visibility: hidden;
      height: 100%;
      width: 100%;
      -webkit-transform: translateX(100%);
      -moz-transform: translateX(100%);
      -ms-transform: translateX(100%);
      -o-transform: translateX(100%);
      transform: translateX(100%);
    }
    </style> -->

    <link rel="stylesheet" href="https://wimvanderbauwhede.github.io/css/main.css">
    <!-- <link rel="stylesheet" href="https://wimvanderbauwhede.github.io/css/bjqs.css"> -->
    <!-- <link rel="stylesheet" href="https://wimvanderbauwhede.github.io/tipuesearch/tipuesearch.css"> -->
    <!-- HTML5 Shiv and Media Query Support for IE -->
    <!--[if lt IE 9]>
      <script src="https://wimvanderbauwhede.github.io/js/vendor/html5shiv.min.js"></script>
      <script src="https://wimvanderbauwhede.github.io/js/vendor/respond.min.js"></script>
    <![endif]-->
    <!-- Include the jQuery library (local or CDN) -->
    <!-- <script src="https://wimvanderbauwhede.github.io/js/plugins/jquery-1.7.1.min.js"></script> -->

    <!-- Include the plugin *after* the jQuery library -->
    <!-- <script src="https://wimvanderbauwhede.github.io/js/plugins/bjqs-1.3.min.js"></script> -->
        
  </head>

  <body>
    <header id="masthead">
  <div class="inner-wrap">
<a href="https://wimvanderbauwhede.github.io" class="site-title">&nbsp;</a>
    <nav role="navigation" class="menu top-menu">
        <ul class="menu-item">
	<li class="home"><a href="/">Wim Vanderbauwhede</a></li>
	

</ul>

    </nav>
<!-- <form style="float: right;" action="https://wimvanderbauwhede.github.io/search.html" ><input type="text" name="q" id="tipue_search_input" autocomplete="off" required></form> -->
  </div><!-- /.inner-wrap -->
</header><!-- /.masthead -->

    <!-- <nav role="navigation" class="js-menu sliding-menu-content">
	<ul class="menu-item">
		
	</ul>
</nav>
<button type="button" class="js-menu-trigger sliding-menu-button menulines-button x2" role="button" aria-label="Toggle Navigation">
	<span class="menulines"></span>
</button>

<div class="js-menu-screen menu-screen"></div>
 -->

    <div id="page-wrapper">

      <div id="main" role="main">
	<article class="wrap" itemscope itemtype="http://schema.org/Article">
		
		<div class="page-feature">
			<div class="page-image">
				<img src="https://wimvanderbauwhede.github.io/images/function-types_1600x600.avif" class="page-feature-image" alt="Function types" itemprop="image">
				
			</div><!-- /.page-image -->
		</div><!-- /.page-feature -->
		
		<nav class="breadcrumbs">
  <a href="https://wimvanderbauwhede.github.io">Home</a> <span class="divider">/</span> <a href="https://wimvanderbauwhede.github.io/articles/">Articles</a> <span class="divider">/</span>
</nav><!-- /.breadcrumbs -->
		<div class="page-title">
			<h1>Function types</h1>
		</div>
		<div class="inner-wrap">
			<nav class="toc"></nav><!-- /.toc -->
			<div id="content" class="page-content" itemprop="articleBody">
				<p>This article builds on my earlier articles on <a href="https://wimvanderbauwhede.github.io/articles/roles-as-adts-in-raku/">algebraic data types</a> in on <a href="https://raku.org/">Raku</a> and their use in the practical example of <a href="https://wimvanderbauwhede.github.io/articles/list-based-parser-combinators/">list-based parser combinators</a>.</p>

<p>In this article I want to look at function types in some detail, and show a way to create well typed functions in Raku. If you are not familiar with functional programming (or with <a href="https://raku.org/">Raku</a>), I suggest you read my introduction <a href="https://wimvanderbauwhede.github.io/articles/decluttering-with-functional-programming/">“Cleaner code with functional programming”</a>. If you are not familiar with algebraic data types, you might want to read the other two articles as well. For most of the article, I provide examples in Raku, Python, Rust and Haskell. There is also some C and even some Fortran.</p>

<h2 id="type-signatures">Type signatures</h2>

<p>A function’s type signature consists of the types of each of its arguments and the return type. In most typed languages, the type is part of the function signature.</p>

<p>For example in C</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sqsum</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sqsum</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">y</span>
<span class="p">};</span>
</code></pre></div></div>

<p>or in Fortran</p>

<div class="language-fortran highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">integer</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="n">sqsum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w">
    </span><span class="kt">integer</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="w">
    </span><span class="n">sqsum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="w">
</span><span class="k">end</span><span class="w"> </span><span class="k">function</span><span class="w">
</span></code></pre></div></div>

<p>or in Rust</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">sqsum</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">y</span> <span class="p">}</span>

<span class="k">let</span> <span class="n">sqsum</span>  <span class="o">=</span> <span class="p">|</span><span class="n">x</span> <span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">i32</span><span class="p">|</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="p">};</span>
</code></pre></div></div>

<p>or in Raku</p>

<pre><code class="language-perl6">sub sqsum(Int, Int --&gt; Int) {...}
sub sqsum(Int \x, Int \y --&gt; Int) { x*x+y*y }

my &amp;sqsum = sub (Int \x, Int \y --&gt; Int) { x*x+y*y };
</code></pre>

<p>or in Python, using the <code class="language-plaintext highlighter-rouge">typing</code> module:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Callable</span>

<span class="k">def</span> <span class="nf">sqsum_</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>  
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">y</span>

<span class="n">sqsum</span> <span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">,</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span>  <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">y</span>
</code></pre></div></div>

<h2 id="the-type-of-a-function-of-functions">The type of a function of functions</h2>

<p>But what happens if we want to provide a function argument that is itself a function, or return a function (so-called <em>higher-order functions</em>)?</p>

<p>This is possible in most languages, but what I am interested in is the type information: what is the type signature of such a function of functions?</p>

<p>C supports functions-of-functions indirectly through function pointers, by creating a function type through a <code class="language-plaintext highlighter-rouge">typedef</code>.</p>

<pre><code class="language-C">typedef int (*Fun)(int,int);

int ten_times (Fun f) {...};
</code></pre>

<p>Maybe surprisingly, venerable old Fortran does support passing functions and subroutines as arguments. Functions are typed by their return type; subroutines are not typed.</p>

<div class="language-fortran highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">program</span><span class="w"> </span><span class="n">fof</span><span class="w"> 
    </span><span class="k">external</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">sqsum</span><span class="w">
    </span><span class="k">call</span><span class="w"> </span><span class="n">ten_times</span><span class="p">(</span><span class="n">sqsum</span><span class="p">)</span><span class="w">
</span><span class="k">end</span><span class="w"> </span><span class="k">program</span><span class="w"> </span><span class="n">fof</span><span class="w">

</span><span class="k">subroutine</span><span class="w"> </span><span class="n">ten_times</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w">
    </span><span class="kt">integer</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">f</span><span class="w">
    </span><span class="c1">! ...</span><span class="w">
</span><span class="k">end</span><span class="w"> </span><span class="k">subroutine</span><span class="w"> </span><span class="n">ten_times</span><span class="w">
</span></code></pre></div></div>

<p>In Rust you can provide the complete type of a function-as-argument:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">ten_times</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">F</span><span class="p">)</span> <span class="k">where</span> <span class="n">F</span><span class="p">:</span> <span class="nf">Fn</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
<span class="c1">// ...</span>
<span class="p">}</span>

<span class="nf">ten_times</span><span class="p">(</span><span class="n">sqsum</span><span class="p">);</span>
</code></pre></div></div>

<p>In Python we can use <code class="language-plaintext highlighter-rouge">Callable</code>, which also allow for the complete type to be expressed.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Callable</span>

<span class="k">def</span> <span class="nf">ten_times</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
<span class="c1"># ...
</span></code></pre></div></div>

<p>The same example in Raku becomes</p>

<pre><code class="language-perl6">sub ten_times (Sub \f:(Int,Int --&gt; Int)) {
#...
}

ten_times(sqsum);
</code></pre>

<p>So we can also pass the complete type. An equivalent way to write this is using the <code class="language-plaintext highlighter-rouge">&amp;</code> sigil <a href="https://docs.raku.org/language/variables#index-entry-sigil_&amp;">which imposes the <code class="language-plaintext highlighter-rouge">Callable</code> type constraint</a>:</p>

<pre><code class="language-perl6">sub ten_times (&amp;f:(Int,Int --&gt; Int)) {
#...
}
</code></pre>

<p>The types can be nested too, e.g. <code class="language-plaintext highlighter-rouge">((Int, Int --&gt; Int), (Int, Int --&gt; Int) --&gt; Int))</code> is a valid type signature.</p>

<!--


--------
fn main() {
 
    let sqsum  = |x : i32, y: i32| -> i32 {x*x+y*y};
    let res = sqsum(4,3);
 
    fn ten_times<F>(f: F  ) -> i3 where F: Fn(i32,i32) -> i32 {
        for index in 0..10 {
            let res = f(index,index+1);
            println!("{}",res);
        }
    }    
    ten_times(sqsum);
}

--------

from typing import Callable

sqsum : Callable[[int,int], int]  = lambda x,y : x*x+y*y
def sqsum_(x: int, y: int) -> int:  
    return x*x+y*y
res : int = sqsum(4,3)

def ten_times(f: Callable[[int, int],int]) -> int:
    for index in range(0,11):
        res = f(index,index+1)
        print(res)
    
ten_times(sqsum)

--------
-->

<h2 id="introducing-the-arrow">Introducing the arrow</h2>

<p>All of the above ways to express function type signatures are perfectly adequate in their respective languages. However, with the exception of Raku, they all share the problem that these function-of-function type signatures don’t compose very well: what if we want to write a function-of-function-of-function type? This is less far-fetched than it may seem.
I would like to introduce a notation used in type theory. It is at the same time simple and powerful. If you are familiar with functional languages like Haskell, Idris or Agda, you already know it.</p>

<p>Instead of mixing the type with the function declaration, it is written separately. The name of the function is followed by a colon and the list types of the arguments and the return value. Each argument is separated by an arrow. The above example of a function of two integer arguments returning an integer would be:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sqsum</span> <span class="o">:</span> <span class="kt">Int</span> <span class="err">⟶</span> <span class="kt">Int</span> <span class="err">⟶</span> <span class="kt">Int</span> 
</code></pre></div></div>

<p>The function-of-a-function introduced above has as type:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ten_times</span> <span class="o">:</span> <span class="p">(</span><span class="kt">Int</span> <span class="err">⟶</span> <span class="kt">Int</span> <span class="err">⟶</span> <span class="kt">Int</span><span class="p">)</span> <span class="err">⟶</span>  <span class="kt">Int</span>
</code></pre></div></div>
<p>The parentheses group the type of the function that is the only argument of <code class="language-plaintext highlighter-rouge">ten_times</code>.</p>

<p>In this notation, the arrow can be interpreted as an operator which creates a function type from the two types that are its arguments. The important property of this operator is that it is right associative. What this means is that for example</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">:</span> <span class="n">t1</span> <span class="err">⟶</span> <span class="n">t2</span> <span class="err">⟶</span> <span class="n">t3</span> <span class="err">⟶</span> <span class="n">t4</span>
</code></pre></div></div>

<p>is the same as</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">:</span> <span class="n">t1</span> <span class="err">⟶</span> <span class="n">t2</span> <span class="err">⟶</span> <span class="p">(</span><span class="n">t3</span> <span class="err">⟶</span> <span class="n">t4</span><span class="p">)</span>
</code></pre></div></div>

<p>and as</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">:</span> <span class="n">t1</span> <span class="err">⟶</span> <span class="p">(</span><span class="n">t2</span> <span class="err">⟶</span> <span class="n">t3</span> <span class="err">⟶</span> <span class="n">t4</span><span class="p">)</span>
</code></pre></div></div>

<p>and for completeness</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">:</span> <span class="n">t1</span> <span class="err">⟶</span> <span class="p">(</span><span class="n">t2</span> <span class="err">⟶</span> <span class="p">(</span><span class="n">t3</span> <span class="err">⟶</span> <span class="n">t4</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="a-detour-into-partial-application">A detour into partial application</h2>

<p>The above groupings imply that our function <code class="language-plaintext highlighter-rouge">f</code> can be interpreted in three ways, as a function of:</p>

<ul>
  <li>3 arguments of types <code class="language-plaintext highlighter-rouge">t1</code>,<code class="language-plaintext highlighter-rouge">t2</code>,<code class="language-plaintext highlighter-rouge">t3</code>, returning a result of type <code class="language-plaintext highlighter-rouge">t4</code>;</li>
  <li>2 arguments of types <code class="language-plaintext highlighter-rouge">t1</code>,<code class="language-plaintext highlighter-rouge">t2</code>, returning a result of type <code class="language-plaintext highlighter-rouge">t3 -&gt; t4</code>;</li>
  <li>1 argument of types <code class="language-plaintext highlighter-rouge">t1</code>, returning a result of type <code class="language-plaintext highlighter-rouge">t2-&gt;t3-&gt;t4</code>.</li>
</ul>

<p>Let’s say we have values <code class="language-plaintext highlighter-rouge">v1</code>,<code class="language-plaintext highlighter-rouge">v2</code>,<code class="language-plaintext highlighter-rouge">v3</code> for the arguments and <code class="language-plaintext highlighter-rouge">v4</code> as the result:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">v4</span> <span class="o">:</span> <span class="n">t4</span>
<span class="n">v4</span> <span class="o">=</span> <span class="n">f</span> <span class="n">v1</span> <span class="n">v2</span> <span class="n">v3</span>
</code></pre></div></div>

<p>But suppose we only apply <code class="language-plaintext highlighter-rouge">v1</code> and <code class="language-plaintext highlighter-rouge">v2</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pf1 : t3 ⟶ t4
pf1 = f v1 v2
</code></pre></div></div>

<p>We get a new function <code class="language-plaintext highlighter-rouge">pf1</code> which takes a single argument <code class="language-plaintext highlighter-rouge">v3</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">v4</span> <span class="o">=</span> <span class="n">pf1</span> <span class="n">v3</span>
</code></pre></div></div>

<p>And in the same way we can create <code class="language-plaintext highlighter-rouge">pf2</code> and <code class="language-plaintext highlighter-rouge">pf3</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pf2</span> <span class="o">:</span> <span class="n">t2</span> <span class="err">⟶</span> <span class="n">t3</span> <span class="err">⟶</span><span class="n">t4</span>
<span class="n">pf2</span> <span class="o">=</span> <span class="n">f</span> <span class="n">v1</span>

<span class="n">pf3</span> <span class="o">:</span> <span class="n">t3</span> <span class="err">⟶</span> <span class="n">t4</span>
<span class="n">pf3</span> <span class="o">=</span> <span class="n">pf2</span> <span class="n">v2</span>

<span class="n">v4</span> <span class="o">=</span> <span class="n">pf3</span> <span class="n">v3</span>
</code></pre></div></div>

<p>Because <code class="language-plaintext highlighter-rouge">pf1</code>, <code class="language-plaintext highlighter-rouge">pf2</code> and <code class="language-plaintext highlighter-rouge">pf3</code> are functions and the above is true for all values of <code class="language-plaintext highlighter-rouge">v1</code>, <code class="language-plaintext highlighter-rouge">v2</code>, <code class="language-plaintext highlighter-rouge">v3</code> and <code class="language-plaintext highlighter-rouge">v4</code>, it follows that</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pf3</span> <span class="o">==</span> <span class="n">pf1</span>
</code></pre></div></div>

<p>For completeness, we can also apply <code class="language-plaintext highlighter-rouge">pf2</code> directly to two arguments:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">v4</span> <span class="o">=</span> <span class="n">pf2</span> <span class="n">v2</span> <span class="n">v3</span>
</code></pre></div></div>

<p>This concept of creating a new function by not providing values for some of the arguments is called <em>partial application</em>, and many languages support it. Here are examples in Haskell, Raku, Python and Rust.</p>

<h3 id="haskell">Haskell</h3>

<p>In case you are not familiar with Haskell, this is what you need to know: it is whitespace-sensitive like Python, but has a markedly different syntax. Because everything is a function, there is no keyword to mark a function. Because there is only lexical scope, there is no need for any special scope identifiers. Function arguments are separated by spaces. Lambda functions (anonymous functions) start with a <code class="language-plaintext highlighter-rouge">\</code>,  chosen because it looks a bit like the Greek letter lambda, λ.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- named function of 2 arguments</span>
<span class="n">sqsum</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">y</span>
<span class="c1">-- lambda function bound to a named variable</span>
<span class="n">sqsum</span> <span class="o">=</span> <span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">y</span>
</code></pre></div></div>

<p>The type of <code class="language-plaintext highlighter-rouge">sqsum</code> is</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sqsum</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
</code></pre></div></div>
<p>(Haskell uses <code class="language-plaintext highlighter-rouge">::</code> rather than <code class="language-plaintext highlighter-rouge">:</code> for the type signature)</p>

<p>In Haskell, partial application works exactly as in the examples above. So our function <code class="language-plaintext highlighter-rouge">sqsum</code> can be partially applied like this:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sqsum4</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">sqsum4</span> <span class="o">=</span> <span class="n">sqsum</span> <span class="mi">4</span>
</code></pre></div></div>

<p>We can apply <code class="language-plaintext highlighter-rouge">sqsum4</code> to the remaining argument:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sqsum4</span> <span class="mi">3</span> <span class="c1">-- returns 25</span>
</code></pre></div></div>

<p>This is very neat. But suppose you want to apply the second argument, rather than the first one? The Haskell Prelude library provides the function <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html#v:flip">flip</a>, which simply flips the arguments:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">flip</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span> 
<span class="n">flip</span> <span class="n">f</span> <span class="o">=</span> <span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">y</span> <span class="n">x</span>
</code></pre></div></div>

<p>That is fine as far as it goes, but let’s do a somewhat contrived example. Let’s say we have a function of four arguments:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">g</span> <span class="o">::</span> <span class="n">t1</span> <span class="o">-&gt;</span> <span class="n">t2</span> <span class="o">-&gt;</span><span class="n">t3</span> <span class="o">-&gt;</span><span class="n">t4</span> <span class="o">-&gt;</span><span class="n">tr</span>
<span class="n">g</span> <span class="n">x1</span> <span class="n">x2</span> <span class="n">x3</span> <span class="n">x4</span> <span class="o">=</span> <span class="n">x1</span><span class="o">*</span><span class="n">x3</span><span class="o">-</span><span class="n">x2</span><span class="o">*</span><span class="n">x4</span>
</code></pre></div></div>

<p>and we want to apply the 1st and 4th argument but not the others, something like <code class="language-plaintext highlighter-rouge">g v1 _ _ v4</code>.</p>

<p>One way to do this is to create yet another function (of course!):</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">apply14</span> <span class="o">::</span> <span class="p">(</span><span class="n">t1</span> <span class="o">-&gt;</span> <span class="n">t2</span> <span class="o">-&gt;</span> <span class="n">t3</span> <span class="o">-&gt;</span> <span class="n">t4</span> <span class="o">-&gt;</span> <span class="n">tr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">t1</span> <span class="o">-&gt;</span> <span class="n">t4</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">t2</span> <span class="o">-&gt;</span> <span class="n">t3</span> <span class="o">-&gt;</span> <span class="n">tr</span><span class="p">)</span>
<span class="n">apply14</span> <span class="n">f</span> <span class="n">x1</span> <span class="n">x4</span> <span class="o">=</span> <span class="nf">\</span><span class="n">x2</span> <span class="n">x3</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">x1</span> <span class="n">x2</span> <span class="n">x3</span> <span class="n">x4</span>
</code></pre></div></div>

<p>And with this function we can partially apply the 1st and 4th argument of <code class="language-plaintext highlighter-rouge">g</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">g14</span> <span class="o">=</span> <span class="n">apply14</span> <span class="n">g</span> <span class="n">v1</span> <span class="n">v4</span>
</code></pre></div></div>

<p>This example mainly serves to illustrate the power of the arrow-based function type notation: it lays out the type of <code class="language-plaintext highlighter-rouge">apply14</code> clearly and concisely.</p>

<h3 id="raku">Raku</h3>

<p>Raku provides the method <a href="https://docs.raku.org/routine/assuming">assuming</a>, which acts as a generalised version of our <code class="language-plaintext highlighter-rouge">apply14</code>:</p>

<pre><code class="language-perl6">my &amp;g14 = &amp;g.assuming( v1, *, *, v4);

g14(v2,v3); 
</code></pre>

<p>The return type of <code class="language-plaintext highlighter-rouge">assuming</code> is a <code class="language-plaintext highlighter-rouge">Callable</code>. This is a role for objects which support calling them. Thus, <code class="language-plaintext highlighter-rouge">g14</code> can be called as if it was a regular function.</p>

<h3 id="python">Python</h3>

<p>Python’s <a href="https://docs.python.org/2/library/functools.html">functools</a> provide the <code class="language-plaintext highlighter-rouge">partial</code> function:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="n">g14</span> <span class="o">=</span> <span class="nf">partial</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x1</span><span class="o">=</span><span class="n">v1</span><span class="p">,</span><span class="n">x4</span><span class="o">=</span><span class="n">v4</span><span class="p">)</span>

<span class="nf">g14</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span><span class="n">v3</span><span class="p">)</span>
</code></pre></div></div>

<p>The return type of <code class="language-plaintext highlighter-rouge">partial</code> is a <code class="language-plaintext highlighter-rouge">partial</code> object, which has an attribute <code class="language-plaintext highlighter-rouge">partial.func</code>, a callable object or function. Calls to the partial object will be forwarded to func with new arguments and keywords, so you can say <code class="language-plaintext highlighter-rouge">g14(v2,v3)</code> instead of <code class="language-plaintext highlighter-rouge">g14.func(v2,v3)</code>.</p>

<h3 id="rust">Rust</h3>

<p>Rust provides the <code class="language-plaintext highlighter-rouge">partial!</code> macro via its <a href="https://docs.rs/partial_application/0.2.1/partial_application/">partial_application</a> crate. Its behaviour is very similar to our <code class="language-plaintext highlighter-rouge">apply14</code>: “<code class="language-plaintext highlighter-rouge">partial!(some_fn =&gt; arg0, _, arg2, _)</code> returns the closure <code class="language-plaintext highlighter-rouge">|x1, x3| some_fn(arg0, x1, arg2, x3)</code>”.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[macro_use]</span>
<span class="k">extern</span> <span class="k">crate</span> <span class="n">partial_application</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">g</span><span class="p">(</span><span class="n">x1</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">x3</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">x4</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="n">x1</span><span class="o">*</span><span class="n">x3</span><span class="o">-</span><span class="n">x2</span><span class="o">*</span><span class="n">x4</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">v1</span><span class="o">=...</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">v2</span><span class="o">=...</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">v3</span><span class="o">=...</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">v4</span><span class="o">=...</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">g14</span> <span class="o">=</span> <span class="nd">partial!</span><span class="p">(</span><span class="n">g</span> <span class="k">=&gt;</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">v4</span><span class="p">);</span>

    <span class="nf">g14</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span><span class="n">v3</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="back-to-the-function-types">Back to the function types</h2>

<p>Suppose we want a type like the one we defined in C using a <code class="language-plaintext highlighter-rouge">typedef</code>, which encapsulates the function type:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">Fun</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span>
</code></pre></div></div>

<p>In Haskell, that would be</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">newtype</span> <span class="kt">Fun</span> <span class="o">=</span> <span class="kt">Fun</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
</code></pre></div></div>

<p>and we can generalise this to be a generic function of two arguments by using type variables instead of concrete types:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">newtype</span> <span class="kt">Fun2Args</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Fun2Args</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
</code></pre></div></div>

<p>So how would we use this? Let’s create an instance</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ft</span> <span class="o">::</span> <span class="kt">Fun2Args</span> <span class="n">a</span>
<span class="n">ft</span> <span class="o">=</span> <span class="kt">Fun2Args</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
</code></pre></div></div>

<p>This is fine, but to apply the function we first must unwrap the type constructor:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">((</span><span class="nf">\</span><span class="p">(</span><span class="kt">Fun2Args</span> <span class="n">f</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="p">)</span> <span class="n">ft</span> <span class="p">)</span> <span class="mi">3</span> <span class="mi">4</span>
</code></pre></div></div>
<p>That is not very handy. A better way is to use the record type syntax which gives us an accessor function:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">newtype</span> <span class="kt">Fun2Args</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Fun2Args</span> <span class="p">{</span> <span class="n">unF</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">}</span>
<span class="n">ft</span> <span class="o">=</span> <span class="kt">Fun2Args</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
<span class="p">(</span><span class="n">unF</span> <span class="n">ft</span><span class="p">)</span> <span class="mi">3</span> <span class="mi">4</span>
</code></pre></div></div>

<p>Now I have applied this to integer, but the type of the function is <code class="language-plaintext highlighter-rouge">Num a =&gt; a -&gt; a -&gt; a</code>, so this works for any type in the <code class="language-plaintext highlighter-rouge">Num</code> typeclass.</p>

<h2 id="named-function-types-for-raku">Named function types for Raku</h2>

<p>In Raku, we can follow a similar approach of wrapping a function signature in a type, and it is actually simpler than in Haskell. We create a parametric role which takes the function as a parameter, and has a method with the signature of the function:</p>

<pre><code class="language-perl6">role Fun2NumArgs[&amp;b] {
    method unF( Numeric \x,  Numeric \y --&gt; Numeric) {
        &amp;b(x,y);
    }
}

my \ft = Fun2NumArgs[ -&gt;\x,\y {x*x+y*y} ].new;

say ft.unF(3,4); 
</code></pre>

<p>But what is the benefit of doing this? Surely we could just have done</p>

<pre><code class="language-perl6">my &amp;f =  -&gt; Numeric \x, Numeric \y --&gt; Numeric {x*x+y*y};

say f(3,4);
</code></pre>

<p>For this simple example, that would indeed be enough as we don’t have functions of functions. But what we gain is that we can now create a function with arguments of type <code class="language-plaintext highlighter-rouge">Fun2NumArgs</code>:</p>

<pre><code class="language-perl6">sub fof (Fun2NumArgs \f1,Fun2NumArgs \f2 --&gt; Fun2NumArgs) {
...
}
</code></pre>

<p>In other words, we can now have explicitly typed function signatures in Raku. Recall that without this approach, the type of a function would be <code class="language-plaintext highlighter-rouge">Code</code> or any dependant in <a href="https://docs.raku.org/type/Code#Type_Graph">the Code type graph</a>. With the role-based type, the function must have the type of the method <code class="language-plaintext highlighter-rouge">unF</code>. Furthermore, these function types can be nested. Let’s create another type, for a function with two arguments of any type:</p>

<pre><code class="language-perl6">role Fun2Args[&amp;b] {
    method unF( Any \x, Any \y --&gt; Any) {
        &amp;b(x,y);
    }
}
</code></pre>

<p>We create two instances of <code class="language-plaintext highlighter-rouge">Fun2NumArgs</code>:</p>

<pre><code class="language-perl6">my \ft = Fun2NumArgs[ -&gt;\x,\y {x*x+y*y} ].new;
my \ft2 = Fun2NumArgs[ -&gt;\x,\y {x*y+y+x} ].new;
</code></pre>

<p>And a function of these two functions using <code class="language-plaintext highlighter-rouge">Fun2Args</code>:</p>

<pre><code class="language-perl6">my \fof2 = Fun2Args[ 
        sub (Fun2NumArgs \f1,Fun2NumArgs \f2 --&gt; Fun2NumArgs) {
            # returns another function of 2 Numeric arguments
        } 
    ].new;
</code></pre>

<p>We can now call the returned function like this:</p>

<pre><code class="language-perl6">say fof2.unF(ft,ft2).unF(3,4);
</code></pre>

<p>Having to call the <code class="language-plaintext highlighter-rouge">unF</code> method is not optimal. A better way is to can make the object itself callable instead, by defining <a href="https://docs.raku.org/routine/CALL-ME">the submethod <code class="language-plaintext highlighter-rouge">CALL-ME</code></a> instead of the method <code class="language-plaintext highlighter-rouge">unF</code>:</p>

<pre><code class="language-perl6">role Fun2Args[&amp;b] {
    submethod CALL-ME( \x,  \y --&gt; Any) {
        &amp;b(x,y);
    }
}

# And similar for Fun2NumArgs
</code></pre>

<p>In this way, we can do:</p>

<pre><code class="language-perl6">say fof2.(ft,ft2)(3,4);
</code></pre>

<p>This is almost what we want. But we can remove the <code class="language-plaintext highlighter-rouge">.</code> as well, by making <code class="language-plaintext highlighter-rouge">fof2</code> of type <code class="language-plaintext highlighter-rouge">Callable</code>. We can indicate this with the <code class="language-plaintext highlighter-rouge">&amp;</code> sigil. But with the current definition of <code class="language-plaintext highlighter-rouge">Fun2Args</code>, this will result in a type error because <code class="language-plaintext highlighter-rouge">Fun2Args</code> is not callable. However, <code class="language-plaintext highlighter-rouge">Callable</code> is a role so all we need to do is mix it in:</p>

<pre><code class="language-perl6">role Fun2ArgsC[&amp;b] does Callable {
    submethod CALL-ME( \x,  \y --&gt; Any) {
        &amp;b(x,y);
    }
}
</code></pre>

<p>In this way we have created something very similar to a <a href="https://en.wikipedia.org/wiki/Function_object">function object</a>, but using a role rather than a class. And now we can write:</p>

<pre><code class="language-perl6">my &amp;fof3 = Fun2ArgsC[ 
        sub (Fun2NumArgs \f1,Fun2NumArgs \f2 --&gt; Fun2NumArgs) {
            ...
        } 
    ].new;

say fof3(ft,ft2)(3,4);
</code></pre>

<p>To summarize, we create a parametric callable role where the parameter is the function to be called, and the signature of the CALL-ME submethod provides the type constraint to that function. Passing a function with a different signature will give a type error.</p>

<p>I think this is a nice way to have some additional type safety in your functional Raku code.</p>

<h2 id="bonus-tracks">Bonus Tracks</h2>

<ul>
  <li><a href="https://www.youtube.com/watch?v=StKVS0eI85I">“Call Me” by Blondie</a></li>
  <li><a href="https://www.youtube.com/watch?v=_04CojexsYw">“CALL ME” (「コール・ミー」) by Drop’s</a></li>
</ul>

<!--
But we can also have    

```haskell
newtype Fun2Args = Fun2Args forall a . a -> a -> a
```


Prelude> newtype Fun2Args = Fun2Args { unF::forall a . Num a => a -> a -> a}
Prelude> ft = Fun2Args (\x y -> x+y)
Prelude> :t ft
ft :: Fun2Args
Prelude> :t unF ft
unF ft :: Num a => a -> a -> a
Prelude> :t unF ft
unF ft :: Num a => a -> a -> a
Prelude> (unF ft) 3 4
7
Prelude> (unF ft) 3.4 4.5
7.9
Prelude> 
--
-->

				<hr />
				<footer class="page-footer">
					

<!--
<div class="author-image">
	<img src="https://wimvanderbauwhede.github.io/images/" alt="Wim Vanderbauwhede">
</div>
-->
<!-- ./author-image -->
<div class="author-content">
	<h3 class="author-name" >Written by <a href="http://www.dcs.gla.ac.uk/~wim" itemprop="author">Wim Vanderbauwhede</a></h3>
	<p class="author-bio"></p>
</div><!-- ./author-content -->

                    <div class="inline-btn">
    <a href="https://wimvanderbauwhede.github.io/atom.xml"><i class="fa fa-rss"></i></a>
</div><!-- /.follow-us -->

					
					<div class="page-meta">
	<p>Updated <time datetime="2020-08-07T00:00:00Z" itemprop="dateModified">August 07, 2020</time>
</div><!-- /.page-meta -->
				</footer><!-- /.footer -->
				<aside>
					
				</aside>
			</div><!-- /.content -->
		</div><!-- /.inner-wrap -->
		
	</article><!-- ./wrap -->
</div><!-- /#main -->


      <footer role="contentinfo" id="site-footer">
	<nav role="navigation" class="menu bottom-menu">
		<ul class="menu-item">
		
      
			<li><a href="https://wimvanderbauwhede.github.io/" >Wim Vanderbauwhede</a></li>
		
      
			<li><a href="https://wimvanderbauwhede.github.io/about/" >About</a></li>
		
		</ul>
	</nav><!-- /.bottom-menu -->
	<p class="copyright">&#169; 2025 <a href="https://wimvanderbauwhede.github.io">Wim Vanderbauwhede</a> <a rel="me" href="https://scholar.social/@wim_v12e">&nbsp;</a><br> <a href="http://jekyllrb.com">Jekyll</a> theme <a href="http://mmistakes.github.io/skinny-bones-jekyll/">Skinny Bones</a></p>

<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
var sc_project=10807901;
var sc_invisible=1;
var sc_security="7dfdbc2d";
var scJsHost = (("https:" == document.location.protocol) ?
"https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" +
scJsHost+
"statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript><div class="statcounter"><a title="web stats"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="http://c.statcounter.com/10807901/0/7dfdbc2d/1/"
alt="web stats"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->

</footer>

    </div>

    <!-- <script src="https://wimvanderbauwhede.github.io/js/vendor/jquery-1.9.1.min.js"></script> -->
    <!-- <script src="https://wimvanderbauwhede.github.io/js/main.js"></script> -->

    

  </body>

</html>
