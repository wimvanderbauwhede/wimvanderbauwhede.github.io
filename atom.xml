<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

    <title>Wim Vanderbauwhede</title>
    <generator uri="https://github.com/jekyll/jekyll">Jekyll v3.8.7</generator>
		<icon>https://wimvanderbauwhede.github.io/apple-touch-icon-precomposed.png</icon>
    <subtitle>Wim Vanderbauwhede</subtitle>
    <link href="https://wimvanderbauwhede.github.io/atom.xml" rel="self"/>
    <link href="https://wimvanderbauwhede.github.io/" rel="alternate" type="text/html"/>
    <updated>2023-04-11T09:28:06+01:00</updated>
    <id>https://wimvanderbauwhede.github.io/</id>
    <author>
			<name>Wim Vanderbauwhede</name>
			<uri>https://wimvanderbauwhede.github.io/</uri>
			
		</author>

    
    <entry>
        <title>Funktal: a frugal functional programming language</title>
        <link href="https://wimvanderbauwhede.github.io/articles/funktal/"/>
        <updated>2023-04-10T00:00:00+01:00</updated>
        <id>https://wimvanderbauwhede.github.io/articles/funktal</id>
        <author>
					<name>Wim Vanderbauwhede</name>
					<uri>https://wimvanderbauwhede.github.io/</uri>
					
				</author>
        <content type="html">
        	&lt;img src=&quot;https://wimvanderbauwhede.github.io/images/funktal_1600x600.jpg&quot;&gt;&lt;br/&gt;
        	&lt;p&gt;&lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/funktal&quot;&gt;&lt;code&gt;Funktal&lt;/code&gt;&lt;/a&gt; is a functional programming language for the &lt;a href=&quot;https://wiki.xxiivv.com/site/uxn.html&quot;&gt;Uxn&lt;/a&gt; virtual machine, a tiny VM with 8-bit opcodes and 64 kB of memory. I have written about implementing functional constructs in Uxn&amp;#39;s native stack based assembly language &lt;a href=&quot;https://wiki.xxiivv.com/site/uxntal.html&quot;&gt;Uxntal&lt;/a&gt; in &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/uxntal-quoting/&quot;&gt;a previous post&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Rationale&lt;/h2&gt;

&lt;p&gt;The main reason for creating Funktal was to see if it was possible to create a statically typed functional language with &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/roles-as-adts-in-raku/&quot;&gt;algebraic data types&lt;/a&gt; and &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/function-types/&quot;&gt;function types&lt;/a&gt; that could run on the Uxn VM, with a compiler that could be implemented in Uxntal. This is motivated by the observation that most modern languages are very resource-intensive: typical projects take a lot of disk space, compilers are large and require a lot of CPU cycles and memory to compile code, and the programs themselves are also very often CPU- and memory-intensive.&lt;/p&gt;

&lt;p&gt;Hard disks and solid-state drives are major contributors to the &lt;a href=&quot;https://principles.green/principles/embodied-carbon/&quot;&gt;embodied carbon&lt;/a&gt; in a computer, followed by the CPU and memory. Reducing these resources is an important way to reduce CO₂ emissions from computing. The ability to write useful software for older generations of hardware allows to use them for longer, and that is the main way to reduce embodied carbon.&lt;/p&gt;

&lt;h2&gt;Funktal design principles&lt;/h2&gt;

&lt;p&gt;The main principle for the design of Funktal is that it should use as little memory as possible, both for the compiler and the programs it produces. This influences most of the design decisions. But at the same time, it should be minimally but fully featured: I want a pure, strict functional language, with a sufficiently expressive static type system. Also, I want the language to be simple to write easy code but expressive enough to write more complex code.&lt;/p&gt;

&lt;p&gt;The main characteristics of Funktal are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It uses postfix notations (aka Reverse Polish Notation, Forth-style).&lt;/li&gt;
&lt;li&gt;It is entirely based on lambda functions (anonymous functions), but has named functions too.&lt;/li&gt;
&lt;li&gt;All variables are immutable (as they are lambda function arguments)&lt;/li&gt;
&lt;li&gt;The type system is based on primitive types and product and sum types and function types to create new types.&lt;/li&gt;
&lt;li&gt;Typing is optional, and therefore Funktal is not fully type safe.&lt;/li&gt;
&lt;li&gt;I/O is not pure.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There is a &lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/funktal/src/branch/main/SPEC.md&quot;&gt;specification&lt;/a&gt; (aimed at people who want to program in Funktal) and a &lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/funktal/src/branch/main/DESIGN.md&quot;&gt;design document&lt;/a&gt; (aimed at people who want to help develop Funktal or are just curious), both still very much in flux.&lt;/p&gt;

&lt;h2&gt;Funktal by example&lt;/h2&gt;

&lt;p&gt;All examples can be found in the &lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/funktal/src/branch/main/examples&quot;&gt;examples folder in the repo&lt;/a&gt;. To try them out, please see the &lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/funktal/&quot;&gt;README&lt;/a&gt; for installation instructions.&lt;/p&gt;

&lt;h3&gt;Basic syntax&lt;/h3&gt;

&lt;p&gt;Funktal is whitespace separated and consists of a number of blocks, the most important of which are &lt;code&gt;types&lt;/code&gt;, &lt;code&gt;constants&lt;/code&gt;, &lt;code&gt;functions&lt;/code&gt;, and &lt;code&gt;main&lt;/code&gt;. There are only expressions, so the entire main program is a single sequence of expressions. Newlines are only for readability and as comment delimiters: anything after a &lt;code&gt;--&lt;/code&gt; until a newline is considered a comment.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;main {
    6 7 * print -- prints 42
    0x0a print  -- prints a newline
    &amp;quot;Hello&amp;quot; print -- prints Hello
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Lambdas and named functions&lt;/h3&gt;

&lt;p&gt;Funktal is a functional language so the key building block is the lambda function (anonymous function). Each lambda is enclosed in parentheses and the arguments are listed between &lt;code&gt;\&lt;/code&gt; and &lt;code&gt;.&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Lambdas do not need to have arguments. Because Funktal is a stack language, if there is anything on the stack, it will be used as argument for the functions. But arguments are often convenient.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;main {
    6 (\x. x x * x 2 * + x -  print ) -- 42
    6  (\x. 7 (\y . x y * print ) ) -- 42
    2 84 `( / ) (\ x y div . y x div apply ) print -- 0x002a
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The second example shows a nesting lambdas, with the &lt;code&gt;x&lt;/code&gt; argument of the outer lambda in scope in the body of the nested lambda.&lt;/p&gt;

&lt;p&gt;The last line is an example of &lt;em&gt;quoting&lt;/em&gt; of functions: &lt;code&gt;( / )&lt;/code&gt; is anonymous function without arguments which only performs a division. More fully we could write it as &lt;code&gt;(\ x y . x y /)&lt;/code&gt;. Normally, this function would be called right away. By quoting it with a backtick, it is not called until we call it explicitly using &lt;code&gt;apply&lt;/code&gt;. The example also shows that functions can be passed as arguments to other functions.&lt;/p&gt;

&lt;h3&gt;Primitive types&lt;/h3&gt;

&lt;p&gt;Funktal has primitive types &lt;code&gt;Int8&lt;/code&gt;, &lt;code&gt;Int16&lt;/code&gt;, &lt;code&gt;AChar&lt;/code&gt;, &lt;code&gt;Byte&lt;/code&gt; and &lt;code&gt;Short&lt;/code&gt;. &lt;code&gt;Int&lt;/code&gt; is currently a synonym for &lt;code&gt;Int16&lt;/code&gt;. &lt;code&gt;AChar&lt;/code&gt; is an ASCII character; &lt;code&gt;Byte&lt;/code&gt; is a raw byte value and &lt;code&gt;Short&lt;/code&gt; a raw 2-byte value. The arrow &lt;code&gt;&amp;lt;-&lt;/code&gt; in the type signature separates arguments and return type of a function. The colon &lt;code&gt;:&lt;/code&gt; separates the argument from its type.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;main {
    6 (\ Int &amp;lt;- x : Int . x x * 2 x * + x - ) print
    (\ Int8 . 6 (\ Int8 &amp;lt;- x : Int8 . x x * 2 x * + x - ) print )
    0x2a 0x2b (\ Byte &amp;lt;- b1: Byte &amp;lt;- b2 : Byte . b1 b2 &amp;amp; ) print
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Without type information, Funktal defaults to 16-bit operations. If you want to use 8-bit operations, explicit typing is necessary, as in the examples above. As shown in the second example, a lambda without arguments can still have an explicit return type.&lt;/p&gt;

&lt;h3&gt;Constants&lt;/h3&gt;

&lt;p&gt;Constants are a convenience. The main purpose is to define arrays of values (e.g. bitmaps) and strings, but scalars are also supported. There is a built-in type that is not strictly speaking primitive: &lt;code&gt;Array&lt;/code&gt;, used to create array constants. Its constructor takes the type and number of the elements in the array.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;constants {
    hello : AChar 6 Array = &amp;quot;Hello!&amp;quot;
}

main {
    hello print
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Sum types and conditionals&lt;/h3&gt;

&lt;p&gt;As mentioned above, Funktal has algebraic data types. The Boolean type is an example of a sum type (similar to an enum): it has two alternatives, &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt;. The example also shows the &lt;code&gt;if&lt;/code&gt; builtin, which takes two quoted lambdas and a condition, i.e. any expression which returns True or False.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Any&lt;/code&gt; type is the supertype of all types. Funktal does (currently) not have polymorphism. The &lt;code&gt;Any&lt;/code&gt; type can be used explicitly and is also the type of any untyped expression. Because Funktal allows untyped expressions and does not do type inference (yet), it is not fully type safe.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;types {
    Bool = True | False
}

main {
    True (\ Any &amp;lt;- cond : Bool .
        `( &amp;quot;true&amp;quot; print )
        `( &amp;quot;false&amp;quot; print )
        cond if
    )
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Product data type construction and pattern matching&lt;/h3&gt;

&lt;p&gt;This is an example of a record or product type. The &lt;code&gt;RGB&lt;/code&gt; type is a triplet of 8-bit integers. The reason why the entire expression is wrapped in a typed lambda is that otherwise the integers would be treated as 16-bit. Funktal does not have proper type checking yet. The return type of a function determines the size of the operations and constants used in the function body.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;types {
    RGB =  Int8 Int8 Int8 RGB
}

main {
        (\ Int8 . 42 43 44 RGB (\ Int8 &amp;lt;- (r g b RGB) : RGB . r ) ) print
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Recursion&lt;/h3&gt;

&lt;p&gt;Funktal does not have mutable variables so it has no loops. Instead, it uses recursion.&lt;/p&gt;

&lt;h4&gt;Factorial with named functions&lt;/h4&gt;

&lt;p&gt;This is a straightforward recursion to calculate a factorial: if &lt;code&gt;b==e&lt;/code&gt; then return the result &lt;code&gt;r&lt;/code&gt; else recurse with the counter &lt;code&gt;b+1&lt;/code&gt; and the accumulator &lt;code&gt;r*b&lt;/code&gt;. This is a tail recursion. It also demonstrates the use if named functions, and Funktal&amp;#39;s natural ability to support point-free programming.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;function {
    fact = ( 1 1 fact_rec )
    fact_rec =  (\ Int  &amp;lt;- e : Int &amp;lt;- b : Int &amp;lt;- r : Int . `( r e * )  `(  e b 1 + r b * fact_rec) b e == if )
}

main {
    5 fact 1 * print
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I use an actual recursive function &lt;code&gt;fact_rec&lt;/code&gt; and a wrapper to initialise the counter and the accumulator.&lt;/p&gt;

&lt;h4&gt;Recursion without named functions&lt;/h4&gt;

&lt;p&gt;Recursion means a function calls itself. But what if the function doesn&amp;#39;t have a name? A &lt;em&gt;fixed-point combinator&lt;/em&gt; allows to do recursion on unnamed functions. The most common one is the Y-combinator. The way I&amp;#39;ve done this here is a bit different, but equivalent. The quoted function describes the recursion. But because that function has no name, it can&amp;#39;t call itself. The function &lt;code&gt;(\f. f f apply)&lt;/code&gt; takes it as its argument, so now it has a name and can be called recursively.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;main {
    5
    `(\ n &amp;lt;- f . `(1) `( n 1 - f f apply n * ) n 1 == if)
    (\ Int &amp;lt;- f : Any . f f apply ) print
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Lists and fold&lt;/h4&gt;

&lt;p&gt;Algebraic data types can also be used to construct lists, like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;types {
    List = List Any Cons | Nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is a recursive type, a List is either a function Cons with takes a List and some value, or a function Nil which takes no arguments. So we can build lists by writing e.g.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;Nil 11 Cons 22 Cons 33 Cons
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In practice, it is handy to have a function to generate a range of numbers (&lt;code&gt;range&lt;/code&gt; below) and list manipulation functions like &lt;code&gt;head&lt;/code&gt;, &lt;code&gt;tail&lt;/code&gt;, &lt;code&gt;fold&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt;. The example shows the use of &lt;code&gt;range&lt;/code&gt; and &lt;code&gt;fold&lt;/code&gt; to calculate a factorial by multiplying all values in a list.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;functions {
    -- First element of a list
    head = (\ Any &amp;lt;- (xs x Cons) . x )
    -- The rest of the list
    tail = (\ List &amp;lt;- (xs x Cons) . xs )
    -- Creates a list with a range of integers
    range Creates a list with = ( Nil integers ec
    range_rec = (\List &amp;lt;- b: Int &amp;lt;- e: Int &amp;lt;- lst : List . `( lst e Cons ) `( b 1 + e lst b Cons range_rec ) b e == if )
    -- A reduction: fold takes a list, an accumulator and a function and combines all elements of the list into the accumulator
    fold = (\ Any &amp;lt;- lst : List &amp;lt;- acc : Any  &amp;lt;- f : Any . `( acc ) `( lst tail acc lst head f apply f fold ) lst `Nil is if )
}

main {
    (\Int . 1 5 range 1 `( * ) fold ) print
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Implementation&lt;/h2&gt;

&lt;p&gt;The Funktal compiler should be implementable in Uxntal (or even Funktal) and run on Uxn. I did not feel I was sufficiently fluent in Uxntal to use it as the implementation language. Instead, I opted to write the compiler in &lt;code&gt;Fortran&lt;/code&gt;, but in such a way that porting to Uxntal should be straightforward.&lt;/p&gt;

&lt;p&gt;Why Fortran? Funktal is essentially an art project; using Fortran is a statement. I could have done this in C, but I prefer Fortran&amp;#39;s arrays. I am using Fortran-90 but with a very restricted feature set. In case you don&amp;#39;t know Fortran, here are some of its characteristics:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;No lexical scoping&lt;/li&gt;
&lt;li&gt;Numeric labels for &lt;code&gt;goto&lt;/code&gt;; no &lt;code&gt;break&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Arrays starting by default at 1 but can start at any integer value&lt;/li&gt;
&lt;li&gt;No unsigned integers&lt;/li&gt;
&lt;li&gt;No native hash tables&lt;/li&gt;
&lt;li&gt;Implicit typing based on the first letter of the variable name (*)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;small&gt;(*) But luckily you can disable that feature in Fortran-90&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;Furthermore, because of the restricted subset I use:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;No pointers so no native linked lists&lt;/li&gt;
&lt;li&gt;No derived types, so no structs&lt;/li&gt;
&lt;li&gt;No dynamic allocation&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It is almost as if I&amp;#39;d have taken the &lt;a href=&quot;https://homepages.inf.ed.ac.uk/rni/papers/realprg.html&quot;&gt;&amp;quot;Real Programmers Don&amp;#39;t Use PASCAL&amp;quot;&lt;/a&gt; essay too literally:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;LANGUAGES&lt;br&gt;
The easiest way to tell a Real Programmer from the crowd is by the programming language he (or she) uses. Real Programmers use FORTRAN. [...]&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;Real Programmers do List Processing in FORTRAN
Real Programmers do String Manipulation in FORTRAN.
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you can&amp;#39;t do it in FORTRAN, do it in assembly language. If you can&amp;#39;t do it in assembly language, it isn&amp;#39;t worth doing.&lt;/p&gt;

&lt;p&gt;STRUCTURED PROGRAMMING&lt;br&gt;
[...] Some quick observations on Real Programmers and Structured Programming:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;Real Programmers aren&amp;#39;t afraid to use GOTO&amp;#39;s.
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;[...]. As all Real Programmers know, the only useful data structure is the Array. Strings, lists, structures, sets -- these are all special cases of arrays and can be treated that way just as easily without messing up your programming language with all sorts of complications. [...]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Be that as it may, this restricted subset maps cleanly to Uxntal, and also forces me to think very carefully about data structures. As a result, the compiler in its current states about 5,000 lines of code, allocates less than 64 kB and compiles to an executable of about 100 kB. For reference, &lt;code&gt;uxnasm&lt;/code&gt; is 20 kB, &lt;code&gt;uxncli&lt;/code&gt; is   25 kB and &lt;code&gt;uxnemu&lt;/code&gt; is 50 kB. But &lt;code&gt;gcc&lt;/code&gt; and &lt;code&gt;gfortran&lt;/code&gt; are 1.2 MB and &lt;code&gt;rustc&lt;/code&gt; is 15 MB.&lt;/p&gt;

&lt;h2&gt;Status&lt;/h2&gt;

&lt;p&gt;Funktal needs a lot more work. In terms of features, it needs at least:
- a proper type checker and probably a better type system;
- support for devices and state for GUI programming;
- a mechanism to include libraries, both funktal and uxntal.&lt;/p&gt;

&lt;p&gt;Apart from that, there are plenty of bugs and shortcomings that need fixing. But it is already good enough to have some fun with, which is of course the main purpose.&lt;/p&gt;

        </content>
    </entry>
    
    <entry>
        <title>The climate cost of the AI revolution</title>
        <link href="https://wimvanderbauwhede.github.io/articles/climate-cost-of-ai-revolution/"/>
        <updated>2023-03-06T00:00:00+00:00</updated>
        <id>https://wimvanderbauwhede.github.io/articles/climate-cost-of-ai-revolution</id>
        <author>
					<name>Wim Vanderbauwhede</name>
					<uri>https://wimvanderbauwhede.github.io/</uri>
					
				</author>
        <content type="html">
        	&lt;img src=&quot;https://wimvanderbauwhede.github.io/images/climate-cost-of-ai-revolution_1600x600.jpg&quot;&gt;&lt;br/&gt;
        	&lt;p&gt;ChatGPT and other AI applications such as Midjourney have pushed &amp;quot;Artificial Intelligence&amp;quot; high on the hype cycle. In this article, I want to focus specifically on the energy cost of training and using applications like ChatGPT, what their widespread adoption could mean for global CO₂ emissions, and what we could do to limit these emissions.&lt;/p&gt;

&lt;h2&gt;Key points&lt;/h2&gt;

&lt;h3&gt;Training of large AI models is not the problem&lt;/h3&gt;

&lt;p&gt;Training of large AI models requires a lot of electricity. However, for a modest growth scenario where there would be a hundred very popular AI-based services in the entire world, I estimate that the global CO₂ emissions from training AI are likely to remain relatively small.&lt;/p&gt;

&lt;h3&gt;Large-scale use of large AI models would be unsustainable&lt;/h3&gt;

&lt;p&gt;For that same  modest growth scenario, with a hundred very popular AI-based services in the entire world, the electricity consumption resulting from the use of these services would lead to unsustainable increases in global CO₂ emissions.&lt;/p&gt;

&lt;h3&gt;Renewables are not making AI more sustainable&lt;/h3&gt;

&lt;p&gt;Using renewables to power AI is not the solution. Large scale adoption of AI would lead to a huge increase in electricity consumption, much more than can be offset even by the fastest possible roll-out of renewables. So even if all AI is powered by renewables, it will not help us reduce global emissions and we will still miss the global climate targets.&lt;/p&gt;

&lt;h3&gt;Reducing the climate cost of AI&lt;/h3&gt;

&lt;p&gt;Technological solutions to increase energy efficiency of AI are likely to lead to a more than proportionate increase in demand for AI - as history has shown us with other technology adoptions. As with any activity that consumes energy, the best way to limit energy consumption is to limit the activity. As a society we need to treat AI resources as finite and precious, to be utilised only when necessary, and as effectively as possible. We need &lt;em&gt;frugal AI&lt;/em&gt;. &lt;/p&gt;

&lt;h2&gt;Carbon cost of electricity usage&lt;/h2&gt;

&lt;p&gt;Many tech companies make much of their use of renewables to power their services. What metric should we use for the electricity usage of ICT in general and Large Language Models in particular? I argue that the metric to use is the carbon intensity of the geographical area in which the electricity is generated and can be traded. In practice, that means the country or group of countries of generation. If the usage is globally distributed, we should use the weighted average intensity.&lt;/p&gt;

&lt;p&gt;Because electricity is still predominantly generated from fossil fuels. In the US, where most of the data centres for AI training and use are located, &lt;a href=&quot;https://www.eia.gov/tools/faqs/faq.php?id=427&amp;t=3&quot;&gt;according to IEA data&lt;/a&gt; this is 60%; only 21% is truly renewable. According to &lt;a href=&quot;https://ec.europa.eu/eurostat/statistics-explained/index.php?title=Renewable_energy_statistics&quot;&gt;EuroStat&lt;/a&gt;, in the EU renewables account for 22% and according to &lt;a href=&quot;https://www.nationalgrid.com/stories/energy-explained/how-much-uks-energy-renewable&quot;&gt;National Grid&lt;/a&gt;, in the UK it is 38%. Therefore, using renewables for increased electricity usage simply results in displacement of the emissions. &lt;a href=&quot;https://www.weforum.org/agenda/2021/07/renewables-cheapest-energy-source/&quot;&gt;Renewables are already the cheapest form of generation&lt;/a&gt;, so generators do not need market pull to install more capacity: to maximise their profit, they will maximise their renewables capacity. Even when the generation is on-site, the argument still stands: the electricity use to power AI could be traded on the grid. So in the case of GPT-3 we should use the overall carbon intensity of the US, which is 371 gCO₂/kWh according to &lt;a href=&quot;https://carbonfund.org/calculation-methods/&quot;&gt;the Carbon Fund&lt;/a&gt;, or alternatively the global carbon intensity, 476 gCO₂/kWh according to &lt;a href=&quot;https://www.iea.org/reports/world-energy-outlook-2019&quot;&gt;the IEA World Energy Outlook 2019&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Carbon emissions from ICT&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://limited.systems/articles/frugal-computing/&quot;&gt;There is an imperative to &lt;em&gt;reduce&lt;/em&gt; emissions from information and communication technologies&lt;/a&gt; (ICT): purely to keep to the Paris agreement, they should drop to a quarter of current emissions in the next 20 years, from about &lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/S2666389921001884&quot;&gt;2 GtCO₂e/y (including embodied emissions)&lt;/a&gt; to 500 MtCO₂e/y. So this is the global ICT carbon budget for the future.&lt;/p&gt;

&lt;p&gt;This is not going to happen through renewables: with business as usual, by 2040 renewables will be &lt;a href=&quot;https://iea.blob.core.windows.net/assets/deebef5d-0c34-4539-9d0c-10b13d840027/NetZeroby2050-ARoadmapfortheGlobalEnergySector_CORR.pdf&quot;&gt;at best 70% of all generated electricity&lt;/a&gt;, and crucially, &lt;a href=&quot;https://iea.blob.core.windows.net/assets/deebef5d-0c34-4539-9d0c-10b13d840027/NetZeroby2050-ARoadmapfortheGlobalEnergySector_CORR.pdf&quot;&gt;generation from fossil fuels will largely remain constant&lt;/a&gt;. So even though we will have more electricity, we will not have less emissions. Therefore, reducing global electricity consumption from ICT is critical.&lt;/p&gt;

&lt;h2&gt;Training Large Language Models&lt;/h2&gt;

&lt;p&gt;Although the large amount of CO₂ emissions resulting from AI training has received a lot of attention, I would argue that training of LLMs is not the main problem.&lt;/p&gt;

&lt;p&gt;According to a peer-reviewed paper by &lt;a href=&quot;https://arxiv.org/pdf/2104.10350.pdf&quot;&gt;Patterson et al.&lt;/a&gt;, training GPT-3 generates 552 ton of CO₂ (tCO₂e). (Using yearly average carbon intensity, it is 477 tCO₂e; the paper used the actual intensity during the period of training, and that was slightly higher).
This is not much compared to the &lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/S2666389921001884&quot;&gt;total emissions from ICT&lt;/a&gt;, but it is still the same amount of CO₂ as produced by &lt;a href=&quot;https://heatable.co.uk/boiler-advice/average-carbon-footprint&quot;&gt;heating 250 average UK homes for one year&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;However, on the one hand, this is just a single model. On the other hand, one of the problems with those large language models is that they need to be kept up-to-date. People will expect the chat bot to know who this week&amp;#39;s Prime Minister is, or the current hit songs, games and movies. Which means that training will need to be an ongoing process. So the carbon footprint will become many times larger than it already is. For the sake of argument, let&amp;#39;s assume as a worst case that the model would need to be retrained fully every day. Then emissions from training would be 365 times larger, so about 175 ktCO₂e/y. If globally there would be a hundred such models from competing companies in different countries, that would mean an increase in global emissions of about 20 MtCO₂e/y.&lt;/p&gt;

&lt;p&gt;This assumes full retraining; it will likely become possible to split the training data into a large static pre-trained set which needs to be updated infrequently, and a dynamic set which needs to be updated weekly or even daily. It is also likely that computational efficiency gains will be found.&lt;/p&gt;

&lt;p&gt;In any case, even if this was not so, and even if updates were daily, emissions from electricity generation used for training would not exceed 2% of global ICT CO₂ budget &amp;mdash; assuming that the number of such large models does not rise to thousands.&lt;/p&gt;

&lt;p&gt;What about the embodied carbon? &lt;a href=&quot;https://news.microsoft.com/source/features/ai/openai-azure-supercomputer/&quot;&gt;Microsoft claims&lt;/a&gt; that the supercomputer used to train GPT-3 hosts 10,000 GPUs and 285,000 CPU cores. Assuming these were similar to &lt;a href=&quot;https://learn.microsoft.com/en-us/azure/virtual-machines/ndv2-series&quot;&gt;NDv2 instances&lt;/a&gt;, we can estimate their embodied carbon &lt;a href=&quot;https://www.boavizta.org/en/blog/empreinte-de-la-fabrication-d-un-serveur&quot;&gt;starting from work by Boavizta&lt;/a&gt; in the order of 2 tCO₂e per node, for 1250 nodes (8 GPUs per node). This is based on the assumptions that each node has a 3TB SSD, 512GB RAM and 2 Xeon CPUs, plus 8 V100 GPUs with each 32GB RAM.&lt;/p&gt;

&lt;p&gt;So the total embodied carbon is of the order 2.5 ktCO₂ per machine. However, it takes 14 days to train GPT-3. So to manage daily retraining, 14 such machines are needed. Assuming 4 years useful life, that would result  in embodied carbon of the order of 35 ktCO₂e/y. So the embodied carbon is of the order of 20% of the total emissions, and we can put the total between 10 and 100 MtCO₂e/y to account for uncertainties in the estimates.&lt;/p&gt;

&lt;p&gt;This means that the increased consumption from training of LLMs could with the highest estimate amount to 20% of the global ICT CO₂ budget. Nevertheless, as the cost of this amount of energy for training would probably be prohibitive, and there are clearly technical options to reduce the energy consumption, I don&amp;#39;t think it is likely that training of LLMs will lead to more than a few percent increase in ICT CO₂ emissions. So far, so good.&lt;/p&gt;

&lt;h2&gt;Using Large Language Models&lt;/h2&gt;

&lt;p&gt;Next, let&amp;#39;s consider the use of LLMs. An estimate for the footprint of ChatGPT is given by  &lt;a href=&quot;https://medium.com/@chrispointon/the-carbon-footprint-of-chatgpt-e1bc14e4cc2a&quot;&gt;Chris Pointon&lt;/a&gt; as 77,160 kWh per day assuming 13 million users per day with 5 questions each, so 65 million queries. This would generate
30 tCO₂e per day or 0.5 gCO₂e per query.&lt;/p&gt;

&lt;p&gt;Just to be clear, in the big picture (&lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/S2666389921001884&quot;&gt;total global ICT emissions of 2 GtCO₂e&lt;/a&gt;) this kind of footprint is still very small. But with a billions of queries per day, that means tens of MtCO₂e/y.&lt;/p&gt;

&lt;p&gt;If that sounds improbable, consider this:  currently, Bing and Google each process 10 billion queries per day. So already, we would be looking at an electricity consumption of 8.7 TWh/y or emissions of 4 MtCO₂e/y purely from Bing and Google searches alone, without any growth or any other applications.&lt;/p&gt;

&lt;p&gt;If there would be 100 such models as assumed above, that would mean 435 TWh/y or 200 MtCO₂e/y, even without taking into account the embodied carbon; recall that ICT has a proportional carbon budget of 500 MtCO₂e/y by 2040, so that would be 40% of that budget; and this is a budget that can&amp;#39;t be exceeded without letting global warming get out of control.&lt;/p&gt;

&lt;p&gt;There is probably no room for a hundred major search engines, but there are many other use cases for ChatGPT and other LLMs, e.g. dynamic content generation for SEO spamming, better email spam etc and there are of course also the image-based generative models. So the coexistence of just a hundred large applications of LLMs in the whole world is entirely plausible.&lt;/p&gt;

&lt;p&gt;From this it is clear that large-scale adoption of LLMs would lead to unsustainable increases in ICT CO₂ emissions.&lt;/p&gt;

&lt;h2&gt;Reducing the climate cost&lt;/h2&gt;

&lt;p&gt;Assuming that ChatGPT-style LLMs make it through the &lt;a href=&quot;https://www.gartner.com/en/research/methodologies/gartner-hype-cycle&quot;&gt;Gartner hype cycle&lt;/a&gt; and are here to stay, then their energy consumption will become a major concern. In the big picture, the best way to address this would of course be not to use this highly polluting technology. After all, there is no burning need for LLMs, it is currently very much a case of a solution looking for a problem.&lt;/p&gt;

&lt;p&gt;Second best would be to put a carbon tax on electricity usage. That might seem like a good way to curb electricity use in general. However, companies would likely resort to on-site generation. Considering the scale of the required electricity generation, it is more precise to say &amp;quot;private generation&amp;quot; than &amp;quot;on-site&amp;quot; or &amp;quot;local&amp;quot;:
435 TWh/y is 15% of the global ICT electricity consumption. This can&amp;#39;t simply be generated by putting a few solar panels on the roofs of the data centres. It would require a 500 MW wind farm per application. For example, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Whitelee_Wind_Farm&quot;&gt;Whitelee wind farm&lt;/a&gt; near Glasgow, the largest on-shore wind farm in the UK, has a maximum generative capacity of 539 MW and covers an area of 55 km² (about the size of Manhattan). Solar power in hot countries has a higher energy density, but is still of the same order: e.g. the &lt;a href=&quot;https://www.theecoexperts.co.uk/solar-panels/biggest-solar-farms&quot;&gt;Bhadla Solar Park&lt;/a&gt; in India, one of the largest solar farms in the world, has 2.7 GW capacity and covers 160 km², so 500MW would require 30 km².&lt;/p&gt;

&lt;p&gt;So to provide &amp;quot;on-site&amp;quot; generation for an LLM application such as ChatGPT-enabled search, a company would have to buy a similar area of land for its private wind or solar farm, thereby reducing the area available for replacing generation from fossil fuels.&lt;/p&gt;

&lt;p&gt;There is however a lot of scope for energy savings. To start with, for many applications there is no need for a model of the size of GPT-3. Something 10x smaller will do the job just fine, at a fraction of the cost. For example, many of Google&amp;#39;s current models are of that size. Of course, if there are many, then combined they will have similar footprints.&lt;/p&gt;

&lt;p&gt;Then there are potential efficiency savings, e.g. through use of energy-efficient hardware accelerators such as FPGAs, Google&amp;#39;s TPU chips or Cerebras&amp;#39; Wafer-Scale Engine. All of these have in principle the potential to be an order of magnitude more efficient for both the training tasks and queries.&lt;/p&gt;

&lt;p&gt;In fact, for many tasks an LLM or other large-scale model is at best total overkill, and at worst unsuitable, and a conventional Machine Learning or Information Retrieval technique will be orders of magnitude more energy efficient and cost effective to run. Especially in the context of chat-based search, the energy consumption could be reduced significantly through generalised forms of caching, replacement of the LLM with a rule-based engines for much-posed queries, or of course simply defaulting to non-AI search.&lt;/p&gt;

&lt;p&gt;However, improved resource usage efficiency also lowers the relative cost of using a resource, which leads to increased demand [1]. This is known as &lt;a href=&quot;https://www.oecd-forum.org/posts/the-jevons-paradox-and-rebound-effect-are-we-implementing-the-right-energy-and-climate-change-policies&quot;&gt;Jevons paradox&lt;/a&gt; or the &amp;quot;rebound effect&amp;quot;. Jevons described in 1865 how energy efficiency improvements increased  consumption of coal. What this means is that the way to reduce the climate cost of the AI revolution can&amp;#39;t be purely technological. As with any activity that consumes energy, the best way to limit energy consumption is to limit the activity.&lt;/p&gt;

&lt;p&gt;As a society we need to treat AI resources as finite and precious, to be utilised only when necessary, and as effectively as possible. We need &lt;em&gt;frugal AI&lt;/em&gt;.&lt;/p&gt;

        </content>
    </entry>
    
    <entry>
        <title>Immutable data structures and reduction in Raku</title>
        <link href="https://wimvanderbauwhede.github.io/articles/immutable-datastructures-reduction/"/>
        <updated>2022-11-20T00:00:00+00:00</updated>
        <id>https://wimvanderbauwhede.github.io/articles/immutable-datastructures-reduction</id>
        <author>
					<name>Wim Vanderbauwhede</name>
					<uri>https://wimvanderbauwhede.github.io/</uri>
					
				</author>
        <content type="html">
        	&lt;img src=&quot;https://wimvanderbauwhede.github.io/images/immutable-datastructures-reduction_1600x600.jpg&quot;&gt;&lt;br/&gt;
        	&lt;h1&gt;Immutable data structures and reduction in Raku&lt;/h1&gt;

&lt;p&gt;For &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/uxntal-to-C/&quot;&gt;a little compiler&lt;/a&gt; I&amp;#39;ve been writing, I felt increasingly the need for immutable data structures to ensure that nothing was passed by references between passes. I love Perl and Raku but I am a functional programmer at heart, so I prefer map and reduce over loops. It bothered me to run reductions on a mutable data structure. So I made &lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/nito/src/branch/main/lib/ImmutableDatastructureHelpers.rakumod&quot;&gt;a small library&lt;/a&gt; to make it easier to work with immutable maps and lists.&lt;/p&gt;

&lt;p&gt;A reduction combines all elements of a list into a result. A typical example is the sum of all elements in a list. According to the Raku docs, &lt;code&gt;reduce()&lt;/code&gt; has the following signature&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;reduce&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;&amp;amp;with&lt;/span&gt;, +&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In general, if we have a list of elements of type &lt;code&gt;T1&lt;/code&gt; and a result of type &lt;code&gt;T2&lt;/code&gt;, Raku&amp;#39;s &lt;code&gt;reduce()&lt;/code&gt; function takes as first argument a function of the form&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;-&amp;gt; &lt;span class=&quot;n&quot;&gt;T2&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;T1&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;T2&lt;/span&gt; { ... }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I use the form of &lt;code&gt;reduce&lt;/code&gt; that takes three arguments: the reducing function, the accumulator (what the Raku docs call the initial value) and the list.  As explained in the docs, Raku&amp;#39;s &lt;code&gt;reduce&lt;/code&gt; operates from left to right. (In Haskell speak, it is a &lt;code&gt;foldl :: (b -&amp;gt; a -&amp;gt; b) -&amp;gt; b -&amp;gt; [a]&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;The use case is the traversal of a role-based datastructure &lt;code&gt;ParsedProgram&lt;/code&gt; which contains a map and an ordered list of keys. The map itself contains elements of type &lt;code&gt;ParsedCodeBlock&lt;/code&gt; which is essentially a list of tokens.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ParsedProgram&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.blocks&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;# {String =&amp;gt; ParsedCodeBlock}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.blocks-sequence&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;# [String]&lt;/span&gt;
    ...
}

&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ParsedCodeBlock&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.code&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;# [Token]&lt;/span&gt;
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;List and Map are immutable, so we have immutable datastructures. What I want do do is update these datastructures using a nested reduction where I iterate over all the keys in the &lt;code&gt;blocks-sequence&lt;/code&gt; List and then modify the corresponding ParsedCodeBlock. For that purpose, I wrote a small API, and in the code below, &lt;code&gt;append&lt;/code&gt; and &lt;code&gt;insert&lt;/code&gt; are part of that API. What they do is create a fresh List resp. Map rather than updating in place.&lt;/p&gt;

&lt;p&gt;I prefer to use sigil-less variables for immutable data, so that sigils in my code show where I have use mutable variables.&lt;/p&gt;

&lt;p&gt;The code below is an example of a typical traversal. We iterate over a list of code blocks in a program, &lt;code&gt;parsed_program.blocks-sequence&lt;/code&gt;; on every iteration, we update the program &lt;code&gt;parsed_program&lt;/code&gt; (the accumulator).
The &lt;code&gt;reduce()&lt;/code&gt; call takes a lambda function with the accumulator  (&lt;code&gt;ppr_&lt;/code&gt;) and a list element (&lt;code&gt;code_block_label&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;We get the code blocks from the program&amp;#39;s map of blocks, and use &lt;code&gt;reduce()&lt;/code&gt; again to update the tokens in the code block. So we iterate over the original list of tokens (&lt;code&gt;parsed_block.code&lt;/code&gt;) and build a new list. The lambda function therefore has as accumulator the updated list (&lt;code&gt;mod_block_code_&lt;/code&gt;) and as element a token (&lt;code&gt;token_&lt;/code&gt;). &lt;/p&gt;

&lt;p&gt;The inner reduce creates a modified token and puts it in the updated list using &lt;code&gt;append&lt;/code&gt;. Then the outer reduce updates the block code using &lt;code&gt;clone&lt;/code&gt; and updates the map of code blocks in the program using &lt;code&gt;insert&lt;/code&gt;, which updates the entry if it was present. Finally, we update the program using &lt;code&gt;clone&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;reduce&lt;/span&gt;(
    -&amp;gt; &lt;span class=&quot;n&quot;&gt;ParsedProgram&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;ppr_&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;code_block_label&lt;/span&gt; {
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ParsedCodeBlock&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;parsed_block&lt;/span&gt; =
            &lt;span class=&quot;n&quot;&gt;ppr_&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;blocks&lt;/span&gt;{&lt;span class=&quot;n&quot;&gt;code_block_label&lt;/span&gt;};

        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;mod_block_code&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;reduce&lt;/span&gt;(
            -&amp;gt; \&lt;span class=&quot;n&quot;&gt;mod_block_code_&lt;/span&gt;,\&lt;span class=&quot;n&quot;&gt;token_&lt;/span&gt; {
                &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;mod_token_&lt;/span&gt; = ...;
                &lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;mode_block_code_&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;mod_token_&lt;/span&gt;);
            },
            &lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;,
            |&lt;span class=&quot;n&quot;&gt;parsed_block&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;
        );
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ParsedCodeBlock&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;mod_block_&lt;/span&gt; =
            &lt;span class=&quot;n&quot;&gt;parsed_block&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;clone&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;=&amp;gt;&lt;span class=&quot;n&quot;&gt;mode_block_code&lt;/span&gt;);
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;blocks_&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;(
            &lt;span class=&quot;n&quot;&gt;ppr_glob&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;blocks&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;code_block_label&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;mod_block_&lt;/span&gt;);
        &lt;span class=&quot;n&quot;&gt;ppr_&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;clone&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;blocks&lt;/span&gt;=&amp;gt;&lt;span class=&quot;n&quot;&gt;blocks_&lt;/span&gt;);
    },
    &lt;span class=&quot;n&quot;&gt;parsed_program&lt;/span&gt;,
    |&lt;span class=&quot;n&quot;&gt;parsed_program&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;blocks-sequence&lt;/span&gt;
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The entire library is only a handful of functions. The naming of the functions is based on Haskell&amp;#39;s, except where Raku already claimed a name as a keyword.&lt;/p&gt;

&lt;h2&gt;Map manipulation&lt;/h2&gt;

&lt;p&gt;Insert, update and remove entries in a Map. Given an existing key, &lt;code&gt;insert&lt;/code&gt; will update the entry.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;m_&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;k_&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;v_&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt; )
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;update&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;m_&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;k_&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;v_&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt; )
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;m_&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;k_&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt; )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;List manipulation&lt;/h2&gt;

&lt;p&gt;There are more list manipulation functions because reductions operate on lists.&lt;/p&gt;

&lt;h3&gt;Add/remove an element at the front:&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# push&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;l_&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;e_&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt;)
&lt;span class=&quot;c1&quot;&gt;# unshift&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prepend&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;l_&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;e_&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Split a list into its first element and the rest:&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# return the first element, like shift&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;l_&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;)
&lt;span class=&quot;c1&quot;&gt;# drops the first element&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;l_&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt;)

&lt;span class=&quot;c1&quot;&gt;# This is like head:tail in Haskell&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;headTail&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;l_&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt;) &lt;span class=&quot;c1&quot;&gt;# List is a tuple (head, tail)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The typical use of &lt;code&gt;headTail&lt;/code&gt; is something like:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; (&lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;leaf&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;leaves_&lt;/span&gt;) = &lt;span class=&quot;n&quot;&gt;headTail&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;leaves&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Similar operations but for the last element:&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# drop the last element&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;init&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;l_&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt;)
&lt;span class=&quot;c1&quot;&gt;# return the last element, like pop.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;l_&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;) ,
&lt;span class=&quot;c1&quot;&gt;# Split the list on the last element&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;initLast&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;l_&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt;) &lt;span class=&quot;c1&quot;&gt;# List is a tuple (init, top)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The typical use of &lt;code&gt;initLast&lt;/code&gt; is something like:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; (&lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;leaves_&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;leaf&lt;/span&gt;) = &lt;span class=&quot;n&quot;&gt;initLast&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;leaves&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
        </content>
    </entry>
    
    <entry>
        <title>Compiling stack-based assembly to C</title>
        <link href="https://wimvanderbauwhede.github.io/articles/uxntal-to-C/"/>
        <updated>2022-10-15T00:00:00+01:00</updated>
        <id>https://wimvanderbauwhede.github.io/articles/uxntal-to-C</id>
        <author>
					<name>Wim Vanderbauwhede</name>
					<uri>https://wimvanderbauwhede.github.io/</uri>
					
				</author>
        <content type="html">
        	&lt;img src=&quot;https://wimvanderbauwhede.github.io/images/uxntal-to-C_1600x600.jpg&quot;&gt;&lt;br/&gt;
        	&lt;p&gt;I wrote a proof-of-concept compiler from &lt;a href=&quot;https://wiki.xxiivv.com/site/uxntal.html&quot;&gt;Uxntal&lt;/a&gt; to &lt;code&gt;C&lt;/code&gt;. The generated code is linked with a slightly modified version of the &lt;a href=&quot;https://git.sr.ht/%7Erabbits/uxn&quot;&gt;Uxn VM/Varvara code&lt;/a&gt; to provide stand-alone applications.&lt;/p&gt;

&lt;h2&gt;Uxntal and Uxn&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://wiki.xxiivv.com/site/uxntal.html&quot;&gt;&lt;code&gt;Uxntal&lt;/code&gt;&lt;/a&gt; is the programming language for the &lt;a href=&quot;https://wiki.xxiivv.com/site/uxn.html&quot;&gt;&lt;code&gt;Uxn&lt;/code&gt;&lt;/a&gt; virtual machine which forms the heart of the &lt;a href=&quot;https://wiki.xxiivv.com/site/varvara.html&quot;&gt;&lt;code&gt;Varvara&lt;/code&gt;&lt;/a&gt; clean-slate computing stack. As Uxn is a stack machine, Uxntal is a stack language, similar to e.g. &lt;a href=&quot;https://forth-standard.org/&quot;&gt;Forth&lt;/a&gt; or &lt;a href=&quot;https://dev.to/palm86/church-encoding-in-the-concatenative-language-joy-3nd8&quot;&gt;Joy&lt;/a&gt; in that it uses reverse Polish notation (postfix). It is an assembly language with opcodes for 8-bit and 16-bit operations on the stack and memory. To get the most out of this article, it is best if you have basic knowledge of Uxntal, either from the above resources or for example &lt;a href=&quot;https://compudanzas.net/uxn_tutorial.html&quot;&gt;the great tutorial at Compudanzas&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;An Uxntal-to-C compiler&lt;/h2&gt;

&lt;p&gt;What I call an Uxntal-to-C compiler is a program that converts an Uxntal program into a C program that, when compiled with a C compiler and executed, has the same functionality as the Uxntal program has when assembled and run on the Uxn emulator. &lt;/p&gt;

&lt;p&gt;Why compile Uxntal to C? Mainly for fun, and out of curiosity. I was curious about the challenges involved and the limitations. Compiling Uxntal programs does result in speed-ups for compute-intensive applications. However, the fact that Uxn is computationally not very efficient is to my mind a bit of a red herring. As the main purpose of Uxn is to create interactive applications, the behaviour of these is dominated by the I/O activity, including the display and audio which are managed by SDL. The effect of the Uxntal code being compiled or interpreted will therefore be small for typical Uxn target, because either the program run time will be dominated by I/O waits or the computations will take place in the SDL layer. And that was another reason behind this experiment: it provides evidence. I verified my assumptions on a number of examples (see below), and the total power saving of the compiled version is negligible.&lt;/p&gt;

&lt;p&gt;I initially considered &lt;a href=&quot;https://llvm.org&quot;&gt;LLVM&lt;/a&gt; and &lt;a href=&quot;https://webassembly.github.io&quot;&gt;WASM&lt;/a&gt; as targets. WASM seems attractive at first because it is purportedly stack based, but it turns out that loops are not stack based, nor is function argument passing. Both WASM and LLVM are typed assembly languages and assume that code and data are in separate memory spaces and that code is read-only, so they offer no additional benefit as a compilation target for Uxntal over C.&lt;/p&gt;

&lt;h2&gt;Limitations&lt;/h2&gt;

&lt;p&gt;There are two aspects of Uxntal that can&amp;#39;t be supported in an ahead-of-time C compiler with static code analysis. &lt;/p&gt;

&lt;h3&gt;Jumps to computed addresses&lt;/h3&gt;

&lt;p&gt;The first is jumps to computed addresses, because that is a concept that is not supported in C (nor in LLVM or WASM). A jump to a constant relative address can be resolved at compile time and supported, but run-time computed jumps have no equivalent. Fortunately, in practice Uxntal&amp;#39;s linter discourages this for jumps longer than one instruction, and the allowed case of a run-time computed binary value is supported.&lt;/p&gt;

&lt;h3&gt;Self-modifiable code&lt;/h3&gt;

&lt;p&gt;The second is self-modifiable code. In C, LLVM and WASM, code and data are separated and a program can&amp;#39;t modify its on source. Fortunately, in practice the use of self-modification in Uxntal is limited to storing of local variables through code such as &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;LIT &amp;amp;x $1 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and evaluation of instructions from the stack using code such as &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;LIT MUL
... 
#00 STR $1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Run-time evaluation through self-modification of the instructions is only supported for a specific case:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;#06 #07 LIT ADD 
...
#00 STR BRK 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In principle, any store of a byte in the code memory results in self-modification, but the above is the most common pattern used to evaluate a byte on the stack as an instruction. &lt;/p&gt;

&lt;p&gt;Also fundamentally, the compiler expects human-readable Uxntal code, in particular it relies on the mnemonics to identify instructions. So while this is valid Uxntal code, it will not work:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;80 06 80 07 1a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It is in general impossible for a compiler to distinguish between opcodes and data because of Uxntal&amp;#39;s dynamic nature. In fact, a value can be used as both depending on a run-time condition. So the compiler needs the meta-information provided by the mnemonic notation.&lt;/p&gt;

&lt;h2&gt;Design&lt;/h2&gt;

&lt;p&gt;The overall approach is to use the runtime data structures used in the Uxn emulator, i.e. arrays that represent the ram, stacks and devices. Rather than reading bytes from the rom file and evaluating them using a case statement, we generate C code with subroutines corresponding to the instructions. The control flow is purely based on subroutine calls.&lt;/p&gt;

&lt;p&gt;The design is quite simple. There is a Token sum type for all token variants and some record types for code blocks and the full program. All of these are in &lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/nito/lib/UxntalTypes.rakumod&quot;&gt;&lt;code&gt;UxntalTypes&lt;/code&gt;&lt;/a&gt;. Definitions of the Uxntal operations are in &lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/nito/lib/UxntalDefs.rakumod&quot;&gt;&lt;code&gt;UxntalDefs&lt;/code&gt;&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;Because of Uxntal&amp;#39;s very regular structure, the &lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/nito/lib/UxntalTokeniser.rakumod&quot;&gt;tokeniser&lt;/a&gt; is trivial (split on whitespace and newlines); the &lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/nito/lib/UxntalParser.rakumod&quot;&gt;parser&lt;/a&gt; is using regular expressions and is also straightforward. Because Uxntal programs are simply sequences of instructions, labels and data of one or two bytes, the parser does need only limited context. We parse the code into a data type that reflects the different types of tokens as described on the &lt;a href=&quot;https://wiki.xxiivv.com/site/uxntal.html&quot;&gt;Uxntal page of the XXIIVV wiki&lt;/a&gt;:&lt;/p&gt;

&lt;table border=&quot;1&quot;&gt;
    &lt;tr&gt;&lt;th colspan=&quot;4&quot;&gt;Padding&lt;/th&gt;&lt;th colspan=&quot;4&quot;&gt;Literals&lt;/th&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;&lt;code&gt;|&lt;/code&gt;&lt;/td&gt;&lt;td&gt;absolute&lt;/td&gt;&lt;td&gt;&lt;code&gt;$&lt;/code&gt;&lt;/td&gt;&lt;td&gt;relative&lt;/td&gt;&lt;td&gt;&lt;code&gt;#&lt;/code&gt;&lt;/td&gt;&lt;td colspan=&quot;3&quot;&gt;literal hex&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;th colspan=&quot;4&quot;&gt;Labels&lt;/th&gt;&lt;th colspan=&quot;4&quot;&gt;Ascii&lt;/th&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;&lt;code&gt;@&lt;/code&gt;&lt;/td&gt;&lt;td&gt;parent&lt;/td&gt;&lt;td&gt;&lt;code&gt;&amp;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;child&lt;/td&gt;&lt;td&gt;&lt;code&gt;&amp;quot;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;raw word&lt;/td&gt;&lt;td&gt;&lt;code&gt;&amp;#39;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;raw char&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;th colspan=&quot;4&quot;&gt;Addressing&lt;/th&gt;&lt;th colspan=&quot;4&quot;&gt;Pre-processor&lt;/th&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;&lt;code&gt;,&lt;/code&gt;&lt;/td&gt;&lt;td&gt;literal relative&lt;/td&gt;&lt;td&gt;.&lt;/td&gt;&lt;td&gt;literal zero-page&lt;/td&gt;&lt;td&gt;&lt;code&gt;%&lt;/code&gt;&lt;/td&gt;&lt;td&gt;macro-define&lt;/td&gt;&lt;td&gt;&lt;code&gt;~&lt;/code&gt;&lt;/td&gt;&lt;td&gt;include&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;&lt;code&gt;:&lt;/code&gt;&lt;/td&gt;&lt;td&gt;raw absolute&lt;/td&gt;&lt;td&gt;&lt;code&gt;;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;literal absolute&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Then we perform two transformation passes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Replace all relative addressing by absolute addressing. &lt;/p&gt;

&lt;p&gt;So after this step, only &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;;&lt;/code&gt; remain. &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Split the code into blocks and identify them as subroutines or data. &lt;/p&gt;

&lt;p&gt;This is only slightly more complex because we need to add an explicit jump to the next block for blocks that do not end in a jump. Blocks that do not contain operations are considered data, all other blocks are subroutines. &lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This transformation allows us to create equivalent C subroutines an  store the data in RAM. There are a few special cases, see the &lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/nito/lib/UxntalParser.rakumod&quot;&gt;&lt;code&gt;UxntalParser&lt;/code&gt;&lt;/a&gt; code for details. &lt;/p&gt;

&lt;p&gt;After this step we &lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/nito/lib/UxntalAnalyser.rakumod&quot;&gt;analyse&lt;/a&gt; the code to determine which labels refer to subroutines and which to data. &lt;/p&gt;

&lt;p&gt;The main advantage of this approach is that it simplifies control flow handling: there is no need for &lt;code&gt;goto&lt;/code&gt; statements or labels because Uxntal&amp;#39;s label-based loops have been turned into recursive subroutines. So all we need to do is generate the code for those subroutines and the code to call them.&lt;/p&gt;

&lt;p&gt;The actual &lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/nito/lib/UxntalStackBasedCEmitter.rakumod&quot;&gt;emitter&lt;/a&gt; is straightforward because it relies on &lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/nito/uxn-runtime-libs/&quot;&gt;a runtime library&lt;/a&gt; which contains a subroutine for every Uxntal instruction. &lt;/p&gt;

&lt;p&gt;In practice there are a few additional complications, specifically to handle the limited use of self-modification, and to handle conditional jumps. Also, the memory allocations and subroutine declarations need to be collected and grouped at the start of the source code, so there is quite a bit of state to be maintained.&lt;/p&gt;

&lt;p&gt;Each instruction subroutine takes the required arguments from the stack and pushes its result on the stack, if any. Consequently, all subroutines have a signature &lt;code&gt;void f(void)&lt;/code&gt;. This means all function pointers are of the same type. Because function pointers in C are machine size, we can&amp;#39;t put them directly on the Uxn stack. Instead, we store them in a separate array and put the index into that array on the stack. &lt;/p&gt;

&lt;p&gt;With this approach, we can handle most of the dynamic nature of Uxntal.&lt;/p&gt;

&lt;h2&gt;Optimisations&lt;/h2&gt;

&lt;h3&gt;Inlining operations&lt;/h3&gt;

&lt;p&gt;The generated C code at this stage has a very large number of subroutine calls, and disappointingly the C compiler (gcc) does not inline most of them. So we do this ourselves in a &lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/nito/lib/UxntalStackBasedCOpsEmitter.rakumod&quot;&gt;first optimisation pass&lt;/a&gt;. This is easy (if cumbersome) because the subroutines don&amp;#39;t take or return arguments and are guaranteed non-recursive, so we can simply replace the call with the definition.&lt;/p&gt;

&lt;h3&gt;Stack to register&lt;/h3&gt;

&lt;p&gt;A &lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/nito/lib/UxntalStackBasedCOpsEmitter.rakumod&quot;&gt;second optimisation&lt;/a&gt; is more complicated but has also a much bigger effect on performance: we replace as much as possible stack operations with register operations. This is a little bit more complicated than at first sight appears. I might write a separate post about the algorithm.&lt;/p&gt;

&lt;h3&gt;Further optimisations&lt;/h3&gt;

&lt;p&gt;There are a number of further optimisations that could be considered, but all of them are more complex and would not result in a dramatic additional performance improvement. Some of them I have implemented but they are not enabled:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/nito/lib/UxntalInliner.rakumod&quot;&gt;Inline subroutines&lt;/a&gt;. This is only partially implemented. It is rather tricky because recursive subroutines can&amp;#39;t be inlined, so we need an analysis to detect recursion. For simple, in-routine recursion that is easy, but recursion can occur through a chain of tail calls, so we need to identify tail calls and follow those through. &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Use &lt;code&gt;goto&lt;/code&gt; instead of function call. This is a simple optimisation which does not require a separate pass so it&amp;#39;s done directly in the &lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/nito/lib/UxntalStackBasedCEmitter.rakumod&quot;&gt;emitter&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Both of these optimisations make little or no difference for most applications I tested so I don&amp;#39;t enable them. Some other optimisations I have not finished implementing:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Stack to register for subroutine calls. This is quite complicated, mostly because of recursion, but also because it is (in general) not possible to infer the type of a function called via a function pointers. &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Stack to register for conditional blocks. This is the case where a condition is created through a computed jump, a typical example would be&lt;/p&gt;

&lt;p&gt;... EQU JMP [ INC2 ] ...&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So if &lt;code&gt;EQU&lt;/code&gt; returns 0, &lt;code&gt;ADD2&lt;/code&gt; will be executed, else it will be jumped over. The instruction has to be idempotent, and I think most commonly this is used with &lt;code&gt;JMP2r&lt;/code&gt;. The effect on performance will generally be minimal.&lt;/p&gt;

&lt;h2&gt;Performance&lt;/h2&gt;

&lt;h3&gt;Code used for testing&lt;/h3&gt;

&lt;p&gt;I did some limited performance evaluation using five command-line programs: three versions of &lt;code&gt;fib*&lt;/code&gt;, &lt;code&gt;primes&lt;/code&gt;, and &lt;code&gt;stencil&lt;/code&gt;. With &lt;code&gt;-O=2&lt;/code&gt; (inlined ops and stack-to-reg), the compiled version is up to 12x faster than the original version. With the additional optimisations this might increase a bit, maybe to     15x, but not more. &lt;/p&gt;

&lt;p&gt;The three version of the Fibonacci calculation are a modified version of &lt;a href=&quot;https://git.sr.ht/%7Erabbits/uxn/tree/main/item/projects/examples/exercises/fib.tal&quot;&gt;&lt;code&gt;uxn/projects/examples/exercises/fib.tal&lt;/code&gt;&lt;/a&gt; and the two versions used in &lt;a href=&quot;https://applied-langua.ge/posts/i-dont-want-to-go-to-chel-c.html&quot;&gt;an article&lt;/a&gt; that criticised Uxn for being inefficient. &lt;/p&gt;

&lt;p&gt;The original &lt;a href=&quot;https://git.sr.ht/%7Erabbits/uxn/tree/main/item/projects/examples/exercises/fib.tal&quot;&gt;&lt;code&gt;fib.tal&lt;/code&gt;&lt;/a&gt; is very terse (ignoring the &lt;code&gt;print&lt;/code&gt; function):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;|0100 ( -&amp;gt; ) @reset

    #0000 INC2k ADD2k
    &amp;amp;loop
        ( print ) DUP2 ,print JSR
        ( linebreak ) #0a18 DEO
        ADD2k LTH2k ,&amp;amp;loop JCN
    ( halt ) #010f DEO

BRK
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I &lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/nito/src/branch/main/demos/fib.tal&quot;&gt;modified it&lt;/a&gt; by writing a loop around it to repeat the calculations 2^16 times:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;#ffff #0000 &amp;amp;iterate
...
INC2 GTH2k ,&amp;amp;iterate JCN
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What I call &lt;code&gt;fib2.tal&lt;/code&gt; is taken from the article:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;|0100

#0020 ;fib JSR2
#01 #0f DEO BRK

@fib ( N -- fib[N] )
    DUP2 #0001 GTH2 ,&amp;amp;inductive-case; JCN JMP2r
    &amp;amp;inductive-case;
    DUP2 #0001 SUB2 ;fib JSR2 ( stack now N fib[N-1] )
    SWP2 #0002 SUB2 ;fib JSR2 ( stack now fib[N-1] fib[N-2] )
    ADD2 JMP2r
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And &lt;code&gt;fib32.tal&lt;/code&gt; is a 32-bit version of this code, also from that article:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;|0100

#0020 ;fib JSR2
#01 #0f DEO BRK

@fib ( N -- fib[N] )
( not[n &amp;lt; 2] equivalent to n &amp;gt; 1 )
    DUP2 #0001 GTH2 ,&amp;amp;inductive-case; JCN #0000 SWP JMP2r
    &amp;amp;inductive-case;
    DUP2 #0001 SUB2 ;fib JSR2 ( stack now N fib[N-1] )
    ROT2 #0002 SUB2 ;fib JSR2 ( stack now fib[N-1] fib[N-2] )
    ;add32 JSR2 JMP2r
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This uses the &lt;a href=&quot;http://plastic-idolatry.com/erik/nxu/math32.tal&quot;&gt;32-bit math library&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I also tested &lt;a href=&quot;https://git.sr.ht/%7Erabbits/uxn/tree/main/item/projects/examples/exercises/primes.tal&quot;&gt;&lt;code&gt;uxn/projects/examples/exercises/primes.tal&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;|0100 ( -&amp;gt; ) @reset

    #0000 INC2k
    &amp;amp;loop
        DUP2 ,is-prime JSR #00 EQU ,&amp;amp;skip JCN
            DUP2 DUP2 ;mem STA2
            ,print/short JSR
            ( space ) #2018 DEO
            &amp;amp;skip
        INC2 NEQ2k ,&amp;amp;loop JCN
    POP2 POP2
    ;mem LDA2 ,print/short JSR
    ( halt ) #010f DEO

BRK

@is-prime   
    DUP2
    #0001 EQU2 ,&amp;amp;fail JCN
    STH2k
    #01 SFT2 #0002
    &amp;amp;loop
        STH2kr OVR2 ( mod2 ) [ DIV2k MUL2 SUB2 ] ORA ,&amp;amp;continue JCN
            POP2 POP2 POP2r #00 JMP2r
            &amp;amp;continue
        INC2  GTH2k ,&amp;amp;loop JCN
    POP2 POP2 POP2r #01
JMP2r
    &amp;amp;fail POP2 #00 JMP2r
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Finally, I wrote &lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/nito/src/branch/main/demos/stencil.tal&quot;&gt;&lt;code&gt;stencil.tal&lt;/code&gt;&lt;/a&gt;, which is a 3-D 6-point stencil code, so the value of each point in a 3-D space is calculated based on the values of its six neighbours (i+1,i-1),(j+1,j-1),(k+1,k-1). This is a very common pattern in scientific computing and a good number crunching test. The code is a bit long to list here. It is a quadruple-nested loop: a time loop containing loops over the x, y and z directions of the 3-D space. At each point, the calculation is simply the weighted average of the current value and the sum of the six neighbours:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;.idx LDZ2 #0001 ADD2 LDA2 ( p(x-1,y,z) )
.idx LDZ2 #0001 SUB2 LDA2 ( p(x+1,y,z) )
ADD2
.idx LDZ2 #0010 ADD2 LDA2 ( p(x,y-1,z) )
.idx LDZ2 #0010 SUB2 LDA2 ( p(x,y+1,z) )
ADD2
ADD2
.idx LDZ2 #0100 ADD2 LDA2 ( p(x,y,z-1) )
.idx LDZ2 #0100 SUB2 LDA2 ( p(x,y,z+1) )
ADD2 
ADD2
#0003 MUL2 

.idx LDZ2 LDA2 ( p(x,y,z) ) 
ADD2
#0004 DIV2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The time loop repeats this calculation 2^16 times. &lt;/p&gt;

&lt;h3&gt;Performance results&lt;/h3&gt;

&lt;p&gt;I compiled these example with as optimisations inlining of operations and stack-to-register transformation. I used &lt;code&gt;time&lt;/code&gt; to obtain the timings.&lt;/p&gt;

&lt;table&gt;
    &lt;tr&gt;&lt;th&gt;Code&lt;/th&gt;&lt;th&gt;Emulated (s)&lt;/th&gt;&lt;th&gt;Compiled (s)&lt;/th&gt;&lt;th&gt;Speed-up&lt;/th&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;&lt;code&gt;fib.tal&lt;/code&gt;&lt;/td&gt;&lt;td&gt;1.57&lt;/td&gt;&lt;td&gt;0.96&lt;/td&gt;&lt;td&gt;1.6x&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;&lt;code&gt;fib2.tal&lt;/code&gt;&lt;/td&gt;&lt;td&gt;0.471&lt;/td&gt;&lt;td&gt;0.047&lt;/td&gt;&lt;td&gt;10x&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;&lt;code&gt;fib32.tal&lt;/code&gt;&lt;/td&gt;&lt;td&gt;1.86&lt;/td&gt;&lt;td&gt;0.151&lt;/td&gt;&lt;td&gt;12.3x&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;&lt;code&gt;primes.tal&lt;/code&gt;&lt;/td&gt;&lt;td&gt;6.9&lt;/td&gt;&lt;td&gt;0.93&lt;/td&gt;&lt;td&gt;7.4x&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;&lt;code&gt;stencil.tal&lt;/code&gt;&lt;/td&gt;&lt;td&gt;96.9&lt;/td&gt;&lt;td&gt;7.8&lt;/td&gt;&lt;td&gt;12.4x&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;For the examples with low speed-ups, the reason is that a lot of the time spend is I/O activity, which takes the same amount of time for the emulated and compiled versions:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;$ time uxncli fib.rom &amp;gt;/dev/null
real    0m1.568s
user    0m0.924s
sys 0m0.644s

$ time uxncliprog &amp;gt;/dev/null
real    0m0.964s
user    0m0.384s
sys 0m0.580s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Even if we print to &lt;code&gt;/dev/null&lt;/code&gt;, that still takes considerable I/O time.&lt;/p&gt;

&lt;p&gt;For the tests without I/O (fib2, fib32, stencil), the speed-up is between 10x and 12.4x. I think with the additional optimisations, it might increase to maybe 15x but not more than that.&lt;/p&gt;

&lt;h2&gt;Power consumption&lt;/h2&gt;

&lt;p&gt;Finally, I had a look at the power consumption of a typical GUI-based Uxn app. I used powertop with the &lt;a href=&quot;https://git.sr.ht/%7Erabbits/uxn/tree/main/item/projects/examples/demos/bunnymark.tal&quot;&gt;&lt;code&gt;bunnymark&lt;/code&gt;&lt;/a&gt; benchmark, running 10,000 rabbits. I used &lt;code&gt;htop&lt;/code&gt; for the CPU utilsation. &lt;/p&gt;

&lt;p&gt;My laptop is nearly three years old, it is a &lt;a href=&quot;https://www.pcspecialist.co.uk&quot;&gt;PCSpecialist&lt;/a&gt; Fusion IV, which is really a &lt;a href=&quot;http://www.hk.tongfangpc.com/&quot;&gt;TongFang&lt;/a&gt; PF4MN2F. The CPU is an Intel Core i7-10510U 1.80GHz and it has 16GB DDR4 memory. &lt;/p&gt;

&lt;h3&gt;Baseline&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;System baseline power is estimated at 766 mW

Power est.    Usage     Device name
564 mW      3.1%        DRAM
157 mW      3.1%        CPU core
44.9 mW      3.1%        CPU misc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Emulated&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;15% CPU

System baseline power is estimated at 7.98 W

Power est.    Usage     Device name
5.03 W     57.7%        CPU core
1.43 W     57.7%        CPU misc
1.02 W     57.7%        DRAM
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Compiled&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;9% CPU

System baseline power is estimated at 8.17 W

Power est.    Usage     Device name
5.09 W     55.4%        CPU core
1.59 W     55.4%        CPU misc
978 mW     55.4%        DRAM    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What we see is that most of the power is drawn by the CPU and that there is effectively no difference between the emulated and compiled versions. I measured this a few times and the error margin is about 0.5 W so within that margin the results are identical. I also measured the power consumption for emulated and compiled versions of other applications in the &lt;a href=&quot;https://git.sr.ht/%7Erabbits/uxn/tree/main/item/projects/examples/demos&quot;&gt;&lt;code&gt;demos&lt;/code&gt;&lt;/a&gt; folder. They all consume considerably less power than bunnymark but there was no significant difference between emulated and compiled versions.&lt;/p&gt;

&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;The main takeaway of this experiment of compiling Uxntal to C is that it provides evidence that there is no need to do this for most Uxn applications: it will have no significant effect on performance or power consumption.&lt;/p&gt;

&lt;p&gt;On the other hand, if you have to or want to you now can compile Uxntal to C and it can give speed-ups of the order of 10x for compute-heavy applications.&lt;/p&gt;

&lt;h2&gt;Code&lt;/h2&gt;

&lt;p&gt;The compiler code and demos can be found &lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/nito&quot;&gt;in my &lt;code&gt;nito&lt;/code&gt; repo on Codeberg&lt;/a&gt;. The README has the instructions and a list of the code on which I tested the compiler.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The banner picture shows a row of bronze prayer wheels in a temple in Kyoto at night.&lt;/em&gt; &lt;/p&gt;

        </content>
    </entry>
    
    <entry>
        <title>Functional programming in stack-based assembly</title>
        <link href="https://wimvanderbauwhede.github.io/articles/uxntal-quoting/"/>
        <updated>2022-10-09T00:00:00+01:00</updated>
        <id>https://wimvanderbauwhede.github.io/articles/uxntal-quoting</id>
        <author>
					<name>Wim Vanderbauwhede</name>
					<uri>https://wimvanderbauwhede.github.io/</uri>
					
				</author>
        <content type="html">
        	&lt;img src=&quot;https://wimvanderbauwhede.github.io/images/uxntal-quoting_1600x600.jpg&quot;&gt;&lt;br/&gt;
        	&lt;h2&gt;Quoting in Uxntal: lambda functions, tuples and lists for free&lt;/h2&gt;

&lt;p&gt;What does it take to bring functional programming to a stack-based assembly language? &lt;em&gt;tl;dr&lt;/em&gt;: not all that much. Uxntal has everything it takes to build a basic mechanism (&amp;quot;quoting&amp;quot;) that lets us create lambda functions, tuples, cons lists and more.&lt;/p&gt;

&lt;h2&gt;Uxntal and Uxn&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://wiki.xxiivv.com/site/uxntal.html&quot;&gt;&lt;code&gt;Uxntal&lt;/code&gt;&lt;/a&gt; is the programming language for the &lt;a href=&quot;https://wiki.xxiivv.com/site/uxn.html&quot;&gt;&lt;code&gt;Uxn&lt;/code&gt;&lt;/a&gt; virtual machine. As Uxn is a stack machine, Uxntal is a stack language, similar to e.g. &lt;a href=&quot;https://forth-standard.org/&quot;&gt;Forth&lt;/a&gt; or &lt;a href=&quot;https://dev.to/palm86/church-encoding-in-the-concatenative-language-joy-3nd8&quot;&gt;Joy&lt;/a&gt; in that it uses reverse Polish notation (postfix). It is an assembly language with opcodes for 8-bit and 16-bit operations on the stack and memory. To get the most out of this article, it is best if you have basic knowledge of Uxntal, either from the above resources or for example &lt;a href=&quot;https://compudanzas.net/uxn_tutorial.html&quot;&gt;the great tutorial at Compudanzas&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Concepts such as lambda functions, quoting, partial application and closures are common in functional programming languages, but if you are not familiar with these you should still be able to follow most of the explanation. My article &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/decluttering-with-functional-programming/&quot;&gt;&amp;quot;Cleaner code with functional programming&amp;quot;&lt;/a&gt;, explains the basics of functional programming.&lt;/p&gt;

&lt;p&gt;Although Uxn is a stack machine and Uxntal a stack language, it is quite easy to do register based programming by using labels as variables: the purely stack based&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;|0100
#06 #07 MUL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;can be written as&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;|0000
@r1 $1 @r2 $1 @r3 $1
|0100
#06 .r1 STZ
#07 .r2 STZ
.r1 LDZ .r2 LDZ MUL .r3 STZ
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where we store the values in memory and load them when needed. My implementation of lambda functions makes use of this approach.&lt;/p&gt;

&lt;p&gt;Uxntal also has a simple but powerful macro mechanism which just creates short names for groups of tokens. I make heavy use of macros in what follows.&lt;/p&gt;

&lt;p&gt;Because of the conciseness of its syntax, I use the venerable functional language &lt;a href=&quot;https://haskell.org/&quot;&gt;Haskell&lt;/a&gt; for some of the examples below. A short primer on Haskell is my article &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/everything-is-a-function/&quot;&gt;&amp;quot;Everything is a function&amp;quot;&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Anonymous functions&lt;/h2&gt;

&lt;p&gt;Uxntal supports variables and named function calls through labels. And as the program is stored in writeable memory, it can be overwritten or modified in place.&lt;/p&gt;

&lt;p&gt;I wanted to see if I could implement or emulate the behaviour of anonymous functions (called &amp;quot;lambda functions&amp;quot; in functional programming). For example, I&amp;#39;d like to be able to write something similar to the following Haskell code:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;or equivalent in Python:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which would square all elements in the list &lt;code&gt;lst&lt;/code&gt;. And I would like to be able to use lambda functions as arguments and as return values:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I also want to be able to combine lambdas and named functions:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sq&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The reason I want to do this is mostly curiosity, but there are some practical advantages because the lambda functions can be generated dynamically based on runtime values. Also, the &amp;quot;quoting&amp;quot; mechanism used to build lambdas is more general and allows for &amp;quot;lazy&amp;quot; or delayed evaluation.&lt;/p&gt;

&lt;p&gt;From the above examples, the clear feature of a lambda function is that it identifies by name the variables used as its arguments. I want to reflect this closely in Uxntal. The other key feature is that the lambda functions are values, and we need to apply them to an argument to get a computation. That is very similar to calling a function in Uxntal. Suppose we have&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;|0100
#0003 #0004 ;f JSR2
BRK
@f
    .x STZ2
    .y STZ2
    .x LDZ2 .x LDZ2 MUL2 .y LDZ2 .y LDZ2 MUL2 ADD2
    .x LDZ2 .y LDZ2 MUL2 #0002 MUL2 ADD2
    JMP2r
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using some macros I have defined for convenience, I can write this as&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;|0100
3 4 ;f call
BRK
@f
    -&amp;gt;x
    -&amp;gt;y
    x x * y y * +
    x y * 2 * +
    return
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With a lambda notation, this would become&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;|0100
3 4  [&amp;#39; \x. \y.
        x&amp;#39; x&amp;#39; *&amp;#39; y&amp;#39; y&amp;#39; *&amp;#39; +&amp;#39;
        x&amp;#39; y&amp;#39; *&amp;#39; 2&amp;#39; *&amp;#39; +&amp;#39;
    ]&amp;#39; apply
BRK
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The nested example &lt;code&gt;(\x -&amp;gt; (\y -&amp;gt; x+y)) 2 3&lt;/code&gt; would be with named functions:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;|0100
3 2 ;f call
BRK
@f
    -&amp;gt;x
    ;g call
    return
@g
    -&amp;gt;y
    x y +
    return
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and with lambdas&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;|0100
3 2 [&amp;#39; \x.
        [&amp;#39; \y.
            x&amp;#39; y&amp;#39; +&amp;#39;
        ]&amp;#39;
    ]&amp;#39; apply
    apply
BRK
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In other words, the function is defined inside the quoted brackets and called using &lt;code&gt;apply&lt;/code&gt; rather than &lt;code&gt;call&lt;/code&gt;.&lt;/p&gt;

&lt;h2&gt;Implementation&lt;/h2&gt;

&lt;p&gt;So how do we do this? There are several components than need to be brought together to have named variables, nesting, and functions as values.&lt;/p&gt;

&lt;h3&gt;Uxntal quoting and unquoting&lt;/h3&gt;

&lt;h4&gt;Quoting&lt;/h4&gt;

&lt;p&gt;First of all, we need some mechanism to defer evaluation of an operation, which I call &amp;quot;quoting&amp;quot; for short.
Luckily, Uxntal has the essential feature: it is possible to quote an operation and unquote it later. For example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;#06 #07 ADD
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;would immediately compute 6*7; but if we write&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;#06 #07 LIT ADD
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;then we have the ADD operation as a symbol on the stack. This is what I call &amp;quot;quoting&amp;quot; for opcodes.&lt;/p&gt;

&lt;h4&gt;Unquoting through self-modification&lt;/h4&gt;

&lt;p&gt;To unquote the symbol and so evaluate the expression, we can do&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;#00 STR $1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which is a bit of Uxn magic: it is a relative store with a relative address of 0, and effectively it takes the symbol from the stack and puts it as the next instruction to be executed. The &lt;code&gt;$1&lt;/code&gt; is just a placeholder on the stack to create the space for the store. So the following would calculate &lt;code&gt;6*7&lt;/code&gt; and print out &lt;code&gt;*&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;|0100
    #06 #07 LIT ADD
    #00 STR $1
    #18 DEO ( prints the character to stdout )
BRK
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There isn&amp;#39;t really anything magical going on here: an equivalent program would be&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;|0100
    #06 #07 LIT ADD
    ;eval STA @eval $1
    #18 DEO ( prints the character to stdout )
BRK
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;or even&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;|0100
    #06 #07 LIT ADD
    ;eval STA ;eval JSR2
    #18 DEO ( prints the character to stdout )
BRK

@eval $1
JMP2r
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The key mechanism is that Uxntal allows to overwrite the program code, so the &lt;code&gt;$1&lt;/code&gt; placeholder can at runtim be replaced by any byte, and all bytes are valid instructions.&lt;/p&gt;

&lt;h4&gt;Unquoting without self-modification&lt;/h4&gt;

&lt;p&gt;Even if Uxntal did not have modifiable code, we could still quote and unquote. After all, e.g. &lt;code&gt;LIT MUL&lt;/code&gt; is exactly the same as &lt;code&gt;LIT 1a&lt;/code&gt; or &lt;code&gt;#1a&lt;/code&gt; so we can always put opcodes on the stack, they are just bytes. And to unquote them, we could use conditional jumps, for example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;#06 #07 LIT MUL
( opcode on the stack )
#1a EQU ,&amp;amp;eval-mul JCN
...
&amp;amp;eval-mul
MUL
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So the self-modification is purely a more efficient way of unquoting.&lt;/p&gt;

&lt;h3&gt;Kinds of symbols&lt;/h3&gt;

&lt;p&gt;Apart from the opcodes, there are several other types of symbols we need to be able to quote and unquote: variables, constants and function calls.&lt;/p&gt;

&lt;p&gt;For the variables, we need to handle declaration and use: the declaration results in the argument being stored at the location referenced by the variable, and the use results in the value stored at the referenced location being read. I store the variables in the zero-page memory:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;@x $2 @y $2 @z $2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The declaration macro &lt;code&gt;\x.&lt;/code&gt; should when unquoted result in&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;.x STZ2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using a variable macro &lt;code&gt;x&amp;#39;&lt;/code&gt; should when unquoted result in&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;.x LDZ2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Unquoting a constant simply means putting it on the stack.&lt;/p&gt;

&lt;p&gt;Finally, named function call should when unquoted result in&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;;f JSR2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Grouping symbols&lt;/h3&gt;

&lt;p&gt;As we want to be able to nest lambdas, we need some delimiters to group the quoted symbols. That is what the &lt;code&gt;[&amp;#39;&lt;/code&gt; and &lt;code&gt;]&amp;#39;&lt;/code&gt; bracket macros do.  A quoted sequence returns its address onto the working stack. In this way we can pass lambdas around as values.&lt;/p&gt;

&lt;h3&gt;Building the lambda&lt;/h3&gt;

&lt;p&gt;To build the lambda function, I need to store the quoted symbols. Crucially, I need to be able to identify the kind of each symbol. I encode each symbol using three bytes, the third byte is a label to identify the kind of symbol. The opening and closing brackets are also labelled and stored in this way. The opening bracket symbol contains the size of the lambda; the closing bracket is only there as a jump target. For example,&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;[&amp;#39; \x. x&amp;#39; 1&amp;#39; +&amp;#39; ;f call&amp;#39; ]&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is encoded as&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;Value   Label
------  ------
00 07   LAMBDA
.x __  BIND
.x __  ARG
00 01   CONST
ADD __  OPCODE
;f      CALL
__ __   END
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;__&lt;/code&gt; are unused slots because for simplicity I have currently made all symbols the same size (this will probably change as I don&amp;#39;t like inefficiency). For an 8-bit version, it would be possible to encode everything in two bytes.&lt;/p&gt;

&lt;p&gt;Each quoting operation is implemented as a function and those functions keep track of where to write the symbols in memory. The memory for the lambdas starts from &lt;code&gt;|0100&lt;/code&gt;, so I effectively overwrite the program. This is OK because the lambda definition in the program takes up more space than the encoding of the lambda, so there is no risk of overwriting named functions.&lt;/p&gt;

&lt;h3&gt;The lambda stack&lt;/h3&gt;

&lt;p&gt;Because I want to be able to nest lambdas, I need a stack. I could abuse the return stack for this purpose, but I don&amp;#39;t think using either of the Uxn stacks for persistent state is a good idea. So I build a stack in the second half of the zero-page memory. This stack stores tuples of the starting address and the size (in 3-byte words) of each lambda. Each quoting operation manipulates that stack to create the memory encoding for each lambda.&lt;/p&gt;

&lt;h3&gt;Applying the lambda&lt;/h3&gt;

&lt;p&gt;The unquoting operation (the &lt;code&gt;apply&lt;/code&gt; call) uses the same lambda stack. It takes the address of the lambda as argument, and loops over all symbols in the stored representation. The interesting case is that of nested lambdas: when the symbol represents an opening bracket, the evaluator puts the address of the nested lambda on the stack and jumps to the closing bracket, which acts as a no-op. For non-nested lambdas, the closing bracket returns the lambda&amp;#39;s address. In this way I can evaluate nested lambdas as part of an &lt;code&gt;apply&lt;/code&gt; call, and I can also return lambdas.&lt;/p&gt;

&lt;h2&gt;More uses of quoting&lt;/h2&gt;

&lt;p&gt;The quoting mechanism can be used for other purposes than creating lambda functions. Or to look at it another way, lambda functions that take no arguments (&amp;quot;blocks&amp;quot;) are valid:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;[&amp;#39; ;f call&amp;#39; ]&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This gives us an option to have deferred calls.&lt;/p&gt;

&lt;h3&gt;A lazy &lt;code&gt;if&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Lazy means here that we will only evaluate the true or false branch after evaluating the condition, instead of evaluating both and returning the result based on the condition. We can create a &lt;code&gt;lazy-if&lt;/code&gt; function using quoting as follows:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;[&amp;#39; &amp;lt;false-expr&amp;gt;&amp;#39; ]&amp;#39; [&amp;#39; &amp;lt;true-expr&amp;gt;&amp;#39; ]&amp;#39; &amp;lt;cond&amp;gt;  ;lazy-if call
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;lazy-if&lt;/code&gt; function is quite simple:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;@lazy-if
    ,&amp;amp;if-true JCN
    ( if-false )
    POP2 apply-tc
    &amp;amp;if-true
    NIP2 apply-tc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, &lt;code&gt;apply-tc&lt;/code&gt; is a tail call version of &lt;code&gt;apply&lt;/code&gt;, so equivalent to &lt;code&gt;apply return&lt;/code&gt;. We could of course create a &lt;code&gt;case&lt;/code&gt; expression in this way too.&lt;/p&gt;

&lt;h3&gt;Tuples&lt;/h3&gt;

&lt;p&gt;The quoting mechanism can also be used to create immutable lists, or actually tuples (a tuple is a generalisation of a pair, can have any number of values of any type but can&amp;#39;t be modified):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;[&amp;#39; 2 4 + \&amp;#39; 3 5 + \&amp;#39; ]&amp;#39; ( a tuple (6,8) )
[&amp;#39; 1 2 + \&amp;#39; 4 \&amp;#39; ]&amp;#39;  ( a tuple (3,4) )
SWP2
apply * apply * / ( 4 )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this example, &lt;code&gt;[&amp;#39; ... ]&amp;#39;&lt;/code&gt; first creates two tuples and stores it somewhere;
then &lt;code&gt;apply&lt;/code&gt; puts the values on the stack. It would be quite easy to write an indexing function to access element by index.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;[&amp;#39; 2 4 + \&amp;#39; 3 5 + \&amp;#39; ]&amp;#39;  ( creates (6,8) )
[&amp;#39; 1 2 + \&amp;#39; 4 2 /  2&amp;#39; ]&amp;#39;  ( creates (3,2,2) )
SWP2
apply * ( 6*8 )
SWP2
apply [ * * ]  ( 3*2*2 )
/ ( 48/12 )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Another example to illustrate the functions to work on tuples:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;[&amp;#39; [ 1 2 + ] \&amp;#39; [ 3 4 * ] \&amp;#39; 5&amp;#39; ]&amp;#39; -&amp;gt;l ( store the tuple in l )
l fst  print16-nl ( first element )
l snd print16-nl ( second element )
l 2 at print16-nl ( at takes the index (base 0) and returns the element )
[  + + ] POP2
l empty print8-nl ( test if the tuple is empty, returns #00 here )
[&amp;#39; ]&amp;#39; empty print8-nl ( test if the tuple is empty, returns #01 here )
l size print16-nl ( returns the number of elements in the tuple, i.e. 3 )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Because Uxntal is not statically typed, there is no difference between immutable lists and tuples.&lt;/p&gt;

&lt;h3&gt;Cons lists&lt;/h3&gt;

&lt;p&gt;What I call a &amp;quot;cons list&amp;quot; is a list constructed starting from an empty list by adding a single element. The function to construct such a list is typically called &lt;code&gt;cons&lt;/code&gt; in functional programming languages, and in Haskell it has a corresponding operator &lt;code&gt;:&lt;/code&gt;. So the list&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;[ 1 2 3 4 ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is really syntactic sugar for&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;1:2:3:4:()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which is a shorter notation for&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;(cons 1 (cons 2 (cons 3 (cons 4 ()))))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can use the tuples in combination with a &lt;code&gt;cons&lt;/code&gt; function in Uxntal to create cons lists:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;[&amp;#39; ]&amp;#39; 7 cons 6 cons 5 cons ( [ 5 6 7 ] )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There are a few functions to manipulate such lists, the most common ones are &lt;code&gt;head&lt;/code&gt; which returns the first element and &lt;code&gt;tail&lt;/code&gt; which returns the rest of the list (&lt;code&gt;car&lt;/code&gt; and &lt;code&gt;cdr&lt;/code&gt; in Scheme).&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;[&amp;#39; ]&amp;#39; 7 cons 6 cons 5 cons -&amp;gt;l ( (5:6:(7:[])) )
l tail tail head ( )
l tail head
*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There is of course also a &lt;code&gt;length&lt;/code&gt; function, and a function &lt;code&gt;null&lt;/code&gt; to check if the list is empty:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;[&amp;#39; ]&amp;#39; 7 cons 6 cons 5 cons -&amp;gt;l ( (5:6:(7:[])) )
l 4 cons length ( 4 )
l tail tail tail null  ( #01 )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Partial application and closures&lt;/h3&gt;

&lt;p&gt;The nested lambdas allow partial application:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;5 [&amp;#39; \x.  [&amp;#39; \y. x&amp;#39; y&amp;#39; +&amp;#39; ]&amp;#39;  ]&amp;#39; lambda-call
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This means that we don&amp;#39;t have to provide values for all arguments, and what we return is a function that has been specialised with the arguments that have been provided. In the example, we will effective obtain a function that will calculate &lt;code&gt;y+5&lt;/code&gt;. This is a technique that can be used to generate specialised functions from a template.&lt;/p&gt;

&lt;p&gt;This looks a lot like a proper &lt;a href=&quot;https://en.wikipedia.org/wiki/Closure_(computer_programming)&quot;&gt;closure&lt;/a&gt; but while it seems to work, the value is not really captured. We simply store 5 in &lt;code&gt;@x&lt;/code&gt;; if I modify &lt;code&gt;x&lt;/code&gt; between the lambda calls, it will use the modified value. With a proper closure, once it has been created, it does not matter that the original value gets modified. This is not the case in my approach because x and y are globals, not locals. It is possible to address this but it would be very expensive:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;In &lt;code&gt;\x.&lt;/code&gt;, we store the address of &lt;code&gt;.x&lt;/code&gt; somewhere;&lt;/li&gt;
&lt;li&gt;Then we check the entire downstream lambda definition for occurrences of that address;&lt;/li&gt;
&lt;li&gt;We need to take into account that any further occurrence of &lt;code&gt;\x.&lt;/code&gt; resets this;&lt;/li&gt;
&lt;li&gt;Then we could replace &lt;code&gt;.x LIT LDZ2 OPCODE&amp;#39;&lt;/code&gt; with &lt;code&gt;.x LDZ2 CONST&amp;#39;&lt;/code&gt;, so the value would become embedded in the lambda.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you want to address this issue, please let me know.&lt;/p&gt;

&lt;h3&gt;Desugaring&lt;/h3&gt;

&lt;p&gt;For example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;5 \[ \x. x&amp;#39; x&amp;#39; *&amp;#39; \[ \y. y&amp;#39; 1&amp;#39; +&amp;#39; \] lambda-call&amp;#39; \] lambda-call ( returns #001a )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;\[&lt;/code&gt; ... &lt;code&gt;\]&lt;/code&gt; brackets indicate the start and end of a quoting region. Within a quoting region, all quote symbols make up the anonymous function. I use macros to make it a bit nicer. Desugaring the example one layer, we get the following:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;#0033
[&amp;#39;
    .x bind&amp;#39;
    .x arg&amp;#39;
    .x arg&amp;#39;
    LIT MUL2 opcode&amp;#39;
    [&amp;#39;
        .y bind&amp;#39;
        .y arg&amp;#39;
        #0001 const&amp;#39;
        LIT ADD2 opcode&amp;#39;
    ]&amp;#39;
    ;lambda-call call&amp;#39;
]&amp;#39;
;lambda-call call
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Although it may seem at first sight that a stack-based assembly language is quite far removed from a high-level functional language, in Uxntal we can implement many fundamental functional programming concepts such as lambdas, lazy conditionals, tuples and lists and concepts such as partial application and closures, simply by introducing the concept of quoting and unquoting symbols. Uxntal&amp;#39;s simple macro mechanism provides sufficient abstraction to create readable functional programs.&lt;/p&gt;

&lt;h2&gt;Code&lt;/h2&gt;

&lt;p&gt;The code implementing the constructs described in this article is available &lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/hyakuwa/src/branch/main/quoting-lambdas&quot;&gt;in my &lt;code&gt;hyakuwa&lt;/code&gt; repo on Codeberg&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;8-bit vs 16-bit&lt;/h3&gt;

&lt;p&gt;By default, my implementation uses 16-bit words as values. It is possible to use 8-bit constants, arguments and operations. The macro files  &lt;code&gt;quote-lambda_macros_8bit.tal&lt;/code&gt; and &lt;code&gt;lambda_decls_8bit.tal&lt;/code&gt; have the appropriate definitions, or with less sugar you can use &lt;code&gt;bind8&amp;#39;&lt;/code&gt;,&lt;code&gt;arg8&amp;#39;&lt;/code&gt; and &lt;code&gt;const8&amp;#39;&lt;/code&gt;.&lt;/p&gt;

&lt;h2&gt;What&amp;#39;s next?&lt;/h2&gt;

&lt;p&gt;As is the nature of such projects, there is always a lot more that could be done. There are two main drawbacks to the current approach: the macro mechanism is not expressive enough and the computational overhead is very high.&lt;/p&gt;

&lt;p&gt;To address the former we could create a custom assembler, which effectively means we have a new functional language that assembles into Uxntal, either source or rom. If we did that, we could write&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;5 \[ \x. x&amp;#39; x&amp;#39; *&amp;#39; \[ \y. y&amp;#39; 1&amp;#39; +&amp;#39; \] lambda-call&amp;#39; \] lambda-call
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;as, for example,&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;5 (\x -&amp;gt; x x * (\y -&amp;gt; y 1 +))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This would be a lot more readable and it would also allow to tailor the memory allocation for variables.&lt;/p&gt;

&lt;p&gt;We can&amp;#39;t fundamentally address the computational overhead. It can definitely be reduced as the current implementation is not optimised. But effectively, the quoting mechanism is a kind of interpreter, so it always incurs the read-eval-write overhead. What we could do instead is compile the Uxntal code itself, rather than emulating it. But that will be the topic of another article.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The banner picture shows a row of small rabbit status at a Shinto shrine in Kyoto.&lt;/em&gt;&lt;/p&gt;

        </content>
    </entry>
    
    <entry>
        <title>The politics of writing compilers</title>
        <link href="https://wimvanderbauwhede.github.io/articles/politics-of-compiler-writing/"/>
        <updated>2021-12-20T00:00:00+00:00</updated>
        <id>https://wimvanderbauwhede.github.io/articles/politics-of-compiler-writing</id>
        <author>
					<name>Wim Vanderbauwhede</name>
					<uri>https://wimvanderbauwhede.github.io/</uri>
					
				</author>
        <content type="html">
        	&lt;img src=&quot;https://wimvanderbauwhede.github.io/images/politics-of-compiler-writing_1600x600.jpg&quot;&gt;&lt;br/&gt;
        	&lt;p&gt;Compilers are pieces of software that convert program code from one format into another. Typically, they convert source code into a binary format for execution on specific hardware. Compilers can also target virtual machines instead of physical hardware, or they can convert source code into different source code. &lt;/p&gt;

&lt;p&gt;(Some programming languages are not compiled but interpreted, which means they require another piece of software, an interpreter, to run them. An interpreter is effectively a compiler and virtual machine combined, because it transforms the source code into some internal representation that it can execute. In this article, I focus on compilers but the same issues apply to interpreters.)&lt;/p&gt;

&lt;p&gt;Most end users never deal with compilers because they simply run the compiled applications. Some users have the need, know-how and skills to compile code written by others; fewer again have the need, know-how and skills to write their own code and compile it. And quite few people have the know-how and skills to write a compiler. And yet, compilers are crucially important, as without a compiler, programs can&amp;#39;t run. &lt;/p&gt;

&lt;p&gt;This automatically takes me to the question of politics. Whoever controls the compiler has some power over the users (both the programmers and the end users), and therefore compilers are political objects. &lt;/p&gt;

&lt;p&gt;But what about compiler research, the field of computing science which investigates new theories, formalisms and techniques to advance the knowledge on compilers? Generally speaking, compiler researchers will not consider their work political. A compiler is a tool that can be used regardless of political convictions, and research into better compilers just leads to better tools. Compiler writers can make a similar argument: we just make them. &lt;/p&gt;

&lt;p&gt;There are many different aspects to this. As a compiler researcher or compiler writer, you could ask yourself the following questions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;What are the reasons for doing this work? 

&lt;ul&gt;
&lt;li&gt;Why are you writing this compiler? Or what is the target compiler for your research?&lt;/li&gt;
&lt;li&gt;Who is going to benefit from your work? You? Your employer? The community? What community?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What are your assumptions?

&lt;ul&gt;
&lt;li&gt;Assumptions on the programmer: 

&lt;ul&gt;
&lt;li&gt;What do they need to know?&lt;br&gt;&lt;/li&gt;
&lt;li&gt;What education level do they need? &lt;/li&gt;
&lt;li&gt;How wealthy do they need to be?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Assumptions on the user: 

&lt;ul&gt;
&lt;li&gt;Who is the user of your compiler? &lt;/li&gt;
&lt;li&gt;What are their required skills and background? &lt;/li&gt;
&lt;li&gt;How usable and accessible is your compiler? &lt;/li&gt;
&lt;li&gt;Which users can afford to use your compiler?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Assumptions on the computer:

&lt;ul&gt;
&lt;li&gt;If your compiler targets a specific hardware architecture, who has access to this hardware?&lt;/li&gt;
&lt;li&gt;Does your compiler need the latest hardware and/or latest operating system to run? &lt;/li&gt;
&lt;li&gt;How much memory and disk space does it need?&lt;/li&gt;
&lt;li&gt;Does it need internet access?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Assumptions on the availability: 

&lt;ul&gt;
&lt;li&gt;Is it available free of charge? &lt;/li&gt;
&lt;li&gt;Does it work on many operating systems?&lt;/li&gt;
&lt;li&gt;Is it available in a readily-useable form?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Inevitably, the answers to these questions are inherently political. &lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The banner picture shows activists and a candidate of the Communist Party of Japan.&lt;/em&gt; &lt;/p&gt;

        </content>
    </entry>
    
    <entry>
        <title>Frugal computing: developer perspective</title>
        <link href="https://wimvanderbauwhede.github.io/articles/frugal-computing-developer/"/>
        <updated>2021-12-20T00:00:00+00:00</updated>
        <id>https://wimvanderbauwhede.github.io/articles/frugal-computing-developer</id>
        <author>
					<name>Wim Vanderbauwhede</name>
					<uri>https://wimvanderbauwhede.github.io/</uri>
					
				</author>
        <content type="html">
        	&lt;img src=&quot;https://wimvanderbauwhede.github.io/images/frugal-computing-developer_1600x600.jpg&quot;&gt;&lt;br/&gt;
        	&lt;p&gt;On the need for low-carbon and sustainable computing and what developers can do about it.&lt;/p&gt;

&lt;p&gt;This is a follow-up on my &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/frugal-computing&quot;&gt;article about Frugal Computing&lt;/a&gt;, focusing on the what developers can do to help reduce the carbon emissions from computing. &lt;/p&gt;

&lt;h2&gt;Key points&lt;/h2&gt;

&lt;h3&gt;The problem:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The current emissions from computing are about 2% of the world total but are projected to rise steeply over the next two decades. By 2040 emissions from computing alone will be more than half the emissions level acceptable to keep global warming below 1.5°C. This growth in computing emissions is unsustainable: it would make it virtually impossible to meet the emissions warming limit.&lt;/li&gt;
&lt;li&gt;The emissions from production of computing devices far exceed the emissions from their electricity usage, so even if devices are more energy efficient producing more of them will make the emissions problem worse.&lt;/li&gt;
&lt;li&gt;The CO₂ emissions from the internet infrastructure resulting from individual internet usage are also very large and growing steeply because of the increased use of higher-resolution video and VR/AR. &lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;The solution:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;As a society we need to start treating computational resources as finite and precious, to be utilised only when necessary, and as effectively as possible. We need &lt;em&gt;frugal computing&lt;/em&gt;: achieving the same results for less energy. &lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Developer actions:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Make software that works on older devices, the older the better.&lt;/li&gt;
&lt;li&gt;Make software that will keep on working for a very long time.&lt;/li&gt;
&lt;li&gt;Make software that uses the least amount of total energy to achieve its results.&lt;/li&gt;
&lt;li&gt;Make software that also uses the least amount of network data transfer, memory and storage.&lt;/li&gt;
&lt;li&gt;Make software that encourages the user to use it in a frugal way.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Extending the useful life of computing devices is key&lt;/h2&gt;

&lt;p&gt;End-user computing devices (phones, laptops, desktops) &lt;a href=&quot;https://reboxed.co/blogs/outsidethebox/the-carbon-footprint-of-your-phone-and-how-you-can-reduce-it&quot;&gt;create more emissions during their manufacturing than during their useful life, and this is not likely to change significantly in the next two decades&lt;/a&gt;. Therefore, we must extend the useful life of our computing devices. This is the top priority.&lt;/p&gt;

&lt;h3&gt;Make software that works on older devices, the older the better&lt;/h3&gt;

&lt;p&gt;One of the main reason why users upgrade their devices is that the device is no longer capable of supporting the needs of new software. This can be because the new software requires
  - more resources than the device has (memory, CPU speed, network bandwidth, screen resolution);
  - a more recent version of other software than device can support, including the operating system.&lt;/p&gt;

&lt;p&gt;This is why when developing software, you should make it work on older devices by design. That way, users with older devices can use your software without having to upgrade. That also means your software should use the least amount of resources (CPU, memory, storage etc) possible to achieve its results, as older devices have fewer resources.&lt;/p&gt;

&lt;h3&gt;Make software that will keep on working for a very long time&lt;/h3&gt;

&lt;p&gt;It is also important that the software you write will keep on working for as long as possible, ideally forever. One reason why your software might stop working is that its resource utilisation grows over time. This can for example be the case if it needs increasingly more memory or disk space the longer it gets used. Another reason is that bugs and vulnerabilities that are discovered only after a long time might not get fixed. &lt;/p&gt;

&lt;p&gt;The software needs to be supported for as long the device lasts. So frugal software requires a long-term commitment in terms of updates for security and bugfixing.&lt;/p&gt;

&lt;h2&gt;Being frugal with resources&lt;/h2&gt;

&lt;p&gt;Whereas for mobile phones the emissions from usage are much lower than the emissions from manufacturing, for laptops and desktop computers, emissions from usage are still significant. &lt;/p&gt;

&lt;h3&gt;Make software that uses the least amount of total energy to achieve its results&lt;/h3&gt;

&lt;p&gt;Not only do older devices have fewer resources, resource consumption eventually means emissions, because all resources on a device consume energy. In practice, a large source of emissions resulting from end user device activity is the local Wifi, because transfering the data (e.g. video) consumes a lot of energy. However, on laptops, desktops and servers, CPU and GPU power consumption is also a significant factor.&lt;/p&gt;

&lt;p&gt;The consequence is that as a developer, you need to be aware of all factors that contribute to the total enery consumption of a task performed by your software. For apps and web sites, the dominant sources of emissions are &lt;a href=&quot;https://www.carbontrust.com/our-work-and-impact/guides-reports-and-tools/carbon-impact-of-video-streaming&quot;&gt;in the home&lt;/a&gt;. For &lt;a href=&quot;https://www.researchgate.net/publication/336909520_Toward_Greener_Gaming_Estimating_National_Energy_Use_and_Energy_Efficiency_Potential&quot;&gt;non-networked games, the power consumption of the CPU and GPU&lt;/a&gt; is the main source of emissions. &lt;/p&gt;

&lt;h3&gt;Make software that encourages the user to be frugal&lt;/h3&gt;

&lt;p&gt;For some applications, the behaviour of the user can have a major effect on the resources it uses. If you are developing such an application, consider if you can encourage or nudge the user to use fewer resources.&lt;/p&gt;

&lt;p&gt;For example: &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Web browsers need resources depending on the number of sites the user is accessing concurrently as well as on the design of the sites;&lt;/li&gt;
&lt;li&gt;for video based applications, energy consumption depends on the resolution of the video; &lt;/li&gt;
&lt;li&gt;if the user experiences the app as sluggish or erratic, they might be more inclined to upgrade their device.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[Note: post edited on 2022-12-07 because the original post assumed that internet network emissions are proportional to the traffic volume, and more recent research shows this is not the case.]&lt;/p&gt;

        </content>
    </entry>
    
    <entry>
        <title>Generic datastructure traversals with roles and introspection</title>
        <link href="https://wimvanderbauwhede.github.io/articles/generic-traversals-in-raku/"/>
        <updated>2021-12-13T00:00:00+00:00</updated>
        <id>https://wimvanderbauwhede.github.io/articles/generic-traversals-in-raku</id>
        <author>
					<name>Wim Vanderbauwhede</name>
					<uri>https://wimvanderbauwhede.github.io/</uri>
					
				</author>
        <content type="html">
        	&lt;img src=&quot;https://wimvanderbauwhede.github.io/images/generic-traversals-in-raku_1600x600.jpg&quot;&gt;&lt;br/&gt;
        	&lt;p&gt;I am a &lt;a href=&quot;https://andrewshitov.com/2015/05/05/interview-with-audrey-tang/&quot;&gt;lambdacamel&lt;/a&gt; and therefore I like to adapt concepts and techniques from functional programming, and in particular from the &lt;a href=&quot;https://www.haskell.org/&quot;&gt;Haskell&lt;/a&gt; language, to Raku. One of the techniques that I use a lot is &lt;em&gt;generic traversals&lt;/em&gt;, also known as &amp;quot;Scrap Your Boilerplate&amp;quot; after the title of &lt;a href=&quot;https://archive.alvb.in/msc/02_infogp/papers/SYB1.pdf&quot;&gt;the paper by Simon Peyton Jones and Ralf Lämmel&lt;/a&gt; that introduced this approach. In their words: &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Many programs traverse data structures built from rich mutually-recursive data types. Such programs often have a great deal of “boilerplate” code that simply walks the structure, hiding a small amount of “real” code that constitutes the reason for the traversal. ”Generic programming” is the umbrella term to describe a wide variety of programming technology directed at this problem. &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So to save you having to write your own custom traversal, this approach gives you generic functions that do traversals on arbitrary data strucures. In this article, I will explain how you can easily implement such generics in Raku for arbitrary role-based datastructures. There is no Haskell in this article.&lt;/p&gt;

&lt;h2&gt;Roles as datatypes by example&lt;/h2&gt;

&lt;p&gt;I implemented of these generics for use with role-based datatypes. Raku&amp;#39;s &lt;a href=&quot;https://docs.raku.org/language/objects#index-entry-Parameterized_Roles&quot;&gt;parameterised roles&lt;/a&gt; make creating complex datastructures very easy. I use the roles purely as datatypes, so they have no associated methods. &lt;/p&gt;

&lt;p&gt;For example, here is an example code snippet in a little language that I use in my research. &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;map (f1 . f2) (map g (zipt (v1,map h v2)))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The primitives are &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;.&lt;/code&gt; (function composition), &lt;code&gt;zipt&lt;/code&gt; and the tuple &lt;code&gt;(...)&lt;/code&gt;, and the names of functions and vectord. The datatype for the abstract syntax of this little language is called &lt;code&gt;Expr&lt;/code&gt; and looks as follows:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Any expression in the language&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Expr&lt;/span&gt; {}
&lt;span class=&quot;c1&quot;&gt;# map f v&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MapV&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;Expr&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;f_&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;Expr&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;v_&lt;/span&gt;] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Expr&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Expr&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.f&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;f_&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Expr&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.v&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;v_&lt;/span&gt;;
}
&lt;span class=&quot;c1&quot;&gt;# function composition f . g&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Comp&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;Expr&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;f_&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;Expr&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;g_&lt;/span&gt;] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Expr&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Expr&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.f&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;f_&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Expr&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.g&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;g_&lt;/span&gt;;
}
&lt;span class=&quot;c1&quot;&gt;# zipt t turns a tuple of vectors into a vector of tuples&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ZipT&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;Expr&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;t_&lt;/span&gt;] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Expr&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Expr&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.t&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;t_&lt;/span&gt;
}
&lt;span class=&quot;c1&quot;&gt;# tuples are just arrays of Expr&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tuple&lt;/span&gt;[&lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;Expr&lt;/span&gt;] \&lt;span class=&quot;n&quot;&gt;e_&lt;/span&gt;] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Expr&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;Expr&lt;/span&gt;] &lt;span class=&quot;nv&quot;&gt;$.e&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;e_&lt;/span&gt;
}
&lt;span class=&quot;c1&quot;&gt;# names of functions and vectors are just string constants&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt;[&lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;n_&lt;/span&gt;] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Expr&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.n&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;n_&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;Expr&lt;/code&gt; role is the toplevel datatype. It is empty because it is implemented entirely in terms of the other roles, which thanks to the &lt;code&gt;does&lt;/code&gt; are all of type &lt;code&gt;Expr&lt;/code&gt;. And most of the roles have attributes that are also of type &lt;code&gt;Expr&lt;/code&gt;. So we have a recursive datatype, a tree with the &lt;code&gt;Name&lt;/code&gt; node as leaves. &lt;/p&gt;

&lt;p&gt;We can now write the abstract syntax tree (AST) of the example code using this &lt;code&gt;Expr&lt;/code&gt; datatype:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;ast&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;MapV&lt;/span&gt;[ 
    &lt;span class=&quot;n&quot;&gt;Comp&lt;/span&gt;[
        &lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt;[&lt;span class=&quot;s&quot;&gt;&amp;#39;f1&amp;#39;&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;,
        &lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt;[&lt;span class=&quot;s&quot;&gt;&amp;#39;f2&amp;#39;&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;
    ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;,
    &lt;span class=&quot;n&quot;&gt;MapV&lt;/span&gt;[
        &lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt;[&lt;span class=&quot;s&quot;&gt;&amp;#39;g&amp;#39;&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;,
        &lt;span class=&quot;n&quot;&gt;ZipT&lt;/span&gt;[
            &lt;span class=&quot;n&quot;&gt;Tuple&lt;/span&gt;[
                &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;Expr&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;(
                    &lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt;[&lt;span class=&quot;s&quot;&gt;&amp;#39;v1&amp;#39;&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;,
                    &lt;span class=&quot;n&quot;&gt;MapV&lt;/span&gt;[
                        &lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt;[&lt;span class=&quot;s&quot;&gt;&amp;#39;h&amp;#39;&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;,
                        &lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt;[&lt;span class=&quot;s&quot;&gt;&amp;#39;v2&amp;#39;&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;
                    ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;
                )
            ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;
        ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;
    ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;
].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The typical way to work with such a datastructure is using a &lt;code&gt;given/when&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Expr&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;expr&lt;/span&gt;) {
    &lt;span class=&quot;k&quot;&gt;given&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expr&lt;/span&gt; {
        &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MapV&lt;/span&gt; {...}
        &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Comp&lt;/span&gt; {...}
        &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ZipT&lt;/span&gt; {...}
        ...        
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Alternatively, you can use a multi sub:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Mapv&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;expr&lt;/span&gt;) {...}
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Comp&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;expr&lt;/span&gt;) {...}
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;ZipT&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;expr&lt;/span&gt;) {...}
...        
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In both cases, we use the roles as the types to match against for the actions we want to take.&lt;/p&gt;

&lt;p&gt;(For more details about algebraic datatypes see my earlier article &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/roles-as-adts-in-raku/&quot;&gt;Roles as Algebraic Data Types in Raku&lt;/a&gt;.)&lt;/p&gt;

&lt;h2&gt;Generics&lt;/h2&gt;

&lt;p&gt;If I want to traverse the AST above, what I would normally do is write a worker as above, where for every node except the leaf nodes, I would call the worker recursively, for example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Expr&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;expr&lt;/span&gt;) {
    &lt;span class=&quot;k&quot;&gt;given&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expr&lt;/span&gt; {
        &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MapV&lt;/span&gt; {
            &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;f_&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;expr&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;);
            &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;v_&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;expr&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;);
            ...
        }
        ...        
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But wouldn&amp;#39;t it be nice if I did not have to write that code at all? Enter generics.&lt;/p&gt;

&lt;p&gt;I base my naming and function arguments on that of the &lt;a href=&quot;https://hackage.haskell.org/package/syb-0.7.2.1/docs/Data-Generics.html&quot;&gt;Haskell library &lt;code&gt;Data.Generics&lt;/code&gt;&lt;/a&gt;. It provides many schemes for traversals, but the most important ones are &lt;code&gt;everything&lt;/code&gt; and &lt;code&gt;everywhere&lt;/code&gt;. &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;everything&lt;/code&gt; is a function which takes a datastructure, a matching function, an accumulator and an update function for the accumulator. The matching function defines what you are looking for in the datastructure. The result is put into the accumulator using the update function.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;everything&lt;/span&gt;(
    &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;datastructure&lt;/span&gt;, 
    &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;accumulator&lt;/span&gt;, 
    &lt;span class=&quot;nv&quot;&gt;&amp;amp;joiner&lt;/span&gt;, 
    &lt;span class=&quot;nv&quot;&gt;&amp;amp;matcher&lt;/span&gt; 
    --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;){...}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;everywhere&lt;/code&gt; is a function which takes a datastructure and a modifier function. The modifier function defines which parts of the datastructure you want to modify. The result of the traversal is a modified version of the datastructure.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;everywhere&lt;/span&gt;(
    &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;datastructure&lt;/span&gt;, 
    &lt;span class=&quot;nv&quot;&gt;&amp;amp;modifier&lt;/span&gt; 
    --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;){...}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The most common case for the accumulator is to use a list, so the updated function appends lists to the accumulator:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;(\&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;) {
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; (|&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;, |&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As an example of a matching function, let&amp;#39;s for example find all the function and vector names in our AST above:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;matcher&lt;/span&gt;(\&lt;span class=&quot;n&quot;&gt;expr&lt;/span&gt;) {
    &lt;span class=&quot;k&quot;&gt;given&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expr&lt;/span&gt; {
        &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt; {
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; [&lt;span class=&quot;n&quot;&gt;expr&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;]
        } 
    }
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; []
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So if we find a &lt;code&gt;Name&lt;/code&gt; node, we return its &lt;code&gt;n&lt;/code&gt; attribute as a single-element list; otherwise we return an empty list.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;names&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;everything&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;ast&lt;/span&gt;,[],&lt;span class=&quot;nv&quot;&gt;&amp;amp;append&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;matcher&lt;/span&gt;); 
&lt;span class=&quot;c1&quot;&gt;# =&amp;gt; returns (f1 f2 g h v1 v2)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or let&amp;#39;s say we want to change the names in this AST:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modifier&lt;/span&gt;(\&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;) {
    &lt;span class=&quot;k&quot;&gt;given&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; {
        &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt; {
            &lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;~&lt;span class=&quot;s&quot;&gt;&amp;#39;_updated&amp;#39;&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt; 
        }
        &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; {&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;}
    }
}

&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;ast_&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;everywhere&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;ast&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;modifier&lt;/span&gt;); 
&lt;span class=&quot;c1&quot;&gt;# =&amp;gt; returns the AST with all names appended with &amp;quot;_updated&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Implementing Generics&lt;/h2&gt;

&lt;p&gt;So how do we implement these magic &lt;code&gt;everything&lt;/code&gt; and &lt;code&gt;everywhere&lt;/code&gt; functions? The problem to solve is that we want to iterate through the attributes of every role without having to name it. The solution for this is to use Raku&amp;#39;s &lt;a href=&quot;https://docs.raku.org/language/mop&quot;&gt;Metaobject protocol (MOP)&lt;/a&gt; for introspection. In practice, we use the Rakudo-specific &lt;a href=&quot;https://docs.raku.org/type/Metamodel::ClassHOW&quot;&gt;&lt;code&gt;Metamodel&lt;/code&gt;&lt;/a&gt;. We need only three methods: &lt;code&gt;attribute&lt;/code&gt;, &lt;code&gt;get_value&lt;/code&gt; and &lt;code&gt;set_value&lt;/code&gt;. With these, we can iterate through the attributes and visit them recursively.&lt;/p&gt;

&lt;p&gt;Attributes can be &lt;code&gt;$&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt; (and even &lt;code&gt;&amp;amp;&lt;/code&gt; but I will skip this). What this means in terms of Raku&amp;#39;s type system is that they can be scalar, Iterable or Associative, and we need to distinguish these cases. With that, we can write &lt;code&gt;everything&lt;/code&gt; as follows:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;everything&lt;/span&gt; (\&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;update&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;match&lt;/span&gt;) {
    &lt;span class=&quot;c1&quot;&gt;# Arguments a immutable, so copy to $acc_&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$acc_&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;;
    &lt;span class=&quot;c1&quot;&gt;# Match and update $acc_&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$acc_&lt;/span&gt; =&lt;span class=&quot;n&quot;&gt;update&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$acc_&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;match&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;));
    &lt;span class=&quot;c1&quot;&gt;# Test the attribute type&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; ~~ &lt;span class=&quot;nb&quot;&gt;Associative&lt;/span&gt; {
        &lt;span class=&quot;c1&quot;&gt;# Iterate over the values&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;values&lt;/span&gt; -&amp;gt; \&lt;span class=&quot;n&quot;&gt;t_elt&lt;/span&gt;  {
            &lt;span class=&quot;nv&quot;&gt;$acc_&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;everything&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;t_elt&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$acc_&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;update&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;match&lt;/span&gt;)
        }
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$acc_&lt;/span&gt;; 
    }     
    &lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; ~~ &lt;span class=&quot;n&quot;&gt;Iterable&lt;/span&gt; {
        &lt;span class=&quot;c1&quot;&gt;# Iterate&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; |&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; -&amp;gt; \&lt;span class=&quot;n&quot;&gt;t_elt&lt;/span&gt;  {
            &lt;span class=&quot;nv&quot;&gt;$acc_&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;everything&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;t_elt&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$acc_&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;update&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;match&lt;/span&gt;)
        }
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$acc_&lt;/span&gt;; 
    }

    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; { 
        &lt;span class=&quot;c1&quot;&gt;# Go through all attributes&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;.^&lt;span class=&quot;n&quot;&gt;attributes&lt;/span&gt; -&amp;gt; \&lt;span class=&quot;nb&quot;&gt;attr&lt;/span&gt; {
            &lt;span class=&quot;c1&quot;&gt;# Not everyting return by ^attributes &lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;# is of type Attribute&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;attr&lt;/span&gt; ~~ &lt;span class=&quot;n&quot;&gt;Attribute&lt;/span&gt; {
                &lt;span class=&quot;c1&quot;&gt;# Get the attribute value&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;expr&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;attr&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;get_value&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;);
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expr&lt;/span&gt; ~~ &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;  { &lt;span class=&quot;c1&quot;&gt;# for ContainerDescriptor::Untyped&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$acc_&lt;/span&gt;;
                }
                &lt;span class=&quot;c1&quot;&gt;# Descend into this expression&lt;/span&gt;
                &lt;span class=&quot;nv&quot;&gt;$acc_&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;everything&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;expr&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$acc_&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;update&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;&amp;amp;match&lt;/span&gt;);
            }
        }
    }
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$acc_&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So what we do here essentially is:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;for &lt;code&gt;@&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; we iterate through the values &lt;/li&gt;
&lt;li&gt;iterate through the attributes using &lt;code&gt;^attributes&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;for each attribute, get the expression using &lt;code&gt;get_value&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;call &lt;code&gt;everything&lt;/code&gt; on that expression&lt;/li&gt;
&lt;li&gt;the first thing &lt;code&gt;everything&lt;/code&gt; does is update the accumulator&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;everywhere&lt;/code&gt; is similar:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;everywhere&lt;/span&gt; (\&lt;span class=&quot;n&quot;&gt;t_&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;modifier&lt;/span&gt;) {
    &lt;span class=&quot;c1&quot;&gt;# Modify the node&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;modifier&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;t_&lt;/span&gt;);
    &lt;span class=&quot;c1&quot;&gt;# Test the type for Iterable or Associative&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; ~~ &lt;span class=&quot;nb&quot;&gt;Associative&lt;/span&gt; {
        &lt;span class=&quot;c1&quot;&gt;# Build the updated map&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%t_&lt;/span&gt;;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;keys&lt;/span&gt; -&amp;gt; \&lt;span class=&quot;n&quot;&gt;t_k&lt;/span&gt;  {
            &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;t_v&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;{&lt;span class=&quot;n&quot;&gt;t_k&lt;/span&gt;};
            &lt;span class=&quot;nv&quot;&gt;%t_&lt;/span&gt;{&lt;span class=&quot;n&quot;&gt;t_k&lt;/span&gt;} = &lt;span class=&quot;n&quot;&gt;everywhere&lt;/span&gt; (&lt;span class=&quot;n&quot;&gt;t_v&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;modifier&lt;/span&gt;);
        }
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%t_&lt;/span&gt;; 
    }     
    &lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; ~~ &lt;span class=&quot;n&quot;&gt;Iterable&lt;/span&gt; {
        &lt;span class=&quot;c1&quot;&gt;# Build the updated list&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@t_&lt;/span&gt;=[];
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; |&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; -&amp;gt; \&lt;span class=&quot;n&quot;&gt;t_elt&lt;/span&gt;  {
            &lt;span class=&quot;nv&quot;&gt;@t_&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;push&lt;/span&gt;( &lt;span class=&quot;n&quot;&gt;everywhere&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;t_elt&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;modifier&lt;/span&gt;) );
        }
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@t_&lt;/span&gt;; 
    }

    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; {
        &lt;span class=&quot;c1&quot;&gt;# t is immutable so copyto $t_&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$t_&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;.^&lt;span class=&quot;n&quot;&gt;attributes&lt;/span&gt; -&amp;gt; \&lt;span class=&quot;nb&quot;&gt;attr&lt;/span&gt; {            
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;attr&lt;/span&gt; ~~ &lt;span class=&quot;n&quot;&gt;Attribute&lt;/span&gt; {
                &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;expr&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;attr&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;get_value&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;);
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expr&lt;/span&gt; ~~ &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;  { &lt;span class=&quot;c1&quot;&gt;# for ContainerDescriptor::Untyped&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$t_&lt;/span&gt;;
                }
                &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;expr_&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;everywhere&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;expr&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;modifier&lt;/span&gt;);                
                &lt;span class=&quot;nb&quot;&gt;attr&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;set_value&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$t_&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;expr_&lt;/span&gt;);
            }
        }
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$t_&lt;/span&gt;;
    }
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So what we do here essentially is:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;for &lt;code&gt;@&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; we iterate through the values&lt;/li&gt;
&lt;li&gt;iterate through the attributes using &lt;code&gt;^attributes&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;for each attribute, get the expression using &lt;code&gt;get_value&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;call &lt;code&gt;everywhere&lt;/code&gt; on that expression&lt;/li&gt;
&lt;li&gt;update the attribute using &lt;code&gt;set_value&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;This works without roles too&lt;/h2&gt;

&lt;p&gt;First of all, the above works for classes too, because the Metamodel methods are not specific to roles. Furthermore, because we test for &lt;code&gt;@&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt;, the generics above work just fine for data structures without roles, built from hashes and arrays:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; = [&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;,[&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;,[&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;]],[&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;,[&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;,[&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;]]]];

&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;matcher&lt;/span&gt; (\&lt;span class=&quot;n&quot;&gt;expr&lt;/span&gt;) {
    &lt;span class=&quot;k&quot;&gt;given&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expr&lt;/span&gt; {
        &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt; {
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expr&lt;/span&gt;[&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;] % &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; == &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; {                
                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; [&lt;span class=&quot;n&quot;&gt;expr&lt;/span&gt;]                
            }            
        }
    }
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; []
}

&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;everything&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;,[],&lt;span class=&quot;nv&quot;&gt;&amp;amp;append&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;matcher&lt;/span&gt;);
&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;;
&lt;span class=&quot;c1&quot;&gt;# ([2 3 4 [5 6 7]] [8 9 [10 11 [12]]] [10 11 [12]] [12])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or for hashes:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%hsh&lt;/span&gt; = 
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; =&amp;gt; {
        &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; =&amp;gt; {
            &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; =&amp;gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;,
            &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; =&amp;gt; {
                &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; =&amp;gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;=&amp;gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
            } 
        },
        &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; =&amp;gt; {
            &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; =&amp;gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
        }
    },
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; =&amp;gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;,
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; =&amp;gt; {&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;=&amp;gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;nb&quot;&gt;e&lt;/span&gt;=&amp;gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;}
;

&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hmatcher&lt;/span&gt; (\&lt;span class=&quot;n&quot;&gt;expr&lt;/span&gt;) {
    &lt;span class=&quot;k&quot;&gt;given&lt;/span&gt; (&lt;span class=&quot;n&quot;&gt;expr&lt;/span&gt;) {
        &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt; {
            &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;=[];
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expr&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;keys&lt;/span&gt; -&amp;gt; \&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; {                
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;eq&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; {
                    &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;expr&lt;/span&gt;{&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;})
                }
            }
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;;
        }
    }
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; []
}

&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;hres&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;everything&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;%hsh&lt;/span&gt;,[],&lt;span class=&quot;nv&quot;&gt;&amp;amp;append&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;hmatcher&lt;/span&gt;);
&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hres&lt;/span&gt;;
&lt;span class=&quot;c1&quot;&gt;# ({b =&amp;gt; {a =&amp;gt; {b =&amp;gt; 1, c =&amp;gt; 2}, c =&amp;gt; 1}, c =&amp;gt; {a =&amp;gt; 3}} {b =&amp;gt; 1, c =&amp;gt; 2} 3)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Generic datastructure traversals are a great way to reduce boilerplate code and focus on the actual purpose of the traversals. And now you can have them in Raku too. I have shown the implementation for the two main schemes &lt;code&gt;everything&lt;/code&gt; and &lt;code&gt;everywhere&lt;/code&gt; and shown that they work for role based datastructures as well as traditional hash- or array-based datastructures.&lt;/p&gt;

        </content>
    </entry>
    
    <entry>
        <title>How to reduce the carbon footprint of your digital lifestyle</title>
        <link href="https://wimvanderbauwhede.github.io/articles/frugal-computing-consumer/"/>
        <updated>2021-11-19T00:00:00+00:00</updated>
        <id>https://wimvanderbauwhede.github.io/articles/frugal-computing-consumer</id>
        <author>
					<name>Wim Vanderbauwhede</name>
					<uri>https://wimvanderbauwhede.github.io/</uri>
					
				</author>
        <content type="html">
        	&lt;img src=&quot;https://wimvanderbauwhede.github.io/images/frugal-computing-consumer_1600x600.jpg&quot;&gt;&lt;br/&gt;
        	&lt;p&gt;The CO₂ emissions from &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/frugal-computing&quot;&gt;manufacturing and use of digital devices (laptops, phones, tablets, TVs, ...) are huge and rising steeply&lt;/a&gt;. Here is what you as a consumer can do to help reduce your digital carbon footprint.&lt;/p&gt;

&lt;h2&gt;Key points&lt;/h2&gt;

&lt;h3&gt;The problem:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The current CO₂ emissions from the internet and digital devices form about 2% of the world CO₂ emissions but are expected to rise steeply over the next two decades. By 2040 this &amp;quot;digital carbon footprint&amp;quot; alone will make up more than half of the acceptable global carbon footprint to keep global warming below 1.5°C. So the growth in digital carbon footprint is unsustainable: it would make it virtually impossible to keep global warming below the safe limit.&lt;/li&gt;
&lt;li&gt;What is little known is that the CO₂ emissions from production of digital devices exceed the emissions from the electricity they use over their lifetime. So even if newer devices are more energy efficient, producing more of them will make the emissions problem worse. &lt;/li&gt;
&lt;li&gt;Apart from the carbon footprint of production and energy consumption of our digital devices, their main purpose &amp;mdash; accessing the internet &amp;mdash; also causes increasing amounts of CO₂ emissions. As an end user, you only have direct control over a small fraction of this: the energy consumption of your home (or office etc) network. The core network consumes a huge amount of energy but it does this regardless of how much data you transfer. But there is indirect consumer control: if we collectively use more and more data, the network operators have to install additional capacity. Conversely, if we collectively used a lot less data, some of the networking infrastructure could be powered down and even decommissioned. So it still makes sense to be frugal with your internet data.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;The solution &amp;mdash; what you as a consumer can do:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Buy fewer new devices (laptop/desktop/phone/tablet/TV):

&lt;ul&gt;
&lt;li&gt;Keep using your existing devices for as long as possible.&lt;/li&gt;
&lt;li&gt;Have your devices repaired rather than replacing them.&lt;/li&gt;
&lt;li&gt;Only buy devices you really need.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;When you use your devices, use them as little as possible and in the most energy-efficient manner:

&lt;ul&gt;
&lt;li&gt;Reduce your internet usage.&lt;/li&gt;
&lt;li&gt;Reduce your resolution when watching streaming video.&lt;/li&gt;
&lt;li&gt;Turn off your camera in online meetings.&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Buy fewer new devices&lt;/h2&gt;

&lt;p&gt;The CO₂ emissions from production of digital devices far exceeds the emissions from the electricity they use. Therefore the best possible action from a consumer perspective is not to buy new devices.&lt;/p&gt;

&lt;p&gt;For digital devices such as mobile phones, tablets, laptops, desktop computers and televisions, the carbon footprint from manufacturing is so large that no amount of energy efficiency savings during use can compensate for it. So buying a new device effectively results in more emissions, even if it is a more energy-efficient model. It is better to keep using an older device for longer, even if it less energy-efficient. For the same reason it is better to have your devices repaired than to replace them.&lt;/p&gt;

&lt;p&gt;Companies are starting to realise that increasing numbers of consumers want to use their devices for longer. Apple has recently introduced &lt;a href=&quot;https://www.apple.com/newsroom/2021/11/apple-announces-self-service-repair/&quot;&gt;a repair self-service&lt;/a&gt; and several brands of Android phones have started to offer up to &lt;a href=&quot;https://www.techadvisor.com/buying-advice/google-android/best-brands-for-android-updates-3798154/&quot;&gt;four years of support&lt;/a&gt; on some models. &lt;/p&gt;

&lt;h2&gt;When you use your devices, use them frugally&lt;/h2&gt;

&lt;p&gt;The internet network infrastructure also generates huge amounts of CO₂ emissions. This is the &amp;quot;invisible&amp;quot; carbon footprint of the physical infrastructure required to serve, store and transfer video, voice and data. &lt;/p&gt;

&lt;p&gt;As an end user, you only have direct control over a small fraction of this: the energy consumption of your home (or office etc) network. The core network consumes a huge amount of energy but it does this regardless of how much data you transfer. But there is indirect consumer control: if we collectively use more and more data, the network operators have to install additional capacity. Conversely, if we collectively used a lot less data, some of the networking infrastructure could be powered down and even decommissioned. So it still makes sense to be frugal with your internet data. The same argument holds for cloud storage: manufacturing storage devices has a huge carbon footprint. If we collectively store less data in the cloud, fewer storage devices are needed, and that reduces emissions.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;For video calls, the most effective action is to switch off your camera whenever possible, even if this does not save a lot of energy in the immediate sense.&lt;/li&gt;
&lt;li&gt;For watching streaming video (including TV), reducing the resolution has a similar effect.&lt;/li&gt;
&lt;li&gt;When you use a search engine or browse the web you also increase your footprint. Search requires a lot of storage hardware as well as compute power to calculate the ranking of results. The cost of browsing the web is also high in an less intuitive way: the machinery for brokering and serving ads and tracking user behaviour requires a lot of compute power.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;In a nutshell, the key actions you can take to reduce your digital carbon footprint are to buy fewer new devices, keep using your existing devices for as long as possible and only buy devices you really need: this reduces the carbon footprint of manufacturing. And when using your device, the most effective action is to be frugal: reduce your internet usage, reduce the resolution when watching streaming video and turn off your camera in video calls. Store as little data as possible, especially in the cloud.&lt;/p&gt;

&lt;h3&gt;Postscript: video calls are still better than cars, even electric ones&lt;/h3&gt;

&lt;p&gt;Even with your camera on, it is still better to have a video conference than to drive to a face-to-face meeting. Assuming average estimates for the emissions from internet usage and car journeys, driving just 500 m causes the same emissions as a video call of one hour. And it might come as a surprise that even if you drive a new electric car, that distance only increases to 1 km.&lt;/p&gt;

&lt;p&gt;[Note: post edited on 2022-12-07 because the original post assumed that internet network emissions are proportional to the traffic volume, and more recent research shows this is not the case.]&lt;/p&gt;

        </content>
    </entry>
    
    <entry>
        <title>Why I wrote Haku</title>
        <link href="https://wimvanderbauwhede.github.io/articles/why-i-wrote-haku/"/>
        <updated>2021-10-17T00:00:00+01:00</updated>
        <id>https://wimvanderbauwhede.github.io/articles/why-i-wrote-haku</id>
        <author>
					<name>Wim Vanderbauwhede</name>
					<uri>https://wimvanderbauwhede.github.io/</uri>
					
				</author>
        <content type="html">
        	&lt;img src=&quot;https://wimvanderbauwhede.github.io/images/why-i-wrote-haku_1600x600.png&quot;&gt;&lt;br/&gt;
        	&lt;p&gt;A few weeks ago I released &lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/haku&quot;&gt;Haku&lt;/a&gt;, a Japanese natural-language programming language. Haku is a strict functional language with implicit typing, and &lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/haku/src/branch/main/examples/pwc131-t1.haku&quot;&gt;an example program&lt;/a&gt; looks like this:&lt;/p&gt;

&lt;div style=&quot;writing-mode: vertical-rl&quot;&gt;
&lt;pre&gt;
裂くとはパーツとヨウソで
若しパーツが空に等しいなら
［［ヨウソ］］ですけど
そうでなければ、
一パートはパーツの頭、
一パーツ一はパーツの尻尾、
一マエはパートの頭、
では
若しマエが〈ヨウソ引く一〉に等しいなら
［ヨウソ・パート］・パーツ一ですが
そうでなければ
［ヨウソ］・パーツ
の事です。

本とは
列は壱と弐と三と四と五と七と八と十一と十三と十六と十七、
仮一は列と空を裂くので畳み込む、
仮二は逆な仮一、
魄は仮二を逆で写像する、
魄を見せる
の事です。
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The &lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/haku#haku&quot;&gt;repository README&lt;/a&gt; explains the language and gives some background, as does this &lt;a href=&quot;https://www.slideshare.net/WimVanderbauwhede/haku-a-toy-functional-language-based-on-literary-japanese&quot;&gt;presentation&lt;/a&gt;. I have also written a separate post about the &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/haku-in-raku&quot;&gt;implementation of Haku in Raku&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;This article is about my motivation for creating Haku.&lt;/p&gt;

&lt;p&gt;I am interested in how programming languages influence the programmer&amp;#39;s thinking (the old adage of &amp;quot;to the programmer with a hammer, everything looks like a thumb&amp;quot;). &lt;/p&gt;

&lt;p&gt;From personal experience, I observe that my thinking patterns are quite different when I program in a functional language, an imperative one or an object-oriented one. There is also a marked difference between programming in a statically or dynamically typed language.&lt;/p&gt;

&lt;p&gt;But what about the influence of the programmer&amp;#39;s native language? Most programming languages are based on English, and in particular function calls typically use English word order. &lt;/p&gt;

&lt;h2&gt;Arithmetic in English and Flemish&lt;/h2&gt;

&lt;p&gt;For example, let&amp;#39;s consider the common arithmetic operations +, -, *, /. If we use named functions rather than operators for these, and used the common parentheses-and-commas syntax for function calls, we get something like&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;A+B: add(A,B) 
A-B: subtract(A,B)
A*B: multiply(A,B)
A/B: divide(A,B)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In English we would express this most commonly as an infinitive or as an imperative. For the infinitive, we have:&lt;/p&gt;

&lt;!-- &lt;div class=&quot;highlight&quot; style=&quot;background-color: #eadcb2&quot;&gt;--&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;to add A and/to B
to subtract A and/from B
to multiply A and B
to divide A and/by B
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The pattern is &lt;code&gt;&amp;#39;to&amp;#39; &amp;lt;verb&amp;gt; A &amp;#39;and&amp;#39; B&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For the imperative, we have:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;add A and/to B
subtract A and/from B
multiply A and B
divide A and/by B
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The pattern is &lt;code&gt;&amp;lt;verb&amp;gt; A &amp;#39;and&amp;#39; B&lt;/code&gt;, so the same pattern apart from the &lt;code&gt;to&lt;/code&gt;. And it is easy to see how this pattern informed the typical function call syntax &lt;code&gt;&amp;lt;verb&amp;gt; &amp;#39;(&amp;#39; A &amp;#39;,&amp;#39; B &amp;#39;)&amp;#39;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;However, in Flemish (or Dutch), the order of the arguments is quite different. For the infinitive, we have:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;A en/bij B optellen; A optellen bij B
A en/van B aftrekken; A aftrekken van B
A en/met B vermenigvuldigen; A vermenigvuldigen met B
A en/door B delen; A delen door B
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first variant has the pattern &lt;code&gt;A &amp;#39;en&amp;#39; B &amp;lt;verb&amp;gt;&lt;/code&gt;; the second variant needs a different preposition for each verb but the pattern is &lt;code&gt;A &amp;lt;verb&amp;gt; &amp;lt;preposition&amp;gt; B&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;For the imperative, we have:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;tel A op bij B; tel A en/bij B op
trek A af van B; trek A en/van B af
vermenigvuldig A en/met B
deel A en/door B
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There is not just one single general pattern but three: &lt;code&gt;&amp;lt;verb&amp;gt; A &amp;#39;en&amp;#39; B&lt;/code&gt;, 
&lt;code&gt;&amp;lt;verb&amp;gt; A &amp;lt;preposition&amp;gt; &amp;lt;preposition&amp;gt; B&lt;/code&gt; and  &lt;code&gt;&amp;lt;verb&amp;gt; A &amp;lt;preposition&amp;gt; B &amp;lt;preposition&amp;gt;&lt;/code&gt;, depending on whether the verb has a preposition as part of it or not, and on the position we choose for that preposition. &lt;/p&gt;

&lt;p&gt;So not only are word orders for infinitive and imperative quite different, there is no simple rule for the imperative word order. Which makes me wonder what programming languages would look like if their developers had not been English native speakers. &lt;/p&gt;

&lt;p&gt;That question becomes even more interesting for non-Indo-European languages, because despite the example above, there are still lots of grammatical similarities between languages such as English, French and German.&lt;/p&gt;

&lt;h2&gt;Japanese natural-language programming languages&lt;/h2&gt;

&lt;p&gt;There is one such language that particularly interests me and that is Japanese. I have been learning it for a long time and written &lt;a href=&quot;https://quickandtastycooking.org.uk/articles/&quot;&gt;several posts on Japanese language related topics&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Besides having a very different grammar, Japanese has writing system that is a very different from the Latin alphabet as well as its own number system.&lt;/p&gt;

&lt;p&gt;So I decided to create a natural-language programming language based on Japanese. &lt;/p&gt;

&lt;p&gt;There are already several Japanese natural-language programming languages, all made by Japanese native speakers. &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-English-based_programming_languages&quot;&gt;Wikipedia lists eight&lt;/a&gt; but there are actually only four that are still under active development: &lt;a href=&quot;https://dolittle.eplang.jp/&quot;&gt;Dolittle&lt;/a&gt;, &lt;a href=&quot;https://rdr.utopiat.net/&quot;&gt;Produire&lt;/a&gt;, &lt;a href=&quot;https://nadesi.com/top/&quot;&gt;Nadeshiko&lt;/a&gt; and &lt;a href=&quot;https://www.scripts-lab.co.jp/mind/whatsmind.html&quot;&gt;Mind&lt;/a&gt;. &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Dolittle&lt;/em&gt; ドリトル is an object-oriented language specifically designed for teaching children to program and follows the &lt;a href=&quot;http://people.eecs.berkeley.edu/%7Ebh/logo.html&quot;&gt;Logo&lt;/a&gt; tradition with a turtle to draw shapes. &lt;/li&gt;
&lt;li&gt;&lt;em&gt;Produire&lt;/em&gt; プロデル is an imperative and object-oriented language but more general purpose. It also has a turtle library, so education is definitely one of the main design purposes.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Nadeshiko&lt;/em&gt; なでしこ (meaning &amp;quot;pink&amp;quot;, the flower) is an open source general purpose imperative language.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Mind&lt;/em&gt; is also imperative. Although it is actually a &lt;a href=&quot;https://www.forth.com/&quot;&gt;Forth&lt;/a&gt;-style stack-based language, in general structure it is similar to the other three. &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All these language are complete with support for graphics, networking etc and their own IDE and/or web-based editor. They are practical programming languages, so they all support the use of Arabic numerals as well as operators for arithmetic, logic and comparison operations. &lt;/p&gt;

&lt;h2&gt;Haku&lt;/h2&gt;

&lt;p&gt;My motivation to create Haku was not to create a practical language. I wanted to explore what the result is of creating a programming language based on a non-English language, in terms of syntax, grammar and vocabulary. In particular, I wanted to allow the programmer to control the register of the language to some extent (informal/polite/formal). &lt;a href=&quot;https://nadesi.com/v3/doc/index.php?%E6%96%87%E6%B3%95%2F%E6%95%AC%E8%AA%9E&amp;show&quot;&gt;Nadeshiko&lt;/a&gt; and &lt;a href=&quot;https://www.scripts-lab.co.jp/mind/ver8/doc/02-Program-Hyoki.html#okurigana&quot;&gt;Mind&lt;/a&gt; allow this to some extent, but I wanted even more flexibility.&lt;/p&gt;

&lt;h3&gt;Grammar&lt;/h3&gt;

&lt;p&gt;My main motivation for creating Haku is the difference in grammar between Japanese and most Indo-European languages.&lt;/p&gt;

&lt;p&gt;Notions such as &amp;quot;noun&amp;quot;, &amp;quot;adjective&amp;quot;, &amp;quot;adverb&amp;quot; and &amp;quot;verb&amp;quot; are not quite so clearly defined in Japanese. For example, consider the word &lt;em&gt;yasashii&lt;/em&gt;, &amp;quot;kind&amp;quot;. A person who is kind is a &lt;em&gt;yasashii hito&lt;/em&gt;. A person who is not kind is a &lt;em&gt;yasashikunai hito&lt;/em&gt;. But in its own right, &lt;em&gt;yasashiku&lt;/em&gt; is and adverb, and &lt;em&gt;~nai&lt;/em&gt; is the plain negative verb ending, e.g. &amp;quot;I don&amp;#39;t understand&amp;quot; is &lt;em&gt;wakaranai&lt;/em&gt;. And this &amp;quot;adjective&amp;quot; can get a past tense: &amp;quot;the person who was not kind&amp;quot; is &lt;em&gt;yasashikunakatta hito&lt;/em&gt;. And if we chain adjectives, e.g. &amp;quot;a kind and and clever person&amp;quot;, we get &lt;em&gt;yasashikute kashikoi hito&lt;/em&gt;. And indeed we can have &lt;em&gt;yasashihunakute　kashikonkatta hito&lt;/em&gt;, &amp;quot;the kerson who was not kind and smart&amp;quot;. It is also very easy to nominalise a verb or verbalise a noun by adding a suffix. &lt;/p&gt;

&lt;p&gt;The word order in a sentence is also quite different from most Indo-European languages. The typical order is main topic, secondary topic(s), verb. The function of the topics is indicated with what is called a &amp;quot;particle&amp;quot;, a kind of suffix. For example, &amp;quot;I ate the pudding with a spoon&amp;quot; is &lt;em&gt;purin wo supuun de tabeta&lt;/em&gt;. In this example, the main topic &amp;quot;I&amp;quot; is implied. Japanese is quite a parsimonious language: whenever possible, implied topics are left out, to be inferred from the context. &lt;/p&gt;

&lt;p&gt;Finally, compared to Indo-European languages, verb conjugation serves a different purpose in Japanese. For example in English, French and German, tenses are mainly uses to give precise indications of the time and duration of the action: simple past, present continuous, future perfect continuous etc. Japanese has essentially two tenses: the past and the non-past; and a form to similar to the -ing form in English to indicated an ongoing action, although that is again a loose approximation. However, there are many tenses to indicate modifiers to the verb to say e.g. that something is possible, that the speaker wants something, that a third party wants something, that the speaker has begun to do something, that someone is doing someone a favour and of course to express the level of politeness. For example, &lt;em&gt;shachou ha kiite kuremashita&lt;/em&gt; &amp;quot;the boss did me the favour of listening to me&amp;quot; (the &lt;em&gt;~mashita&lt;/em&gt; is a polite verb form), or &lt;em&gt;wasurekaketeita&lt;/em&gt; &amp;quot;I had begun to forget&amp;quot; (&lt;em&gt;~ta&lt;/em&gt; is a plain past, rather than polite).&lt;/p&gt;

&lt;p&gt;Putting at least some of this grammar in the programming language seemed like an interesting challenge to me. In particular, I was interested in how programmers perceive functions calls. Some time ago I ran a poll about this, and 3/4 of respondents answered &amp;quot;imperative&amp;quot; (other options were infinitive, noun, -ing form). &lt;/p&gt;

&lt;p&gt;In Japanese, the imperative (&lt;em&gt;meireikei&lt;/em&gt;, &amp;quot;command form&amp;quot;) is rarely used. Therefore in Haku you can&amp;#39;t use this form. Instead, you can use the plain form, the polite &lt;em&gt;-masu&lt;/em&gt; form or the &lt;em&gt;-te&lt;/em&gt; form (like &amp;quot;-ing&amp;quot;), including &lt;em&gt;-te kudasai&lt;/em&gt; (similar to &amp;quot;please&amp;quot;). Whether a function is perceived as a verb or a noun is up to you, and the difference is clear from the syntax. If it is a noun, you can turn it into a verb by adding &lt;em&gt;suru&lt;/em&gt;, and if it is a verb, you can add the &lt;em&gt;no&lt;/em&gt; or &lt;em&gt;koto&lt;/em&gt; nominalisers. And you can conjugate the verb forms in many different ways, although in practice the verb ending has no semantic function in the Haku language.&lt;/p&gt;

&lt;h3&gt;Naming and giving meaning&lt;/h3&gt;

&lt;p&gt;In principle, a programming language does not need to be based on natural language at all. The notorious example is APL, which uses symbols for everything. Agda programmers also tends to use lots of mathematical symbols. It works because they are very familiar with those symbols. An interesting question is if an experienced programmer who does not know Japanese could understand a Haku program; or if not, what the minimal changes would be to make it understandable. &lt;/p&gt;

&lt;p&gt;To allow to investigate that question, the Scheme and Raku emitters for Haku support (limited) transliteration to Romaji. I have the intention (but maybe not the time) to create a Romaji version of Haku as well as a version that does not use any Japanese but keeps the word order.&lt;/p&gt;

&lt;h3&gt;Syntax and parsing&lt;/h3&gt;

&lt;p&gt;I also wanted the language to be closer, at lease visually, to literary Japanese. Therefore Haku does not use Roman letters, Arabic digits or common arithmetic, logical and comparison operators. It also supports top-to-bottom, right-to-left writing.  &lt;/p&gt;

&lt;p&gt;Literary Japanese does not use spaces. So another question of interest to was how to tokenise a string of Japanese. &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;There are three writing systems: &lt;em&gt;katakana&lt;/em&gt; (angular), &lt;em&gt;hiragana&lt;/em&gt; (squigly) and &lt;em&gt;kanji&lt;/em&gt; (complicated). &lt;/li&gt;
&lt;li&gt;&lt;em&gt;katakana&lt;/em&gt; is used in a similar way as italics, and also for loanwords and names of plants and animals.&lt;/li&gt;
&lt;li&gt;Nouns, verb, adjectives and adverbs normally start with a &lt;em&gt;kanji&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;hiragana&lt;/em&gt; is used for verb/adjective/adverb endings and &amp;quot;particles&amp;quot;, small words or suffixes that help identify the words in a sentence. &lt;/li&gt;
&lt;li&gt;A verb/adjective/adverb can&amp;#39;t end with a &lt;em&gt;hiragana&lt;/em&gt; character that represents a particle. &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So we have some simple tokenisation rules:
- a sequence of &lt;em&gt;katakana&lt;/em&gt;
- a &lt;em&gt;kanji&lt;/em&gt; followed by more &lt;em&gt;kanji&lt;/em&gt; or &lt;em&gt;hiragana&lt;/em&gt; that do not represent particles
- &lt;em&gt;hiragana&lt;/em&gt; that represent particles&lt;/p&gt;

&lt;p&gt;This is in fact a formalisation of the rules a human uses when reading Japanese. &lt;/p&gt;

&lt;p&gt;Where that fails, we can introduce parentheses. A human reader uses context, and a considerable amount of look-ahead parsing and backtracking, but that would make the parser very complex and slow.&lt;/p&gt;

&lt;p&gt;In practice, only specific adverbs and adjectives are used in Haku. For example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;ラムダ|は|或|エクス|で|エクス|掛ける|エクス|です

ラムダ: katakana word
は: particle
或: pre-noun adjective
エクス: katakana word
で: particle
エクス: katakana word
掛ける: verb
エクス: katakana word　
です: verb (copula)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Number system&lt;/h3&gt;

&lt;p&gt;For large numbers, Japanese uses a number system based on multiples of ten thousand (called &lt;em&gt;myriads&lt;/em&gt;) rather than a thousand. A peculiar feature of this system is that there are &lt;em&gt;kanji&lt;/em&gt; for all powers of 10,000 up to 10&lt;sup&gt;48&lt;/sup&gt;. For more background on this, please read &lt;a href=&quot;https://quickandtastycooking.org.uk/articles/japanese-large-numbers/&quot;&gt;my article on this topic&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;The consequence is that a number such as &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;1,234,567,890 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is composed as &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;  (10 + 2) * 100,000,000 
+ (3 * 1000 + 4 * 100 + 5 * 10 + 6) * 10,000
+  7 * 1000 + 8 * 100 + 9 * 10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which can is written in &lt;em&gt;kanji&lt;/em&gt; as &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;十二億三千四百五十六万七千八百九十
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There are also &lt;em&gt;kanji&lt;/em&gt; for numbers smaller than one. They go down to 10&lt;sup&gt;-12&lt;/sup&gt; in powers of 10 and rational numbers are indicated with the &lt;em&gt;kanji&lt;/em&gt; 点 (&lt;em&gt;ten&lt;/em&gt;, &amp;quot;dot&amp;quot;). So &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;3.14159
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;can be written as    &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt; 三点一分四厘一毛五糸九忽 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Apart from this format, the decimal format is also used, and is indeed more common for rational numbers and also for years (and dates in general), e.g. 2021 is written 二〇二一 instead of 二千二十一. Haku supports all these formats.&lt;/p&gt;

&lt;h2&gt;Poetry&lt;/h2&gt;

&lt;p&gt;The expressiveness of Haku as a programming language is on purpose rather spartan. It is after all a &amp;quot;toy language&amp;quot;, an experimental rather than general-purpose language. &lt;/p&gt;

&lt;p&gt;I am more interested in the natural-language expressiveness of Haku, and for that my criterion  is: Can the programmer write poetry in it? Several of Haku&amp;#39;s features such as adjectives and verb conjugation (&lt;em&gt;okurigana&lt;/em&gt;) are there entirely to make Haku programs sufficiently expressive on the natural-language level to support this idea. For that reason, my &lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/haku/src/branch/main/examples/yuki.haku&quot;&gt;favourite Haku program&lt;/a&gt; is one that demonstrates this ability:&lt;/p&gt;

&lt;div style=&quot;writing-mode: vertical-rl&quot;&gt;
&lt;pre&gt;
忘れるとは件で空のことです。

遠いとは物で物を見せるのことです。

本とは
記憶は「忘れられないあの冬の the new fallen snow」、
忘れかけてた遠い記憶
の事です
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;When run, this program prints out the string 「忘れられないあの冬の the new fallen snow」. The line that causes this string to be printed is &lt;/p&gt;

&lt;p&gt;忘れかけてた遠い記憶&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Wasurekaketeta tooi kioku&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This is on the one hand an example of some of the Japanese grammar features that Haku supports:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;adjectives as functions: &lt;em&gt;tooi&lt;/em&gt; is a so-called &amp;quot;i-adjective&amp;quot;;&lt;/li&gt;
&lt;li&gt;adjectival verbs: &lt;em&gt;wasurekaketeta&lt;/em&gt; is a verb used as an adjective;&lt;/li&gt;
&lt;li&gt;complex verb conjucations: the plain form, used to define the function, is &lt;em&gt;wasureru&lt;/em&gt;. The form &lt;em&gt;~kakeru&lt;/em&gt; means &amp;quot;starting to&amp;quot; and the final ending &lt;em&gt;~ta&lt;/em&gt; is a plain past. &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;But on the other hand, it is also poetry.&lt;/p&gt;

&lt;h2&gt;Why &lt;em&gt;haku&lt;/em&gt;?&lt;/h2&gt;

&lt;p&gt;I decided to call my language &lt;em&gt;haku&lt;/em&gt; because I like the sound of it, and also because that word can be written in many ways and mean many things in Japanese (in my dictionary there are 89 &lt;em&gt;kanji&lt;/em&gt; that have &lt;em&gt;haku&lt;/em&gt; as one of their possible pronunciations). I was definitely thinking about the character Haku from the &lt;a href=&quot;https://ghiblicollection.com/product/spirited-away-collector-s-edition?product_id=7231&quot;&gt;Studio Ghibli movie &amp;quot;Spirited Away&amp;quot;&lt;/a&gt;. Also, I like the resemblance with &lt;a href=&quot;https://raku.org&quot;&gt;Raku&lt;/a&gt;, the implementation language. &lt;/p&gt;

&lt;p&gt;If I had to pick a &lt;em&gt;kanji&lt;/em&gt;, I would write it 珀 (amber) or 魄 (soul, spirit).&lt;/p&gt;

        </content>
    </entry>
    
    <entry>
        <title>Haku: a Japanese programming language</title>
        <link href="https://wimvanderbauwhede.github.io/articles/haku-in-raku/"/>
        <updated>2021-09-20T00:00:00+01:00</updated>
        <id>https://wimvanderbauwhede.github.io/articles/haku-in-raku</id>
        <author>
					<name>Wim Vanderbauwhede</name>
					<uri>https://wimvanderbauwhede.github.io/</uri>
					
				</author>
        <content type="html">
        	&lt;img src=&quot;https://wimvanderbauwhede.github.io/images/haku-in-raku_1600x600.png&quot;&gt;&lt;br/&gt;
        	&lt;p&gt;Haku is a natural language functional programming language based on literary Japanese. This article is about the implementation of Haku in &lt;a href=&quot;https://raku.org&quot;&gt;Raku&lt;/a&gt;. You don&amp;#39;t need to know Japanese or &lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/haku&quot;&gt;have read the Haku documentation&lt;/a&gt;. I you are not familiar with Raku, you might want to read my &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/roles-as-adts-in-raku/#raku-intro&quot;&gt;quick introduction&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I do assume familiarity with the concepts of parsing, syntax tree and code generation. I you find you lack background for what follows, I recommend Andrew Shitov&amp;#39;s series of posts &lt;a href=&quot;https://andrewshitov.com/creating-a-compiler-with-raku/&quot;&gt;Creating a Compiler with Raku
&lt;/a&gt; which takes a step-by-step approach.&lt;/p&gt;

&lt;h2&gt;Haku&lt;/h2&gt;

&lt;p&gt;Haku aims to be close to written Japanese, so it is written in a combination of the three Japanese writing systems &lt;em&gt;kanji&lt;/em&gt; (Chinese characters), &lt;em&gt;hiragana&lt;/em&gt; and &lt;em&gt;katakana&lt;/em&gt;, and Japanese punctuation. There are no spaces, and Haku does not use Arabic (or even Roman) digits nor any operators. The design of the language is explained &lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/haku&quot;&gt;in more detail in the documentation&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;Here is an example of a small Haku program (for more examples see &lt;a href=&quot;https://codeberg.org/wimvanderbauwhede/haku/src/branch/main/examples&quot;&gt;the repo&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;本とは
「魄から楽まで」を見せる
の事です。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This translates as&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;quot;main is: to show &amp;#39;From Haku to Raku&amp;#39;&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;And the Raku version would be&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;From Haku to Raku&amp;#39;&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The strings &amp;quot;本とは&amp;quot; and &amp;quot;の事です。&amp;quot; indicate the start and end of the main program. &amp;quot;「魄から楽まで」&amp;quot; is a string constant. &amp;quot;見せる&amp;quot; is the print function. The &amp;#39;を&amp;#39; indicates that anything before it is an argument of the function. The newlines in the example code are optional and purely there for readability. A Haku program is a single string without whitespace or newlines.&lt;/p&gt;

&lt;p&gt;The actual generated Raku code for this example is&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v6&lt;/span&gt;;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HakuPrelude&lt;/span&gt;;

&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;() {
    &lt;span class=&quot;n&quot;&gt;show&lt;/span&gt;(&lt;span class=&quot;s&quot;&gt;&amp;#39;魄から楽まで&amp;#39;&lt;/span&gt;)
}

&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To be even closer to literary Japanese, Haku programs can be written vertically from right to left:&lt;/p&gt;

&lt;div  class=&quot;highlight&quot; style=&quot;writing-mode: vertical-rl&quot;&gt;
&lt;pre&gt;
忘れるとは
物で空
のことです。

遠いとは
条で条を見せる
のことです。

本とは
記憶は無、
忘れかけてた遠い記憶
の事です。
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The generated Raku code for this Haku program is again quite simple:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v6&lt;/span&gt;;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HakuPrelude&lt;/span&gt;;

&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wasureru&lt;/span&gt;( \&lt;span class=&quot;n&quot;&gt;mono&lt;/span&gt;) {[]}

&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tooi&lt;/span&gt;( \&lt;span class=&quot;n&quot;&gt;jou&lt;/span&gt;) {&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;jou&lt;/span&gt;)}

&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hon&lt;/span&gt;() {
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;kioku&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;Nil&lt;/span&gt;;
    &lt;span class=&quot;n&quot;&gt;wasureru&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;tooi&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;kioku&lt;/span&gt;))
}

&lt;span class=&quot;n&quot;&gt;hon&lt;/span&gt;();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Haku is implemented in Raku. The Haku compiler is a source-to-source compiler (sometimes called &lt;em&gt;transpiler&lt;/em&gt;) which generates Raku source from the Haku source and executes it. Raku makes writing such a compiler easy in many ways:&lt;/p&gt;

&lt;h2&gt;Parsing using Grammars&lt;/h2&gt;

&lt;p&gt;I decided to implement Haku in Raku mostly because I wanted to use Raku&amp;#39;s &lt;a href=&quot;https://docs.raku.org/language/grammars&quot;&gt;Grammars&lt;/a&gt; feature, and it did not disappoint. A grammar is like a class, but instead of methods it has rules or tokens, which are the building blocks of the parser. Any token can be used in the definition of another token by enclosing it in &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt;, for example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;n&quot;&gt; adjective&lt;/span&gt; {&lt;span class=&quot;sr&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;    &amp;lt;i-adjective&amp;gt; | &amp;lt;na-adjective&amp;gt;&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The tokens &lt;code&gt;i-adjective&lt;/code&gt; and &lt;code&gt;na-adjective&lt;/code&gt; have been defined separately and &lt;code&gt;adjective&lt;/code&gt; matches one or the other.&lt;/p&gt;

&lt;p&gt;I have always liked parser combinators (like &lt;a href=&quot;https://www.futurelearn.com/info/courses/functional-programming-haskell/0/steps/27222&quot;&gt;Parsec&lt;/a&gt; in Haskell) and from a certain angle, Raku&amp;#39;s Grammar&amp;#39;s are quite similar. They are both scannerless, i.e. there is no separate tokenisation step, and highly composable. Many of the features offered by Parsec (e.g. &lt;code&gt;many&lt;/code&gt;, &lt;code&gt;oneOf&lt;/code&gt;, &lt;code&gt;sepBy&lt;/code&gt;) are available courtesy of Raku&amp;#39;s regexes.&lt;/p&gt;

&lt;p&gt;There are several features of Raku&amp;#39;s Grammars that helped to make the parser for Haku easy to implement. &lt;/p&gt;

&lt;h3&gt;Excellent Unicode support&lt;/h3&gt;

&lt;p&gt;I think Raku&amp;#39;s Unicode support is really excellent. For example, thanks to the support for Unicode blocks, I can simply write&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;n&quot;&gt; kanji&lt;/span&gt; {&lt;span class=&quot;sr&quot;&gt;  &lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;    &amp;lt;:Block(&amp;#39;CJK Unified Ideographs&amp;#39;)&amp;gt;&lt;/span&gt;
}  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;rather than having to enumerate them all (there are 92,865 kanji in that block!). In fact, the &lt;code&gt;&amp;lt;:...&amp;gt;&lt;/code&gt; syntax works for any Unicode property, not just for Blocks.&lt;/p&gt;

&lt;p&gt;Even better: I have some kanji that are reserved as keywords:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;n&quot;&gt; reserved-kanji&lt;/span&gt; {&lt;span class=&quot;sr&quot;&gt; &amp;#39;本&amp;#39; | &amp;#39;事&amp;#39; | ... &lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To make sure these are excluded from the valid kanji for Haku, I can simply use a set difference:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;n&quot;&gt; kanji&lt;/span&gt; {&lt;span class=&quot;sr&quot;&gt;  &lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;    &amp;lt;:Block(&amp;#39;CJK Unified Ideographs&amp;#39;) - reserved-kanji &amp;gt;&lt;/span&gt;
}  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(One detail that bit me is that the equivalent syntax for a user-defined character class requires an explicit &amp;#39;+&amp;#39; : &lt;code&gt;token set-difference { &amp;lt; +set1 -set2&amp;gt; }&lt;/code&gt; )&lt;/p&gt;

&lt;h3&gt;Tokens and rules&lt;/h3&gt;

&lt;p&gt;Luckily, Raku does not assume by default that you want to parse something where whitespace can be ignored, or that you want to tokenise on whitespace. If you want to ignore whitespace, you can use a &lt;code&gt;rule&lt;/code&gt;. But in Haku, extraneous whitespace is not allowed (except for newlines at certain locations). So I use &lt;code&gt;token&lt;/code&gt; everywhere. (There is also &lt;a href=&quot;https://docs.raku.org/language/grammars#index-entry-declarator_token-Named_Regexes&quot;&gt;&lt;code&gt;regex&lt;/code&gt;, which backtracks&lt;/a&gt;. In Haku&amp;#39;s grammar I have not needed it.)&lt;/p&gt;

&lt;h3&gt;Very powerful regexes&lt;/h3&gt;

&lt;p&gt;As a lambdacamel, I&amp;#39;ve always been fond of Perl&amp;#39;s regexes, the now ubiquitous &lt;a href=&quot;https://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions&quot;&gt;PCREs&lt;/a&gt;. Yet, &lt;a href=&quot;https://docs.raku.org/language/regexes&quot;&gt;Raku&amp;#39;s regexes&lt;/a&gt; go way beyond that in power, expressiveness and readability. &lt;/p&gt;

&lt;p&gt;For one thing, they are composable: you can defined a named regex with the &lt;code&gt;regex&lt;/code&gt; type and use it in subsequent regexes with the &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; syntax. Also, the care with which they have been designed makes them very easy to use.  For example, a negative look-ahead assertion is simply &lt;code&gt;&amp;lt;no&amp;gt; &amp;lt;!before &amp;lt;koto&amp;gt; &amp;gt;&lt;/code&gt;; and the availability of both a try-in-order alternation (&lt;code&gt;||&lt;/code&gt;) and longest-token match alternation (&lt;code&gt;|&lt;/code&gt;) is a huge boon. Another thing I like very much is the ability to make a character class non-capturing:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;n&quot;&gt; lambda-expression&lt;/span&gt; {&lt;span class=&quot;sr&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;        &amp;lt;.aru&amp;gt; &amp;lt;variable-list&amp;gt; &amp;lt;.de&amp;gt; &amp;lt;expression&amp;gt; &lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;    &lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Only &lt;code&gt;&amp;lt;variable-list&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;expression&amp;gt;&lt;/code&gt; will be captured, so a lot of the concrete syntax can be removed at parse time.&lt;/p&gt;

&lt;h3&gt;Grammar composition via roles&lt;/h3&gt;

&lt;p&gt;Roles (&amp;#39;mixins&amp;#39; in Ruby, &amp;#39;traits&amp;#39; in Rust) define interfaces and/or implementation of those interfaces.&lt;br&gt;
I found this a better fit for my purpose than the also-supported class inheritance. For example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Nouns&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Characters&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;n&quot;&gt; sa&lt;/span&gt; {&lt;span class=&quot;sr&quot;&gt; &amp;#39;さ&amp;#39; &lt;/span&gt;}
    &lt;span class=&quot;k&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;n&quot;&gt; ki&lt;/span&gt; {&lt;span class=&quot;sr&quot;&gt; &amp;#39;き&amp;#39; &lt;/span&gt;}
    &lt;span class=&quot;c1&quot;&gt;# 一線 is OK,  一 is not OK, 線 is OK&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;n&quot;&gt; noun&lt;/span&gt; {&lt;span class=&quot;sr&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;        &amp;lt;number-kanji&amp;gt;? &amp;lt;non-number-kanji&amp;gt; &amp;lt;kanji&amp;gt;* &lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;        [&amp;lt;sa&amp;gt;|&amp;lt;ki&amp;gt;]?&lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;    &lt;/span&gt;}
}

&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Identifiers&lt;/span&gt; 
&lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Verbs&lt;/span&gt; 
&lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Nouns&lt;/span&gt; 
&lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Adjectives&lt;/span&gt; 
&lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Variables&lt;/span&gt; 
{
    &lt;span class=&quot;k&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;n&quot;&gt; nominaliser&lt;/span&gt; {&lt;span class=&quot;sr&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;        | &amp;lt;no&amp;gt; &amp;lt;!before &amp;lt;koto&amp;gt; &amp;gt; &lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;        | &amp;lt;koto&amp;gt; &amp;lt;!before &amp;lt;desu&amp;gt; &amp;gt; &lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;    &lt;/span&gt;}
    &lt;span class=&quot;c1&quot;&gt;# Identifiers are variables,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# noun-style, verb-style&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# and adjective-style function names&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;n&quot;&gt; identifier&lt;/span&gt; {&lt;span class=&quot;sr&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;        | &amp;lt;variable&amp;gt; &lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;        | &amp;lt;verb&amp;gt; &amp;lt;nominaliser&amp;gt;? &lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;        | &amp;lt;noun&amp;gt; &amp;lt;.sura&amp;gt;? &lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;        | &amp;lt;adjective&amp;gt; &lt;/span&gt;}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Although I would like a list syntax for this, something like &lt;code&gt;role Identifiers does Verbs, Nouns, Adjectives, Variables {...}&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;There is a lot more to grammars and regexes. The nice Raku folks on Twitter recommended me the book &lt;a href=&quot;https://link.springer.com/book/10.1007/978-1-4842-3228-6&quot;&gt;&amp;quot;Parsing with Perl 6 Regexes and Grammars&amp;quot; by Moritz Lenz&lt;/a&gt; and it was very useful in particular for debugging of the grammar and handling of error messages.&lt;/p&gt;

&lt;h2&gt;Abstract syntax tree using roles&lt;/h2&gt;

&lt;p&gt;I like to implement the abstract syntax tree (AST) as an algebraic data type, the way it is usually done in Haskell. In Raku, one way to do this is to use parametrised Roles &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/roles-as-adts-in-raku/&quot;&gt;as I explained in an earlier post&lt;/a&gt;. Most of the AST maps directly to the toplevel parser for each role in my grammar, for example the lambda expression:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LambdaExpr&lt;/span&gt;[ &lt;span class=&quot;nv&quot;&gt;@lambda-args&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$expr&lt;/span&gt;] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HakuExpr&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Variable&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@.args&lt;/span&gt; = &lt;span class=&quot;nv&quot;&gt;@lambda-args&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HakuExpr&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.expr&lt;/span&gt; = &lt;span class=&quot;nv&quot;&gt;$expr&lt;/span&gt;;
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;From parse tree to abstract syntax tree&lt;/h2&gt;

&lt;p&gt;Raku&amp;#39;s grammars provide a very convenient mechanism for turning the parse tree into an AST, called &lt;a href=&quot;https://docs.raku.org/language/grammars#index-entry-Actions&quot;&gt;Actions&lt;/a&gt;. Essentially, you create a class with a method with the same name as the token or rule in the Grammar. Each method gets the &lt;a href=&quot;https://docs.raku.org/type/Match&quot;&gt;Match object&lt;/a&gt; (&lt;code&gt;$/&lt;/code&gt;) created by the token as a positional argument. &lt;/p&gt;

&lt;p&gt;For example, to populate the AST node for a lambda expression from the parse tree:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lambda-expression&lt;/span&gt;(&lt;span class=&quot;vg&quot;&gt;$/&lt;/span&gt;) {
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@args&lt;/span&gt; = &lt;span class=&quot;nv&quot;&gt;$&amp;lt;variable-list&amp;gt;&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;made&lt;/span&gt;;
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$expr&lt;/span&gt; = &lt;span class=&quot;nv&quot;&gt;$&amp;lt;expression&amp;gt;&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;made&lt;/span&gt;;
        &lt;span class=&quot;k&quot;&gt;make&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LambdaExpr&lt;/span&gt;[&lt;span class=&quot;nv&quot;&gt;@args&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$expr&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The capturing tokens used in the &lt;code&gt;lambda-expression&lt;/code&gt; token are accessible via the notation &lt;code&gt;$&amp;lt;...&amp;gt;&lt;/code&gt; which is shorthand for &lt;code&gt;$/&amp;lt;...&amp;gt;&lt;/code&gt;, i.e. they are named attributes of the current match object.&lt;/p&gt;

&lt;p&gt;In the Haku grammar, there are several tokens where the match is one from a list of alternatives, for example the &lt;code&gt;expression&lt;/code&gt; token, which enumerates anything that is an expression in Haku. For such tokens I use the following code to &amp;quot;inherit&amp;quot; from the constituent tokens:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expression&lt;/span&gt;(&lt;span class=&quot;vg&quot;&gt;$/&lt;/span&gt;) { 
        &lt;span class=&quot;k&quot;&gt;make&lt;/span&gt; &lt;span class=&quot;vg&quot;&gt;$/&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;values&lt;/span&gt;[&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;].&lt;span class=&quot;n&quot;&gt;made&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Because every match is a map with as keys the names of the capturing tokens, and because we know that in this case there will be only one token selected, we know the first element in the corresponding &lt;code&gt;values&lt;/code&gt; list will be the match for that particular token.&lt;/p&gt;

&lt;h2&gt;Code generation&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;haku.raku&lt;/code&gt; main program essentially does this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$hon_parse&lt;/span&gt; = 
    &lt;span class=&quot;n&quot;&gt;Haku&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;parse&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$program_str&lt;/span&gt;, :&lt;span class=&quot;n&quot;&gt;actions&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;HakuActions&lt;/span&gt;));
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$hon_raku_code&lt;/span&gt; =  
    &lt;span class=&quot;n&quot;&gt;ppHakuProgram&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$hon_parse&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;made&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The Haku program string is parsed using the Haku grammar and the methods defined in the corresponding HakuActions class are used to populate the AST. The toplevel parse tree node must be &lt;code&gt;$&amp;lt;haku-program&amp;gt;&lt;/code&gt;, and the &lt;code&gt;made&lt;/code&gt; method of this node returns the AST node &lt;code&gt;HakuProgram&lt;/code&gt;.  The routine &lt;code&gt;ppHakuProgram&lt;/code&gt; is the toplevel routine in the module &lt;code&gt;Raku&lt;/code&gt;, which is the Raku emitter for Haku. (There is also a Scheme emitter, in the module &lt;code&gt;Scheme&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;So &lt;code&gt;ppHakuProgram($hon_parse.made)&lt;/code&gt; pretty-prints the HakuProgram AST node and thus the entire Haku program as Raku code.&lt;/p&gt;

&lt;p&gt;What I like about the role-based AST is that you can pattern match against the variants of a type using &lt;code&gt;given/when&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ppHakuExpr&lt;/span&gt;(\&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;) {            
    &lt;span class=&quot;k&quot;&gt;given&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; {
        &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BindExpr&lt;/span&gt; { ... }
        &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FunctionApplyExpr&lt;/span&gt; { ... }
        &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ListExpr&lt;/span&gt; { ... }
        &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MapExpr&lt;/span&gt; { ... }        
        &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;IfExpr&lt;/span&gt; { ... }   
        &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LetExpr&lt;/span&gt; { ... }
        &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LambdaExpr&lt;/span&gt; { ... }        
        ...
        &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; {
            &lt;span class=&quot;k&quot;&gt;die&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;TODO:&amp;quot;&lt;/span&gt; ~ &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;raku&lt;/span&gt;;
        }        
    }
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The Raku code corresponding to the Haku AST is quite straightforward, but there are a few things worth noting:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Because Haku&amp;#39;s variables are immutable, I use the &lt;code&gt;\&lt;/code&gt; notation which means I don&amp;#39;t have to build a variable table with the sigils.&lt;/li&gt;
&lt;li&gt;Because Haku is functional, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;if&lt;/code&gt; are expressions, so in Raku I wrap them in a &lt;code&gt;do {}&lt;/code&gt; block. &lt;/li&gt;
&lt;li&gt;For partial application I use &lt;code&gt;.assuming()&lt;/code&gt;. &lt;/li&gt;
&lt;li&gt;In Haku, strings are lists. In Raku they aren&amp;#39;t. I created a small Prelude of functions, and the list manipulation functions in that Prelude use pattern matching on the type with &lt;code&gt;given/when&lt;/code&gt; to see if the argument is a string or a list.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Running the generated Raku code&lt;/h2&gt;

&lt;p&gt;Running the generated Raku code is simple: I write the generated Raku code to a module and &lt;code&gt;require&lt;/code&gt; it. The generated code ends with a call to &lt;code&gt;hon()&lt;/code&gt;, the main function in a Haku program, so this automatically executes the program. &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Write the parsed program to a module &lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&amp;#39;Hon.rakumod&amp;#39;&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;IO&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;spurt&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$hon_raku_code&lt;/span&gt;);

&lt;span class=&quot;c1&quot;&gt;# Require the module. This will execute the program&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Hon&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Other things Haku makes really easy is to create command-line flags and document their usage:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;USAGE&lt;/span&gt;() {
    &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Q:to/EOH/;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;    Usage: haku &amp;lt;Haku program, written horizontally or vertically, utf-8 text file&amp;gt;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;        [--tategaki, -t] : do not run the program but print it vertically.&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;        [--miseru, -m] : just print the Raku source code, don&amp;#39;t execute.&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;        ...&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;    EOH&lt;/span&gt;
}

&lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAIN&lt;/span&gt;(
          &lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$src_file&lt;/span&gt;,
          &lt;span class=&quot;nb&quot;&gt;Bool&lt;/span&gt; :&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$tategaki&lt;/span&gt;) = &lt;span class=&quot;nb&quot;&gt;False&lt;/span&gt;,   
          &lt;span class=&quot;nb&quot;&gt;Bool&lt;/span&gt; :&lt;span class=&quot;sr&quot;&gt;m($miseru)&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;False&lt;/span&gt;,
          ...
        );  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;USAGE&lt;/code&gt; is called when &lt;code&gt;MAIN&lt;/code&gt; is called with the wrong (or no) arguments. Arguments of &lt;code&gt;MAIN&lt;/code&gt; prefixed with &lt;code&gt;:&lt;/code&gt; are flags. &lt;code&gt;unit sub&lt;/code&gt; means that anything after this declaration is part of the MAIN program, so no need for &lt;code&gt;{...}&lt;/code&gt;.&lt;/p&gt;

&lt;h2&gt;To conclude&lt;/h2&gt;

&lt;p&gt;This article shows the lazy programmer&amp;#39;s way to creating your own programming language: let Raku do all the hard work. &lt;/p&gt;

&lt;p&gt;Or to express it with a Haku program:&lt;/p&gt;

&lt;div style=&quot;writing-mode: vertical-rl&quot;&gt;
&lt;pre&gt;
本真とは
コンパイラを書いて、
プログラムを書いて、
プログラムを走らす
と言う事です。

&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;the truth:&lt;br&gt;
write the compiler,&lt;br&gt;
write the program,&lt;br&gt;
run the program.&lt;/p&gt;
&lt;/blockquote&gt;

        </content>
    </entry>
    
    <entry>
        <title>Frugal computing </title>
        <link href="https://wimvanderbauwhede.github.io/articles/frugal-computing/"/>
        <updated>2021-06-29T00:00:00+01:00</updated>
        <id>https://wimvanderbauwhede.github.io/articles/frugal-computing</id>
        <author>
					<name>Wim Vanderbauwhede</name>
					<uri>https://wimvanderbauwhede.github.io/</uri>
					
				</author>
        <content type="html">
        	&lt;img src=&quot;https://wimvanderbauwhede.github.io/images/frugal-computing_1600x600.jpg&quot;&gt;&lt;br/&gt;
        	&lt;p&gt;On the need for low-carbon and sustainable computing and the path towards zero-carbon computing.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://wimvanderbauwhede.github.io/translations/fr&quot;&gt;Lisez en Français&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://wimvanderbauwhede.github.io/translations/es&quot;&gt;Lea en Español&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Key points&lt;/h2&gt;

&lt;h3&gt;The problem:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The current emissions from computing are about 2% of the world total but are projected to rise steeply over the next two decades. By 2040 emissions from computing alone will be more than of half the emissions level acceptable to keep global warming below 1.5°C. This growth in computing emissions is unsustainable: it would make it virtually impossible to meet the emissions warming limit.&lt;/li&gt;
&lt;li&gt;The emissions from production of computing devices far exceed the emissions from operating them, so even if devices are more energy efficient producing more of them will make the emissions problem worse. Therefore we must extend the useful life of our computing devices.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;The solution:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;As a society we need to start treating computational resources as finite and precious, to be utilised only when necessary, and as effectively as possible. We need &lt;em&gt;frugal computing&lt;/em&gt;: achieving the same results for less energy. &lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;The vision:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Imagine we can extend the useful life of our devices and even increase their capabilities without any increase in energy consumption, purely by improving the software.&lt;/li&gt;
&lt;li&gt;Meanwhile, we will develop the technologies for the next generation of devices, designed for energy efficiency as well as long life.&lt;/li&gt;
&lt;li&gt;Every subsequent cycle will last longer, until finally the world will have computing resources that last forever and hardly use any energy.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Defining computational resources&lt;/h2&gt;

&lt;p&gt;Computational resources are all resources of energy and material that are involved in any given task that requires computing. For example, when you perform a web search on your phone or participate in a video conference on your laptop, the computational resources involved are those for production and running of your phone or laptop, the mobile network or WiFi you are connected to, the fixed network it connects to, the data centres that perform the search or video delivery operations. If you are a scientist running a simulator in a supercomputer, then the computational resources involved are your desktop computer, the network and the supercomputer. For an industrial process control system, it is the production and operation of the Programmable Logic Controllers.&lt;/p&gt;

&lt;h2&gt;Computational resources are finite&lt;/h2&gt;

&lt;p&gt;Since the start of general purpose computing in the 1970s, our society has been using increasing amounts of computational resources. &lt;/p&gt;

&lt;p&gt;For a long time the growth in computational capability as a function of device power consumption has literally been exponential, a trend expressed by &lt;a href=&quot;https://www.britannica.com/technology/Moores-law&quot;&gt;Moore&amp;#39;s law&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;With this growth in computational capability, increasing use of computational resources has become pervasive in today&amp;#39;s society. Until recently, the total energy budget and carbon footprint resulting from the use of computational resources has been small compared to the world total. As a result, computational resources have until recently effectively been treated as unlimited. &lt;/p&gt;

&lt;p&gt;Because of this, the economics of hardware and software development have been built on the assumption that with every generation, performance would double for free. Now, this unlimited growth is no longer sustainable because of a combination of technological limitations and the climate emergency. Therefore, we need to do more with less. &lt;/p&gt;

&lt;p&gt;Moore&amp;#39;s law has effectively come to an end as integrated circuits can&amp;#39;t be scaled down any more. As a result, the improvement in performance per Watt is slowing down continuously. On the other hand, the demand for computational resources is set to increase considerably.   &lt;/p&gt;

&lt;p&gt;The consequence is that at least for the next decades, growth in demand for computational resources will not be offset by increased power efficiency. Therefore with business as usual, the total energy budget and carbon footprint resulting from the use of computational resources will grow dramatically to become a major contributor to the world total.&lt;/p&gt;

&lt;p&gt;Furthermore, the resources required to create the compute devices and infrastructure are also finite, and the total energy budget and carbon footprint of production of compute devices is huge. Moore&amp;#39;s Law has conditioned us to doubling of performance ever two years, which has led to very short effective lifetimes of compute hardware. This rate of obsolescence of compute devices and software is entirely unsustainable. &lt;/p&gt;

&lt;p&gt;Therefore, as a society we need to start treating computational resources as finite and precious, to be utilised only when necessary, and as frugally as possible. And as computing scientists, we need to ensure that computing has the lowest possible energy consumption. And we should achieve this with the currently available technologies because the lifetimes of compute devices needs to be extended dramatically. &lt;/p&gt;

&lt;p&gt;I would like to call this &amp;quot;frugal computing&amp;quot;: achieving the same results for less energy by being more frugal with our computing resources. &lt;/p&gt;

&lt;h2&gt;The scale of the problem&lt;/h2&gt;

&lt;h3&gt;Meeting the climate targets&lt;/h3&gt;

&lt;p&gt;To limit global warming to 1.5&amp;deg;C, within the next decade a global reduction from 55 gigatonnes CO₂ equivalent (GtCO₂e) by 32 GtCO₂e to 23 GtCO₂e per year is needed &lt;a href=&quot;#5&quot;&gt;[5]&lt;/a&gt;. So by 2030 that would mean a necessary reduction in overall CO₂ emissions of more than 50%. By 2040, a further reduction to 13 GtCO₂e per year is necessary. According to the International Energy Agency &lt;a href=&quot;#10&quot;&gt;[10]&lt;/a&gt;, emissions from electricity are currently estimated at about 10 GtCO₂e. The global proportion of electricity from renewables is projected to rise from the current figure of 22% to slightly more than 30% by 2040 &lt;a href=&quot;#15&quot;&gt;[15]&lt;/a&gt;. A more optimistic scenario by the International Energy Agency &lt;a href=&quot;#17&quot;&gt;[17]&lt;/a&gt; projects 70% of electricity from renewables, but even in that scenario, generation from fossil fuels reduces only slightly, so there is only a slight reduction in emissions as a result.&lt;/p&gt;

&lt;p&gt;In other words, we cannot count on renewables to eliminate CO₂ emissions from electricity in time to meet the climate targets. Reducing the energy consumption is the only option. &lt;/p&gt;

&lt;h3&gt;Emissions from consumption of computational resources&lt;/h3&gt;

&lt;p&gt;The consequence of the end of Moore&amp;#39;s law was expressed most dramatically in a 2015 report by the Semiconductor Industry Association (SIA) &amp;quot;Rebooting the IT Revolution: a call to action&amp;quot; &lt;a href=&quot;#1&quot;&gt;[1]&lt;/a&gt;, which calculated that, based on projected growth rates and on the 2015 ITRS roadmap for CMOS chip engineering technologies &lt;a href=&quot;#16&quot;&gt;[16]&lt;/a&gt;, &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;computing will not be sustainable by 2040, when the energy required for computing will exceed the estimated world&amp;#39;s energy production. &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It must be noted that this is purely the energy of the computing device, as explained in the report. The energy required by e.g. the data centre infrastructure and the network is not included. &lt;/p&gt;

&lt;p&gt;The SIA has reiterated this in their 2020 &amp;quot;Decadal Plan for Semiconductors&amp;quot; &lt;a href=&quot;#2&quot;&gt;[2]&lt;/a&gt;, although they have revised the projection based on a &amp;quot;market dynamics argument&amp;quot;: &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If the exponential growth in compute energy is left unchecked, market dynamics will limit the growth of the computational capacity which would cause a flattening out the energy curve. &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is merely an acknowledgement of the reality that the world&amp;#39;s energy production is not set to rise dramatically, and therefore increased demand will result in higher prices which will damp the demand. So computation is not actually going to exceed the world&amp;#39;s energy production.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ever-rising energy demand for computing vs. global energy production is creating new risk, and new computing paradigms offer opportunities to dramatically improve energy efficiency.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In the countries where most of the computational resources are consumed (US and EU), electricity production accounts currently for 25% of the total emissions &lt;a href=&quot;#4&quot;&gt;[4]&lt;/a&gt;. According to the SIA&amp;#39;s estimates, computation accounts currently for a little less than 10% of the total electricity production but is set to rise to about 30% by 2040. This would mean that, with business as usual, computational resources would be responsible for at least 10% of all global CO₂ emissions by 2040. &lt;/p&gt;

&lt;p&gt;The independent study &amp;quot;Assessing ICT global emissions footprint: Trends to 2040 &amp;amp; recommendations&amp;quot; &lt;a href=&quot;#3&quot;&gt;[3]&lt;/a&gt; corroborates the SIA figures: they estimate the computing greenhouse gas emissions for 2020 between 3.0% and 3.5% of the total, which is a bit higher than the SIA estimate of 2.5% because it does take into account networks and datacentres. Their projection for 2040 is 14% rather than 10%, which means a growth of 4x rather than 3x. &lt;/p&gt;

&lt;p&gt;To put it in absolute values, based on the above estimate, by 2040 energy consumption of compute devices would be responsible for 5 GtCO₂e, whereas the target for world total emissions from all sources is 13 GtCO₂e.&lt;/p&gt;

&lt;h3&gt;Emissions from production of computational resources&lt;/h3&gt;

&lt;p&gt;To make matters worse, the carbon emissions resulting from the production of computing devices exceeds those incurred during operation. This is a crucial point, because it means that we can&amp;#39;t rely on next-generation hardware technologies to save energy: the production of this next generation of devices will create more emissions than any operational gains can offset. It does not mean research into more efficient technologies should stop. But their deployment cycles should be much slower. Extending the useful life of compute technologies by improving the way we design and use software must become our priority.&lt;/p&gt;

&lt;p&gt;The report about the cost of planned obsolescence by the European Environmental Bureau &lt;a href=&quot;#7&quot;&gt;[7]&lt;/a&gt; makes the scale of the problem very clear. For laptops and similar computers, manufacturing, distribution and disposal account for 52% of their &lt;a href=&quot;https://www.sciencedirect.com/topics/earth-and-planetary-sciences/global-warming-potential&quot;&gt;Global Warming Potential&lt;/a&gt; (i.e. the amount of CO₂-equivalent emissions caused). For mobile phones, this is 72%. The report calculates that the lifetime of these devices should be at least 25 years to limit their Global Warming Potential. Currently, for laptops it is about 5 years and for mobile phones 3 years. According to &lt;a href=&quot;#8&quot;&gt;[8]&lt;/a&gt;, the typical lifetime for servers in data centres is also 3-5 years, which again falls short of these minimal requirements. According to this paper, the impact of manufacturing of the servers is 20% of the total, which would require an extension of the useful life to 11-18 years. &lt;/p&gt;

&lt;h3&gt;The total emissions cost from computing&lt;/h3&gt;

&lt;p&gt;Taking into account the carbon cost of both operation and production, computing would be responsible for 10 GtCO₂e by 2040, almost 80% of the acceptable CO₂ emissions budget &lt;a href=&quot;#2&quot;&gt;[2,3,14]&lt;/a&gt;.&lt;/p&gt;

&lt;figure&gt;
&lt;img src=&quot;https://wimvanderbauwhede.github.io/images/computing-emissions.png&quot; alt=&quot;A graph with two bars: world emissions (55) and emissions from computing (0.1) in 2020; and for 2040, the world emissions target to limit warming to 1.5°C (13), and the projected emissions from computing (10)&quot;
title=&quot;A graph with two bars: world emissions (55) and emissions from computing (0.1) in 2020; and for 2040, the world emissions target to limit warming to 1.5°C (13), and the projected emissions from computing (10)&quot; /&gt;
&lt;figcaption&gt;Actual and projected emissions from computing (production+operation), and 2040 emission target to limit warming to &amp;lt;1.5&amp;deg;C&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h3&gt;A breakdown per device type&lt;/h3&gt;

&lt;p&gt;To decide on the required actions to reduce emissions, it is important to look at the numbers of different types of devices and their energy usage. If we consider mobile phones as one category, laptops and desktops as another and servers as a third category, the questions are: how many devices are there in each category, and what is their energy consumption. The absolute numbers of devices in use are quite difficult to estimate, but the yearly sales figures &lt;a href=&quot;#10&quot;&gt;[10]&lt;/a&gt; and estimates for the energy consumption for each category &lt;a href=&quot;#11&quot;&gt;[11,12,13,14]&lt;/a&gt; are readily available from various sources. The tables below show the 2020 sales and yearly energy consumption estimates for each category of devices. A detailed analysis is presented in &lt;a href=&quot;#14&quot;&gt;[14]&lt;/a&gt;.&lt;/p&gt;

&lt;table&gt;
&lt;caption&gt;Number of devices sold worldwide in 2020&lt;/caption&gt;
&lt;tr&gt;&lt;th&gt;Device type&lt;/th&gt;&lt;th&gt;2020 sales&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Phones&lt;/td&gt;&lt;td&gt; 3000M&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Servers&lt;/td&gt;&lt;td&gt; 13M&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Tablets&lt;/td&gt;&lt;td&gt; 160M&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Displays&lt;/td&gt;&lt;td&gt; 40M&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Laptops&lt;/td&gt;&lt;td&gt; 280M&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Desktops&lt;/td&gt;&lt;td&gt; 80M&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;TVs&lt;/td&gt;&lt;td&gt;220M&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;IoT devices&lt;/td&gt;&lt;td&gt; 2000M&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;The energy consumption of all communication and computation technology currently in use in the world is currently around 3,000 TWh/y, about 11% of the world&amp;#39;s electricity consumption, projected to rise by 3-4 times by 2040 with business as usual according to &lt;a href=&quot;#2&quot;&gt;[2]&lt;/a&gt;. This is a conservative estimate: the study in &lt;a href=&quot;#14&quot;&gt;[14]&lt;/a&gt; includes a worst-case projection of a rise to 30,000 TWh (exceeding the current world electricity consumption) by 2030. &lt;/p&gt;

&lt;table&gt;
&lt;caption&gt;Yearly energy consumption estimates in TWh&lt;/caption&gt;
&lt;tr&gt;&lt;th&gt;Device type&lt;/th&gt;&lt;th&gt;TWh&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;TVs&lt;/td&gt;&lt;td&gt; 560&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Other Consumer devices&lt;/td&gt;&lt;td&gt; 240&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Fixed access network (wired+WiFi)&lt;/td&gt;&lt;td&gt; 900 + 500&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Mobile network&lt;/td&gt;&lt;td&gt; 100&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Data centres&lt;/td&gt;&lt;td&gt; 700&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Total&lt;/td&gt;&lt;td&gt; 3000&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;The above data make it clear which actions are necessary: the main carbon cost of phones, tablets and IoT devices is their production and the use of the mobile network, so we must extend their useful life very considerably and reduce network utilisation. Extending the life time is also the key action for datacentres and desktop computers, but their energy consumption also needs to be reduced considerably, as does the energy consumption of the wired, WiFi and mobile networks. &lt;/p&gt;

&lt;p&gt;From the technical side, these are primarily software issues: the hardware exists because of the software&lt;/p&gt;

&lt;h2&gt;A vision for low carbon and sustainable computing&lt;/h2&gt;

&lt;p&gt;It is clear that urgent action is needed: in less than two decades, the global use of computational resources needs to be transformed radically. Otherwise, the world will fail to meet its climate targets, even with significant reductions in other emission areas. The carbon cost of both production and operation of the devices must be considerably reduced. &lt;/p&gt;

&lt;p&gt;To use devices for longer, a change in business models as well as consumer attitudes is needed. This requires raising awareness and education but also providing incentives for behavioural change. And to support devices for a long time, an infrastructure for repair and maintenance is needed, with long-term availability of parts, open repair manuals and training. To make all this happen, economic incentives and policies will be needed (e.g. taxation, regulation). Therefore we need to convince key decision makers in society, politics and business.&lt;/p&gt;

&lt;p&gt;Imagine that we can extend the useful life of our devices and even increase their capabilities, purely by improving the software. With every improvement, the computational capacity will in effect increase without any increase in energy consumption. Meanwhile, we will develop the technologies for the next generation of devices, designed for energy efficiency as well as long life. Every subsequent cycle will last longer, until finally the world will have computing resources that last forever and hardly use any energy.&lt;/p&gt;

&lt;figure&gt;
&lt;img src=&quot;https://wimvanderbauwhede.github.io/images/towards-zero-carbon-computing.png&quot; alt=&quot;A graph with four trends: emissions from production, emissions in total, performance and emissions/performance.&quot;
title=&quot;A graph with four trends: emissions from production, emissions in total, performance and emissions/performance.&quot; /&gt;
&lt;figcaption&gt;Towards zero carbon computing: increasing performance and lifetime and reducing emissions. Illustration with following assumptions: every new generation lasts twice as long as the previous one and cost half as much energy to produce; energy efficiency improves linearly with 5% per year.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;This is a very challenging vision, spanning all aspects of computing science. To name just a few challenges:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We must design software so that it supports devices  with extended lifetimes.&lt;/li&gt;
&lt;li&gt;We need software engineering strategies to handle the extended software life cycles, and in particular deal with &lt;a href=&quot;https://en.wikipedia.org/wiki/Technical_debt&quot;&gt;technical debt&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Longer life means more opportunities to exploit vulnerabilities, so we need better cyber security.&lt;/li&gt;
&lt;li&gt;We need to develop new approaches to reduce overall energy consumption across the entire system.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To address these challenges, action is needed on many fronts. What will you do to make frugal computing a reality?&lt;/p&gt;

&lt;h4&gt;Edits&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;2023-03-06: edits to make it more clear that frugal computing is primarily a software issue.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;References&lt;/h2&gt;

&lt;p&gt;&lt;small&gt;
  &lt;span id=&quot;1&quot;&gt;[1] &lt;a href=&quot;https://www.semiconductors.org/resources/rebooting-the-it-revolution-a-call-to-action-2/&quot;&gt;&lt;em&gt;&amp;quot;Rebooting the IT revolution: a call to action&amp;quot;&lt;/em&gt;, Semiconductor Industry Association/Semiconductor Research Corporation, Sept 2015&lt;/a&gt;&lt;/span&gt;&lt;br&gt;
  &lt;span id=&quot;2&quot;&gt;[2] &lt;a href=&quot;https://www.src.org/about/decadal-plan/decadal-plan-full-report.pdf&quot;&gt;&lt;em&gt;&amp;quot;Full Report for the Decadal Plan for Semiconductors&amp;quot;&lt;/em&gt;, Semiconductor Industry Association/Semiconductor Research Corporation, Jan 2021&lt;/a&gt;&lt;/span&gt;&lt;br&gt;
  &lt;span id=&quot;3&quot;&gt;[3] &lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/S095965261733233X&quot;&gt;&lt;em&gt;&amp;quot;Assessing ICT global emissions footprint: Trends to 2040 &amp;amp; recommendations&amp;quot;&lt;/em&gt;, Lotﬁ Belkhir, Ahmed Elmeligi, Journal of Cleaner Production 177 (2018) 448--463&lt;/a&gt;&lt;/span&gt;&lt;br&gt;
  &lt;span id=&quot;4&quot;&gt;[4] &lt;a href=&quot;https://www.epa.gov/ghgemissions/sources-greenhouse-gas-emissions&quot;&gt;&lt;em&gt;&amp;quot;Sources of Greenhouse Gas Emissions&amp;quot;&lt;/em&gt;, United States Environmental Protection Agency&lt;/a&gt;, Last updated on April 14, 2021&lt;/span&gt;&lt;br&gt;
  &lt;span id=&quot;5&quot;&gt;[5] &lt;a href=&quot;https://www.unep.org/emissions-gap-report-2020&quot;&gt;&lt;em&gt;&amp;quot;Emissions Gap Report 2020&amp;quot;&lt;/em&gt;, UN Environment Programme, December 2020&lt;/a&gt;&lt;/span&gt;&lt;br&gt;
  &lt;span id=&quot;6&quot;&gt;[6] &lt;a href=&quot;https://onlinelibrary.wiley.com/doi/full/10.1111/jiec.13123&quot;&gt;&lt;em&gt;&amp;quot;The link between product service lifetime and GHG emissions: A comparative study for different consumer products&amp;quot;&lt;/em&gt;, Simon Glöser-Chahoud, Matthias Pfaff, Frank Schultmann,  Journal of Industrial Ecology, 25 (2), pp 465-478, March 2021&lt;/a&gt;&lt;/span&gt;&lt;br&gt;
  &lt;span id=&quot;7&quot;&gt;[7] &lt;a href=&quot;https://eeb.org/library/coolproducts-report/&quot;&gt;&lt;em&gt;&amp;quot;Cool products don’t cost the Earth – Report&amp;quot;&lt;/em&gt;, European Environmental Bureau, September 2019&lt;/a&gt;&lt;/span&gt;&lt;br&gt;
  &lt;span id=&quot;8&quot;&gt;[8] &lt;a href=&quot;https://link.springer.com/article/10.1007/s11367-014-0838-7&quot;&gt;&lt;em&gt;&amp;quot;The life cycle assessment of a UK data centre&amp;quot;&lt;/em&gt;, Beth Whitehead, Deborah Andrews, Amip Shah, Graeme Maidment, Building and Environment 93 (2015) 395--405, January 2015&lt;/a&gt;&lt;/span&gt;&lt;br&gt;
  &lt;span id=&quot;9&quot;&gt;[9] &lt;a href=&quot;https://www.statista.com&quot;&gt;Statista&lt;/a&gt;,  retrieved June 2021&lt;/span&gt;&lt;br&gt;
  &lt;span id=&quot;10&quot;&gt;[10] &lt;a href=&quot;https://www.iea.org/reports/global-energy-CO%E2%82%82-status-report-2019/emissions&quot;&gt;&lt;em&gt;&amp;quot;Global Energy &amp;amp; CO₂ Status Report&amp;quot;&lt;/em&gt;, International Energy Agency, March 2019&lt;/a&gt;&lt;/span&gt;&lt;br&gt;
  &lt;span id=&quot;11&quot;&gt;[11] &lt;a href=&quot;https://link.springer.com/article/10.1007/s11367-015-0909-4&quot;&gt;&lt;em&gt;&amp;quot;Redefining scope: the true environmental impact of smartphones?&amp;quot;&lt;/em&gt;, James Suckling, Jacquetta Lee, The International Journal of Life Cycle Assessment volume 20, pages 1181–1196 (2015)&lt;/a&gt;&lt;/span&gt;&lt;br&gt;
  &lt;span id=&quot;12&quot;&gt;[12] &lt;a href=&quot;https://www.racksolutions.com/news/blog/server-rack-power-consumption-calculator/&quot;&gt;&lt;em&gt;&amp;quot;Server Rack Power Consumption Calculator&amp;quot;&lt;/em&gt;, Rack Solutions, Inc., July 2019&lt;/a&gt;&lt;/span&gt;&lt;br&gt;
  &lt;span id=&quot;13&quot;&gt;[13] &lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/S111001682030524X&quot;&gt;&lt;em&gt;&amp;quot;Analysis of energy consumption and potential energy savings of an institutional building in Malaysia&amp;quot;&lt;/em&gt;, Siti Birkha Mohd Ali,  M.Hasanuzzaman, N.A.Rahim, M.A.A.Mamun, U.H.Obaidellah,  Alexandria Engineering Journal, Volume 60, Issue 1, February 2021, Pages 805-820&lt;/a&gt;&lt;/span&gt;&lt;br&gt;
  &lt;span id=&quot;14&quot;&gt;[14] &lt;a href=&quot;https://doi.org/10.3390/challe6010117&quot;&gt;&lt;em&gt;&amp;quot;On Global Electricity Usage of Communication Technology: Trends to 2030&amp;quot;&lt;/em&gt;, Anders S. G. Andrae, Tomas Edler, Challenges 2015, 6(1), 117-157 &lt;/a&gt;&lt;/span&gt;&lt;br&gt;
  &lt;span id=&quot;15&quot;&gt;[15] &lt;a href=&quot;https://www.bp.com/en/global/corporate/energy-economics/energy-outlook.html&quot;&gt;&lt;em&gt;&amp;quot;BP Energy Outlook: 2020 Edition&amp;quot;&lt;/em&gt;,BP plc&lt;/a&gt;&lt;/span&gt;&lt;br&gt;
  &lt;span id=&quot;16&quot;&gt;[16] &lt;a href=&quot;https://www.semiconductors.org/resources/2015-international-technology-roadmap-for-semiconductors-itrs/&quot;&gt;&lt;em&gt;&amp;quot;2015 International Technology Roadmap for Semiconductors (ITRS)&amp;quot;&lt;/em&gt;, Semiconductor Industry Association, June 2015&lt;/a&gt;&lt;/span&gt;&lt;br&gt;
  &lt;span id=&quot;17&quot;&gt;[17] &lt;a href=&quot;https://iea.blob.core.windows.net/assets/deebef5d-0c34-4539-9d0c-10b13d840027/NetZeroby2050-ARoadmapfortheGlobalEnergySector_CORR.pdf&quot;&gt;&lt;em&gt;&amp;quot;Net Zero by 2050 &amp;mdash; A Roadmap for the Global Energy Sector&amp;quot;&lt;/em&gt;, International Energy Agency, October 2021&lt;/a&gt;&lt;/span&gt;&lt;br&gt;
&lt;/small&gt;&lt;/p&gt;

        </content>
    </entry>
    
    <entry>
        <title>Writing faster Raku code</title>
        <link href="https://wimvanderbauwhede.github.io/articles/writing-faster-raku/"/>
        <updated>2020-12-02T00:00:00+00:00</updated>
        <id>https://wimvanderbauwhede.github.io/articles/writing-faster-raku</id>
        <author>
					<name>Wim Vanderbauwhede</name>
					<uri>https://wimvanderbauwhede.github.io/</uri>
					
				</author>
        <content type="html">
        	&lt;img src=&quot;https://wimvanderbauwhede.github.io/images/writing-faster-raku_1600x600.jpg&quot;&gt;&lt;br/&gt;
        	&lt;p&gt;In &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/writing-faster-perl&quot;&gt;an earlier article&lt;/a&gt;, I discussed the result of my attempts to optimize the performance of an expression parser which is part of my Perl-based &lt;a href=&quot;https://github.com/wimvanderbauwhede/RefactorF4Acc&quot;&gt;Fortran source-to-source compiler&lt;/a&gt;. An expression parser takes strings representing expressions in a programming language (in my case Fortran) and turns it into a data structure called a parse tree, which the compiler uses for further analysis and code generation.&lt;/p&gt;

&lt;p&gt;I have recently been writing quite a bit of &lt;a href=&quot;https://raku.org/&quot;&gt;Raku&lt;/a&gt; code but so far I had not looked at its performance. Out of curiosity I decided to rewrite and optimise this Fortran expression parser in Raku.  &lt;/p&gt;

&lt;h2&gt;Expression parsing&lt;/h2&gt;

&lt;p&gt;What I loosely call an expression parser is actually a combination of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Lexical_analysis&quot;&gt;lexer&lt;/a&gt; and a &lt;a href=&quot;https://en.wikipedia.org/wiki/Parsing#Parser&quot;&gt;parser&lt;/a&gt;: it turns a string of source code into a tree-like data structure which expresses the structure of the expression and the purpose of its constituents. For example if the expression is &lt;code&gt;2*v+1&lt;/code&gt;, the result of the expression parser will be a data structure which identifies the top-level expression as a sum of a multiplication with  the integer constant &lt;code&gt;1&lt;/code&gt;, and the multiplication of an integer constant &lt;code&gt;2&lt;/code&gt; with a variable &lt;code&gt;v&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;So how do we build a fast expression parser in Raku? It is not my intention to go into the computing science details, but instead to discuss the choices and trade-offs to be considered.&lt;/p&gt;

&lt;h2&gt;Raku performance testing&lt;/h2&gt;

&lt;p&gt;An easily-made argument is that if you want performance, you should not write your code in Raku but in C/C++. And it is of course true that compiled code will almost always be faster. However, often, rewriting in a compiled language is not an option, so it is important to know how to get the best possible performance in Raku. &lt;/p&gt;

&lt;p&gt;The Raku documentation has &lt;a href=&quot;https://docs.raku.org/language/performance&quot;&gt;a page on performance&lt;/a&gt; which offers good advice in general terms. But for my needs I did not find the answers about the specific trade-offs that I might have to make. So I created some simple test cases to find out more. I used Raku version  &lt;code&gt;2020.09&lt;/code&gt; built on MoarVM version &lt;code&gt;2020.09&lt;/code&gt;, the most recent one when I ran the tests, but the results should be quite similar for slightly earlier and later versions.&lt;/p&gt;

&lt;p&gt;I test the performance using a series of small test benches with different cases, controlled by a command line argument, using the &lt;code&gt;time&lt;/code&gt; command to obtain the wall clock time, and taking the average over 5 runs. For example,&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt; raku test_hash_vs_regex.raku &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;There is more than one way to do it, but only one will be the fastest&lt;/h2&gt;

&lt;p&gt;Parsing involves taking strings and turning them into other data structures, so there are many decisions to be made about the data structures and the ways to turn strings into them and manipulate them. Here are some results of performance comparisons that influenced design decisions for the compiler. I was curious to see if they would turn out different in Raku. &lt;/p&gt;

&lt;h3&gt;Hash key testing is faster than regexp matching&lt;/h3&gt;

&lt;p&gt;Fortran code essentially consists of a list of statements which can contain expressions, and in my compiler the statement parser labels each of the statements once using a hashmap. Every parsed line of code is stored as a pair of the original string &lt;code&gt;$src_line&lt;/code&gt; with this hashmap, called &lt;code&gt;$info&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl&quot; data-lang=&quot;perl&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$parsed_line&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$src_line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$info&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The labels and values stored in &lt;code&gt;$info&lt;/code&gt; depend on the type of statement. It is not &lt;em&gt;a priori&lt;/em&gt; clear if matching a pattern in &lt;code&gt;$src_line&lt;/code&gt; using a regex is faster or slower than looking up the corresponding label in &lt;code&gt;$info&lt;/code&gt;. So I tested the performance of hash key testing versus regexp matching, using some genuine FORTRAN 77 code, a &lt;code&gt;READ&lt;/code&gt; I/O call, labelled in &lt;code&gt;$info&lt;/code&gt; as &lt;code&gt;ReadCall&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;lc&lt;/span&gt;(&lt;span class=&quot;s&quot;&gt;&amp;#39;READ( 1, 2, ERR=8, END=9, IOSTAT=N ) X&amp;#39;&lt;/span&gt;);
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$info&lt;/span&gt; = {};   
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;~~&lt;span class=&quot;sr&quot;&gt;/read/&lt;/span&gt;) {
    &lt;span class=&quot;nv&quot;&gt;$info&amp;lt;ReadCall&amp;gt;&lt;/span&gt; = &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;;
}
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$count&lt;/span&gt;=&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;;

&lt;span class=&quot;k&quot;&gt;constant&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NITERS&lt;/span&gt; = &lt;span class=&quot;mi&quot;&gt;10_000_000&lt;/span&gt;;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CASE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NITERS&lt;/span&gt; -&amp;gt; &lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt; {
&lt;span class=&quot;c1&quot;&gt;# regexp        &lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;~~&lt;span class=&quot;sr&quot;&gt;/read/&lt;/span&gt;) { 
            &lt;span class=&quot;nv&quot;&gt;$count&lt;/span&gt;+=&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;;
        }
    }
} &lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CASE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NITERS&lt;/span&gt; -&amp;gt; &lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt; {
&lt;span class=&quot;c1&quot;&gt;# hash lookup        &lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;$info&amp;lt;ReadCall&amp;gt;&lt;/span&gt;:&lt;span class=&quot;n&quot;&gt;exists&lt;/span&gt;) {
                &lt;span class=&quot;nv&quot;&gt;$count&lt;/span&gt;+=&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;;
            }
    }   
} &lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CASE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NITERS&lt;/span&gt; -&amp;gt; &lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt; {
&lt;span class=&quot;c1&quot;&gt;# overhead        &lt;/span&gt;
                &lt;span class=&quot;nv&quot;&gt;$count&lt;/span&gt;+=&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;;
    }    
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Without the &lt;code&gt;if&lt;/code&gt;-condition in its body (CASE==3), the &lt;code&gt;for 1..NITERS&lt;/code&gt; loop takes 3 s on my laptop. The loop with with the hash key existence test takes 5 s; the regexp match condition takes 53 s. So the actual condition evaluation takes 2 s for hash key existence check and 50 s for regexp match. So testing hash keys is 25 times faster than simple regexp matching. So we trade some memory for computation: we identify the statement once using a regexp, an store the identifying label in &lt;code&gt;$info&lt;/code&gt; for subsequent passes.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Result:&lt;/b&gt; Testing hash keys is 25 times faster than simple regexp matching. So we trade some memory for computation: we identify the statement once using a regexp, an store the identifying label in &lt;code&gt;$info&lt;/code&gt; for subsequent passes.&lt;/p&gt;

&lt;h3&gt;A fast data structure for the parse tree: integer versus string comparison&lt;/h3&gt;

&lt;p&gt;The choice of the data structure for the parsed expression matters. As we need a tree-like ordered data structure, it would have to either an object or a list-like data structure. But objects in are slow, so I use a nested array.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;[&lt;span class=&quot;s&quot;&gt;&amp;#39;+&amp;#39;&lt;/span&gt;,
    [&lt;span class=&quot;s&quot;&gt;&amp;#39;*&amp;#39;&lt;/span&gt;,
        &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;,
        [&lt;span class=&quot;s&quot;&gt;&amp;#39;$&amp;#39;&lt;/span&gt;,&lt;span class=&quot;s&quot;&gt;&amp;#39;v&amp;#39;&lt;/span&gt;]
    ],
    &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;!-- ### Integer comparison is faster than string comparison --&gt;

&lt;p&gt;This data structure is fine if you don&amp;#39;t need to do a lot of work on it. However, because every node is labelled with a string, testing against the node type is a string comparison. Simply testing against a constant string or integer is not good enough as the compiler might optimise this away. So I tested this as follows to make sure &lt;code&gt;$str&lt;/code&gt; and &lt;code&gt;$c&lt;/code&gt; get a new value on every iteration: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CASE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; { &lt;span class=&quot;c1&quot;&gt;# 7.3 - 5.3 = 2 s net&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; .. &lt;span class=&quot;n&quot;&gt;NITERS&lt;/span&gt; -&amp;gt; &lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt; {
&lt;span class=&quot;c1&quot;&gt;# string equality        &lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;chr&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt; % &lt;span class=&quot;mi&quot;&gt;43&lt;/span&gt;);
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;eq&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;*&amp;#39;&lt;/span&gt; {
            &lt;span class=&quot;nv&quot;&gt;$count&lt;/span&gt;+=&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;;
        }
    }
} 
&lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CASE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; { &lt;span class=&quot;c1&quot;&gt;# 3.3 - 3.1 = 0.3&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NITERS&lt;/span&gt; -&amp;gt; &lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt; {
&lt;span class=&quot;c1&quot;&gt;# int equality        &lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$c&lt;/span&gt; = &lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt; % &lt;span class=&quot;mi&quot;&gt;43&lt;/span&gt;;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$c&lt;/span&gt; == &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt; {
            &lt;span class=&quot;nv&quot;&gt;$count&lt;/span&gt;+=&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;;
        }
    }
} &lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CASE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; { &lt;span class=&quot;c1&quot;&gt;# 5.3&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NITERS&lt;/span&gt; -&amp;gt; &lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt; {
&lt;span class=&quot;c1&quot;&gt;# string equality overhead        &lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;chr&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt; % &lt;span class=&quot;mi&quot;&gt;43&lt;/span&gt;);
    }
} &lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CASE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; { &lt;span class=&quot;c1&quot;&gt;# 3.1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NITERS&lt;/span&gt; -&amp;gt; &lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt; {
&lt;span class=&quot;c1&quot;&gt;# int equality overhead&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$c&lt;/span&gt; = &lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt; % &lt;span class=&quot;mi&quot;&gt;43&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I populate the string or integer based on the loop iterator and then perform a comparison to a constant string or integer. By subtracting the time taken for the assignment (cases 3 and 4) I obtain the actual time for the comparison. &lt;/p&gt;

&lt;p&gt;On my laptop, the version with string comparison takes 2 s net, the integer comparison 0.3 s. So doing string comparisons is at least 5 times slower than doing integer comparisons. Therefore my data structure uses integer labels. Also, I label the constants so that I can have different labels for string, integer and real constants, and because in this way all nodes are arrays. This avoids having to test if a node is an array or a scalar, which is a slow operation.&lt;/p&gt;

&lt;p&gt;So the example becomes :&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl&quot; data-lang=&quot;perl&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;29&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;2&amp;#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;v&amp;#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;29&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;1&amp;#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Less readable, but faster and easier to extend. In what follows, what I call the &lt;em&gt;parse tree&lt;/em&gt; is this data structure.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Result:&lt;/b&gt; String comparisons is at least 5 times slower than doing integer comparisons.&lt;/p&gt;

&lt;h3&gt;Custom tree traversals are faster&lt;/h3&gt;

&lt;p&gt;I tested the cost of using higher-order functions for parse tree traversal (recursive descent). Basically, this is the choice between a generic traversal using a higher-order function which takes an arbitrary function that operates on the parse tree nodes: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_traverse_ast_with_action&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$ast_&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$acc_&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;&amp;amp;f&lt;/span&gt;) {
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$ast&lt;/span&gt;=&lt;span class=&quot;nv&quot;&gt;$ast_&lt;/span&gt;; &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;=&lt;span class=&quot;nv&quot;&gt;$acc_&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;cond&amp;gt;&lt;/span&gt; { 
        &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;=&lt;span class=&quot;nv&quot;&gt;&amp;amp;f&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$ast&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;);
    } &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; { 
        &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;=&lt;span class=&quot;nv&quot;&gt;&amp;amp;f&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$ast&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;);
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; .. &lt;span class=&quot;nv&quot;&gt;$ast&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;elems&lt;/span&gt; - &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;  -&amp;gt; &lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt; {
            (&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$entry&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;) = 
                &lt;span class=&quot;n&quot;&gt;_traverse_ast_with_action&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$ast&lt;/span&gt;[&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;],&lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;&amp;amp;f&lt;/span&gt;);
            &lt;span class=&quot;nv&quot;&gt;$ast&lt;/span&gt;[&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;] = &lt;span class=&quot;nv&quot;&gt;$entry&lt;/span&gt;;
        }
    }
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;$ast&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;);
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;or a custom traversal:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_traverse_ast_custom&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$ast_&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$acc_&lt;/span&gt;) {
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$ast&lt;/span&gt;=&lt;span class=&quot;nv&quot;&gt;$ast_&lt;/span&gt;; &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;=&lt;span class=&quot;nv&quot;&gt;$acc_&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;cond&amp;gt;&lt;/span&gt; { 
        &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;=&amp;lt; &lt;span class=&quot;n&quot;&gt;custom&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acting&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$ast&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;&amp;gt;;
    } &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; { 
    &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;=&amp;lt; &lt;span class=&quot;n&quot;&gt;custom&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acting&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$ast&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;&amp;gt;;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; .. &lt;span class=&quot;nv&quot;&gt;$ast&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;elems&lt;/span&gt; - &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;  -&amp;gt; &lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt; {
            (&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$entry&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;) = 
                &lt;span class=&quot;n&quot;&gt;_traverse_ast_custom&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$ast&lt;/span&gt;[&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;],&lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;);
            &lt;span class=&quot;nv&quot;&gt;$ast&lt;/span&gt;[&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;] = &lt;span class=&quot;nv&quot;&gt;$entry&lt;/span&gt;;
        }
    }
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;$ast&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;);
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For the case of the parse tree data structures in my compiler, the higher-order implementation takes more than twice as long as the custom traversal, so for performance this is not a good choice. Therefore I don&amp;#39;t use higher-order functions in the parser, but I do use them in the later refactoring passes.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Result:&lt;/b&gt; Higher-order implementations of recursive descent take more than twice as long as custom traversals.&lt;/p&gt;

&lt;h3&gt;The fastest way to process a list&lt;/h3&gt;

&lt;p&gt;The internal representation of a Fortran program in my compiler is an list of &lt;code&gt;[ $src_line, $info ]&lt;/code&gt; pairs and the &lt;code&gt;$info&lt;/code&gt; hash stores the parse tree as a nested array. So iterating through lists and arrays is a major factor in the performance.  &lt;/p&gt;

&lt;p&gt;Raku has several ways to iterate through a list-like data structure. I tested six of them, as follows: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl&quot; data-lang=&quot;perl&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constant&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NITERS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2_000_000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CASE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 6.2 s&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# map&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@src&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NITERS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CASE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 7.9 s&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# for each elt in list&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@res&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;NITERS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$elt&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$elt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@src&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$elt&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$elt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CASE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 6.2 s&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# for with index&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@res&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NITERS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$elt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;@src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$elt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NITERS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$elt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;@src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;@res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$elt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CASE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 11.0&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# loop (C-style)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@res&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NITERS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$elt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;@src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$elt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$idx2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$idx2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NITERS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$idx2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$elt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;@src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$idx2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;@res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$idx2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$elt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CASE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 3.7 s&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# postfix for with push&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@src&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@res&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NITERS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CASE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 3.5 s&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# comprehension&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@src&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NITERS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@res&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The fastest way is to use list comprehension (case 5, 3.5 s), very closely followed by the suffix-style &lt;code&gt;for&lt;/code&gt; (case 4, 3.7 s). The C-style &lt;code&gt;loop&lt;/code&gt; construct (case 3) is the slowest (11 s). The &lt;code&gt;map&lt;/code&gt; version performs the same as the index-based &lt;code&gt;for&lt;/code&gt; loop (both 6.2 s). It is a bit odd that the list-based for loop, probably the most common loop construct, is slower than these two (7.9 s).&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Result:&lt;/b&gt; List comprehensions are fastest, almost twice as fast as &lt;code&gt;for&lt;/code&gt;-loops or &lt;code&gt;map&lt;/code&gt;s. C-style &lt;code&gt;loop&lt;/code&gt; is very slow.&lt;/p&gt;

&lt;h3&gt;Parsing: regular expressions, string comparisons or list operations?&lt;/h3&gt;

&lt;p&gt;Finally, we have to decide how to parse the expression string. The traditional way to build an expression parser is using a Finite State Machine, consuming one character at a time (if needed with one or more characters look-ahead) and keeping track of the identified portion of the string. This is very fast in a language such as C but in Raku I was not too sure, because in Raku a character is actually a string of length one, so every test against a character is a string comparison. On the other hand, Raku has a sophisticated regular expression engine. Yet another way is to turn the string into an array, and parse using list operations. Many possibilities to be tested:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;constant&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NITERS&lt;/span&gt; = &lt;span class=&quot;mi&quot;&gt;100_000&lt;/span&gt;;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;=&lt;span class=&quot;s&quot;&gt;&amp;#39;This means we need a stack per type of operation and run until the end of the expression&amp;#39;&lt;/span&gt;;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@chrs&lt;/span&gt; =  &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;comb&lt;/span&gt;;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;n&quot;&gt;CASE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;) { &lt;span class=&quot;c1&quot;&gt;# 5.8 s&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; .. &lt;span class=&quot;n&quot;&gt;NITERS&lt;/span&gt; -&amp;gt; &lt;span class=&quot;nv&quot;&gt;$ct&lt;/span&gt; {
&lt;span class=&quot;c1&quot;&gt;# map on an array of characters        &lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@words&lt;/span&gt;=();
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$word&lt;/span&gt;=&lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt;;
        &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;(-&amp;gt; \&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; { 
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;ne&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39; &amp;#39;&lt;/span&gt;) {
                &lt;span class=&quot;nv&quot;&gt;$word&lt;/span&gt; ~= &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;;
            } &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;nb&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@words&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$word&lt;/span&gt;;
                &lt;span class=&quot;nv&quot;&gt;$word&lt;/span&gt;=&lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt;;
            }
        }, &lt;span class=&quot;nv&quot;&gt;@chrs&lt;/span&gt;);
        &lt;span class=&quot;nb&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@words&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$word&lt;/span&gt;;
    }
} &lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CASE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; { &lt;span class=&quot;c1&quot;&gt;# 2.7 s    &lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; .. &lt;span class=&quot;n&quot;&gt;NITERS&lt;/span&gt; -&amp;gt; &lt;span class=&quot;nv&quot;&gt;$ct&lt;/span&gt; {
&lt;span class=&quot;c1&quot;&gt;# while with index through a string        &lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@words&lt;/span&gt;=();
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;=&lt;span class=&quot;s&quot;&gt;&amp;#39;This means we need a stack per type of operation and run until the end of the expression&amp;#39;&lt;/span&gt;;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;=&lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;index&lt;/span&gt;( &lt;span class=&quot;s&quot;&gt;&amp;#39; &amp;#39;&lt;/span&gt; ) {
            &lt;span class=&quot;nb&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@words&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;substr&lt;/span&gt;(&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;);
            &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; .= &lt;span class=&quot;nb&quot;&gt;substr&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;);
        }
        &lt;span class=&quot;nb&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@words&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;;
    }         
} &lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CASE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; {  &lt;span class=&quot;c1&quot;&gt;# 11.7 s&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; .. &lt;span class=&quot;n&quot;&gt;NITERS&lt;/span&gt; -&amp;gt; &lt;span class=&quot;nv&quot;&gt;$ct&lt;/span&gt; {
&lt;span class=&quot;c1&quot;&gt;# while on an array of characters        &lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@words&lt;/span&gt;=();
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@chrs_&lt;/span&gt; = &lt;span class=&quot;nv&quot;&gt;@chrs&lt;/span&gt;; 
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$word&lt;/span&gt;=&lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt;;      
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@chrs_&lt;/span&gt; {
            &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$chr&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@chrs_&lt;/span&gt;;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;$chr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;ne&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39; &amp;#39;&lt;/span&gt;) {
                &lt;span class=&quot;nv&quot;&gt;$word&lt;/span&gt;~=&lt;span class=&quot;nv&quot;&gt;$chr&lt;/span&gt;;
            } &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;nb&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@words&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$word&lt;/span&gt;;
                &lt;span class=&quot;nv&quot;&gt;$word&lt;/span&gt;=&lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt;;
            }
        }
        &lt;span class=&quot;nb&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@words&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$word&lt;/span&gt;;
    }
} &lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CASE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; { &lt;span class=&quot;c1&quot;&gt;# 101 s&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; .. &lt;span class=&quot;n&quot;&gt;NITERS&lt;/span&gt; -&amp;gt; &lt;span class=&quot;nv&quot;&gt;$ct&lt;/span&gt; {
&lt;span class=&quot;c1&quot;&gt;# while on a string using a regexp        &lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@words&lt;/span&gt;=();
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;=&lt;span class=&quot;s&quot;&gt;&amp;#39;This means we need a stack per type of operation and run until the end of the expression&amp;#39;&lt;/span&gt;;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;Bool&lt;/span&gt; {
            &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; ~~ &lt;span class=&quot;sr&quot;&gt;s/^$&amp;lt;w&amp;gt; = [ \w+ ]//&lt;/span&gt;;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;$&amp;lt;w&amp;gt;&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;Bool&lt;/span&gt;) {
                &lt;span class=&quot;nb&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@words&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$&amp;lt;w&amp;gt;&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt;;
            }
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; ~~ &lt;span class=&quot;sr&quot;&gt;s/^\s+//&lt;/span&gt;;
            } 
        }
    }   
} &lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CASE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; { &lt;span class=&quot;c1&quot;&gt;# 64 s&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; .. &lt;span class=&quot;n&quot;&gt;NITERS&lt;/span&gt; -&amp;gt; &lt;span class=&quot;nv&quot;&gt;$ct&lt;/span&gt; {
&lt;span class=&quot;c1&quot;&gt;# reduce on an array of characters        &lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;reduce&lt;/span&gt;(
        -&amp;gt; \&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; { 
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;ne&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39; &amp;#39;&lt;/span&gt;) {
                &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;[&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;],&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;[&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;] ~ &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;;
            } &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; {
                ( |&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;[&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;[&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;] ),&lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt;;
            }
        }, ((),&lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt;), |&lt;span class=&quot;nv&quot;&gt;@chrs&lt;/span&gt;);
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@words&lt;/span&gt; = |&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;[&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;],&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;[&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For the list-based version, the overhead is 1.6 s; for the string-based versions, 0.8s.&lt;/p&gt;

&lt;p&gt;The results are rather striking. Clearly the regexp version is by far the slowest. This was a surprise because in my Perl implementation, the regexp version was twice as fast as next best choice. From the other implementations, the string-based FSM which uses the &lt;code&gt;index&lt;/code&gt; and &lt;code&gt;substr&lt;/code&gt; methods is by far the fastest, without the overhead it takes 1.9s s, which is more that 50 times faster than the regexp version. The &lt;code&gt;map&lt;/code&gt; based version comes second but is nearly twice as slow. What is surprising, and actually a bit disappointing, is that the &lt;code&gt;reduce&lt;/code&gt; based version, which works the same as the &lt;code&gt;map&lt;/code&gt; based one but works on immutable data, is also very slow, 64 s. &lt;/p&gt;

&lt;p&gt;In any case, the choice is clear. It is possible to make the fastest version  marginally faster (1.6 s instead of 1.9 s) by not reducing the string but instead moving the index through the string. However, for the full parser I want to have the convenience of the &lt;code&gt;trim-leading&lt;/code&gt; and &lt;code&gt;starts-with&lt;/code&gt; methods, so I choose to consume the string.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Result:&lt;/b&gt; Using &lt;code&gt;index&lt;/code&gt; and &lt;code&gt;substr&lt;/code&gt; methods is much faster than using regexps.&lt;/p&gt;

&lt;h2&gt;A faster expression parser&lt;/h2&gt;

&lt;p&gt;With the choices of string parsing and data structure made, I focused on the structure of the overall algorithm. The basic approach is to loop trough a number of states and in every state perform a specific action. In the Perl version this was very simple because we use regular expressions to identify tokens, so most of the state transitions are implicit. I wanted to keep this structure so I emulate the regexp &lt;code&gt;s///&lt;/code&gt; operation with comparisons, indexing and substring operations.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl&quot; data-lang=&quot;perl&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$prev_lev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$lev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@ast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$op&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;c1&quot;&gt;# Match unary prefix operations&lt;/span&gt;
     &lt;span class=&quot;c1&quot;&gt;# Match terms&lt;/span&gt;
     &lt;span class=&quot;c1&quot;&gt;# Add prefix operations if matched&lt;/span&gt;
     &lt;span class=&quot;c1&quot;&gt;# Match binary operators&lt;/span&gt;
     &lt;span class=&quot;c1&quot;&gt;# Append to the AST&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The matching rules and operations are very simple (I use &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;integer&amp;gt;&lt;/code&gt; as placeholders for the actual values). Here is the Perl version for reference:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;prefix operations:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl&quot; data-lang=&quot;perl&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=~&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;s/^&amp;lt;pattern&amp;gt;//&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;&amp;lt;integer&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;terms:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl&quot; data-lang=&quot;perl&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=~&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;s/^(&amp;lt;pattern&amp;gt;)//&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$expr_ast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;&amp;lt;integer&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;operators:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl&quot; data-lang=&quot;perl&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$prev_lev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$lev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=~&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;s/^&amp;lt;pattern&amp;gt;//&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$lev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;&amp;lt;integer&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$op&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;&amp;lt;integer&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the Raku version I used the &lt;code&gt;given&lt;/code&gt;/&lt;code&gt;when&lt;/code&gt; construct, which is as fast as an &lt;code&gt;if&lt;/code&gt; statement but a bit neater.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;prefix operations:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;given&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; .&lt;span class=&quot;n&quot;&gt;starts-with&lt;/span&gt;(&lt;span class=&quot;s&quot;&gt;&amp;lt;token&amp;gt;&lt;/span&gt;) { 
        .=&lt;span class=&quot;nb&quot;&gt;substr&lt;/span&gt;(&lt;span class=&quot;s&quot;&gt;&amp;lt;length of token&amp;gt;&lt;/span&gt;); 
        &lt;span class=&quot;nv&quot;&gt;$state&amp;lt;integer&amp;gt;&lt;/span&gt;; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;terms:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;given&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; .&lt;span class=&quot;n&quot;&gt;starts-with&lt;/span&gt;(&lt;span class=&quot;s&quot;&gt;&amp;lt;token start&amp;gt;&lt;/span&gt;) { 
        &lt;span class=&quot;nv&quot;&gt;$expr_ast&lt;/span&gt;=[&lt;span class=&quot;s&quot;&gt;&amp;lt;integer&amp;gt;&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$term&lt;/span&gt;]; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;operators:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;given&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; .&lt;span class=&quot;n&quot;&gt;starts-with&lt;/span&gt;(&lt;span class=&quot;s&quot;&gt;&amp;lt;token&amp;gt;&lt;/span&gt;) { 
        .=&lt;span class=&quot;nb&quot;&gt;substr&lt;/span&gt;(&lt;span class=&quot;s&quot;&gt;&amp;lt;length of token&amp;gt;&lt;/span&gt;); 
        &lt;span class=&quot;nv&quot;&gt;$lev&lt;/span&gt;=&lt;span class=&quot;s&quot;&gt;&amp;lt;integer&amp;gt;&lt;/span&gt;; 
        &lt;span class=&quot;nv&quot;&gt;$op&lt;/span&gt;=&lt;span class=&quot;s&quot;&gt;&amp;lt;integer&amp;gt;&lt;/span&gt;; 
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;One of the more complex patterns to match is the case of an identifier followed by an opening parenthesis with optional whitespace. Using regular expressions this pattern would be:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; ~~ &lt;span class=&quot;sr&quot;&gt;s:i/^ $&amp;lt;token&amp;gt; = [ [a .. z] \w*] \s* \( //&lt;/span&gt; { 
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$var&lt;/span&gt;=&lt;span class=&quot;nv&quot;&gt;$&amp;lt;token&amp;gt;&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt;;
    ... 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Without regular expressions, we first check for a character between &amp;#39;a&amp;#39; and &amp;#39;z&amp;#39; using &lt;code&gt;&amp;#39;a&amp;#39; le .substr(0,1).lc le &amp;#39;z&amp;#39;&lt;/code&gt;. If that matches, we remove it from &lt;code&gt;$str&lt;/code&gt; and add it to &lt;code&gt;$var&lt;/code&gt;. Then we go in a &lt;code&gt;while&lt;/code&gt; loop for as long as there are characters that are alphanumeric or &amp;#39;_&amp;#39;. Then we strip any whitespace and test for &amp;#39;(&amp;#39;. &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;le&lt;/span&gt; (&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$var&lt;/span&gt; = .&lt;span class=&quot;nb&quot;&gt;substr&lt;/span&gt;(&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;)).&lt;span class=&quot;nb&quot;&gt;lc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;le&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;z&amp;#39;&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;=&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$c&lt;/span&gt; = .&lt;span class=&quot;nb&quot;&gt;substr&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;);
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;le&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$c&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;lc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;le&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;z&amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;eq&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;_&amp;#39;&lt;/span&gt; 
        &lt;span class=&quot;o&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;0&amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;le&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;le&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;9&amp;#39;&lt;/span&gt; {
        &lt;span class=&quot;nv&quot;&gt;$var&lt;/span&gt;~=&lt;span class=&quot;nv&quot;&gt;$c&lt;/span&gt;;
        &lt;span class=&quot;nv&quot;&gt;$c&lt;/span&gt; = .&lt;span class=&quot;nb&quot;&gt;substr&lt;/span&gt;(++&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;);
    }
    .=&lt;span class=&quot;nb&quot;&gt;substr&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;);
    .=&lt;span class=&quot;n&quot;&gt;trim-leading&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; .&lt;span class=&quot;n&quot;&gt;starts-with&lt;/span&gt;(&lt;span class=&quot;s&quot;&gt;&amp;#39;(&amp;#39;&lt;/span&gt;) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Another complex pattern is that for a floating point number. In Fortran, the pattern is more complicated because the sub-pattern &lt;code&gt;.e&lt;/code&gt; can be part of a floating-point constant but could also be the part of the equality operator &lt;code&gt;.eq.&lt;/code&gt;. Furthermore, the separator between the mantissa and the exponent can be not just &lt;code&gt;e&lt;/code&gt; but also &lt;code&gt;d&lt;/code&gt; or &lt;code&gt;q&lt;/code&gt;. So the regular expression is rather involved:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; (                        
    (
        !(&lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;~~&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;rx:i/^\d+\.eq/&lt;/span&gt;) &lt;span class=&quot;o&quot;&gt;and&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;~~&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;s:i/^([\d*\.\d*][[e|d|q][\-|\+]?\d+]?)//&lt;/span&gt;        
    )           
    &lt;span class=&quot;o&quot;&gt;or&lt;/span&gt; 
    &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;~~&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;s:i/^(\d*[e|d|q][\-|\+]?\d+)//&lt;/span&gt;
) {
    &lt;span class=&quot;nv&quot;&gt;$real_const_str&lt;/span&gt;=&lt;span class=&quot;vg&quot;&gt;$/&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt;;
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Without regular expression, the implementation is as follows. We first detect a character between 0 and 9 or a dot. Then we try to match the mantissa, separator, sign and exponent. The latter three are optional; if they are not present and the mantissa does not contain a dot, we have matched an integer. &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;0&amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;le&lt;/span&gt; .&lt;span class=&quot;nb&quot;&gt;substr&lt;/span&gt;(&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;o&quot;&gt;le&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;9&amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;or&lt;/span&gt; .&lt;span class=&quot;nb&quot;&gt;substr&lt;/span&gt;(&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;o&quot;&gt;eq&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;.&amp;#39;&lt;/span&gt; { 
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$sep&lt;/span&gt;=&lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$sgn&lt;/span&gt;=&lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$exp&lt;/span&gt;=&lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$real_const_str&lt;/span&gt;=&lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt;;

    &lt;span class=&quot;c1&quot;&gt;# first char of mantissa&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$mant&lt;/span&gt; = .&lt;span class=&quot;nb&quot;&gt;substr&lt;/span&gt;(&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;);
    &lt;span class=&quot;c1&quot;&gt;# try and match more chars of mantissa&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;=&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;;
    &lt;span class=&quot;nv&quot;&gt;$h&lt;/span&gt; = .&lt;span class=&quot;nb&quot;&gt;substr&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;);
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;0&amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;le&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;le&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;9&amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;eq&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;.&amp;#39;&lt;/span&gt; {
        &lt;span class=&quot;nv&quot;&gt;$mant&lt;/span&gt; ~=&lt;span class=&quot;nv&quot;&gt;$h&lt;/span&gt;;
        &lt;span class=&quot;nv&quot;&gt;$h&lt;/span&gt; = .&lt;span class=&quot;nb&quot;&gt;substr&lt;/span&gt;(++&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;);
    }
    &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; .= &lt;span class=&quot;nb&quot;&gt;substr&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;);

    &lt;span class=&quot;c1&quot;&gt;# reject .eq.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;not&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;$mant&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;ends-with&lt;/span&gt;(&lt;span class=&quot;s&quot;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;) &lt;span class=&quot;o&quot;&gt;and&lt;/span&gt; .&lt;span class=&quot;n&quot;&gt;starts-with&lt;/span&gt;(&lt;span class=&quot;s&quot;&gt;&amp;#39;eq&amp;#39;&lt;/span&gt;,:&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;)) { 
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$h&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;lc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;eq&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;e&amp;#39;&lt;/span&gt; | &lt;span class=&quot;s&quot;&gt;&amp;#39;d&amp;#39;&lt;/span&gt; | &lt;span class=&quot;s&quot;&gt;&amp;#39;q&amp;#39;&lt;/span&gt; {
            &lt;span class=&quot;c1&quot;&gt;# we found a valid separator&lt;/span&gt;
            &lt;span class=&quot;nv&quot;&gt;$sep&lt;/span&gt; = &lt;span class=&quot;nv&quot;&gt;$h&lt;/span&gt;;            
            &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;=&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;;
            &lt;span class=&quot;nv&quot;&gt;$h&lt;/span&gt; =.&lt;span class=&quot;nb&quot;&gt;substr&lt;/span&gt;(&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;);
            &lt;span class=&quot;c1&quot;&gt;# now check if there is a sign&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;eq&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;-&amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;eq&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;+&amp;#39;&lt;/span&gt; {
                ++&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;;
                &lt;span class=&quot;nv&quot;&gt;$sgn&lt;/span&gt; = &lt;span class=&quot;nv&quot;&gt;$h&lt;/span&gt;;
                &lt;span class=&quot;nv&quot;&gt;$h&lt;/span&gt; =.&lt;span class=&quot;nb&quot;&gt;substr&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;);
            }
            &lt;span class=&quot;c1&quot;&gt;# now check if there is an exponent            &lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;0&amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;le&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;le&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;9&amp;#39;&lt;/span&gt; {
                ++&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;;
                &lt;span class=&quot;nv&quot;&gt;$exp&lt;/span&gt;~=&lt;span class=&quot;nv&quot;&gt;$h&lt;/span&gt;;
                &lt;span class=&quot;nv&quot;&gt;$h&lt;/span&gt; =.&lt;span class=&quot;nb&quot;&gt;substr&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;);
            }
            &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; .= &lt;span class=&quot;nb&quot;&gt;substr&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;);
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$exp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;ne&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt; {
            &lt;span class=&quot;nv&quot;&gt;$real_const_str&lt;/span&gt;=&lt;span class=&quot;s&quot;&gt;&amp;quot;$mant$sep$sgn$exp&amp;quot;&lt;/span&gt;;
            &lt;span class=&quot;nv&quot;&gt;$expr_ast&lt;/span&gt;=[&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$real_const_str&lt;/span&gt;];
            } &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;c1&quot;&gt;# parse error&lt;/span&gt;
            }
        } &lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;index&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$mant&lt;/span&gt;,&lt;span class=&quot;s&quot;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;).&lt;span class=&quot;nb&quot;&gt;Bool&lt;/span&gt; {
            &lt;span class=&quot;c1&quot;&gt;# a mantissa-only real number&lt;/span&gt;
            &lt;span class=&quot;nv&quot;&gt;$real_const_str&lt;/span&gt;=&lt;span class=&quot;nv&quot;&gt;$mant&lt;/span&gt;;
            &lt;span class=&quot;nv&quot;&gt;$expr_ast&lt;/span&gt;=[&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$real_const_str&lt;/span&gt;];
        }
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;c1&quot;&gt;# no dot and no sep, so an integer&lt;/span&gt;
            &lt;span class=&quot;nv&quot;&gt;$expr_ast&lt;/span&gt;=[&lt;span class=&quot;mi&quot;&gt;29&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$mant&lt;/span&gt;];   
        }
    } &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;c1&quot;&gt;# .eq., backtrack and carry on&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; =&lt;span class=&quot;s&quot;&gt;&amp;quot;$mant$str&amp;quot;&lt;/span&gt;;        
        &lt;span class=&quot;n&quot;&gt;proceed&lt;/span&gt;;
    }            
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A final example of how to handle patterns is the case of whitespace in comparison and logical operators. Fortran has operators of the form &lt;code&gt;&amp;lt;dot word dot&amp;gt;&lt;/code&gt;, for example &lt;code&gt;.lt.&lt;/code&gt; and &lt;code&gt;.xor.&lt;/code&gt;. But annoyingly, it allows whitespace between the dot and the word, e.g. &lt;code&gt;. not .&lt;/code&gt;. Using regular expressions, this is of course easy to handle, for example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;~~&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;s/^\.\s*ge\s*\.//&lt;/span&gt;) {
    &lt;span class=&quot;nv&quot;&gt;$lev&lt;/span&gt;=&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;;
    &lt;span class=&quot;nv&quot;&gt;$op&lt;/span&gt;=&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;;
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I check for a pattern starting with a dot and which contains a space before the next dot. Then I remove all spaces from that substring using &lt;code&gt;trans&lt;/code&gt; and replace this original string with this trimmed version. &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; .&lt;span class=&quot;n&quot;&gt;starts-with&lt;/span&gt;(&lt;span class=&quot;s&quot;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;) &lt;span class=&quot;o&quot;&gt;and&lt;/span&gt;  .&lt;span class=&quot;nb&quot;&gt;index&lt;/span&gt;( &lt;span class=&quot;s&quot;&gt;&amp;#39; &amp;#39;&lt;/span&gt; ) 
    &lt;span class=&quot;o&quot;&gt;and&lt;/span&gt; (.&lt;span class=&quot;nb&quot;&gt;index&lt;/span&gt;( &lt;span class=&quot;s&quot;&gt;&amp;#39; &amp;#39;&lt;/span&gt; ) &amp;lt; (&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$eidx&lt;/span&gt; = .&lt;span class=&quot;nb&quot;&gt;index&lt;/span&gt;(&lt;span class=&quot;s&quot;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; ))) {

    &lt;span class=&quot;c1&quot;&gt;# Find the keyword with spaces&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$match&lt;/span&gt; = .&lt;span class=&quot;nb&quot;&gt;substr&lt;/span&gt;(&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$eidx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;);
    &lt;span class=&quot;c1&quot;&gt;# remove the spaces&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$match&lt;/span&gt; .= &lt;span class=&quot;n&quot;&gt;trans&lt;/span&gt;( &lt;span class=&quot;s&quot;&gt;&amp;#39; &amp;#39;&lt;/span&gt; =&amp;gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt; );
    &lt;span class=&quot;c1&quot;&gt;# update the string&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; = &lt;span class=&quot;nv&quot;&gt;$match&lt;/span&gt; ~ .&lt;span class=&quot;nb&quot;&gt;substr&lt;/span&gt;( &lt;span class=&quot;nv&quot;&gt;$eidx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;);
    &lt;span class=&quot;n&quot;&gt;proceed&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Overall the optimised expression parser in Raku is still very close to the Perl version. The key difference is that the Raku version does not use regular expressions. With the above examples I wanted to illustrate how it is possible to write code with the same functionality as a regular expression &lt;code&gt;s///&lt;/code&gt; operation, using some of Raku&amp;#39;s built-in string operations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;substr&lt;/code&gt; : substring&lt;/li&gt;
&lt;li&gt;&lt;code&gt;index&lt;/code&gt; : location a a substring in a string&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trim-leading&lt;/code&gt; : strip leading whitespace&lt;/li&gt;
&lt;li&gt;&lt;code&gt;starts-with&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ends-with&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trans&lt;/code&gt; : used to remove whitespace using the &lt;code&gt;&amp;#39; &amp;#39; =&amp;gt; &amp;#39;&amp;#39;&lt;/code&gt; pattern&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lc&lt;/code&gt; : used in range tests instead of testing against both upper and lower case&lt;/li&gt;
&lt;li&gt;&lt;code&gt;le&lt;/code&gt;, &lt;code&gt;lt&lt;/code&gt;, &lt;code&gt;ge&lt;/code&gt;, &lt;code&gt;gt&lt;/code&gt;: for very handy range comparisons, e.g. &lt;code&gt;&amp;#39;a&amp;#39; le $str le &amp;#39;z&amp;#39;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The resulting code is of course much longer but arguably more readable than regular expressions, and currently four times faster.&lt;/p&gt;

&lt;p&gt;I ran a lot more tests, and compared performance against Perl and Python as well, but that is another story. All code for the tests is available in &lt;a href=&quot;https://github.com/wimvanderbauwhede/raku-examples/tree/master/Performance-analysis&quot;&gt;my GitHub repo&lt;/a&gt;.&lt;/p&gt;

&lt;!-- Operators have precedence and associativity, and Fortran requires twelve precedence levels. In the &quot;Append to AST&quot; state, the parser uses `$lev` and `$prev_lev` to work out how the previously matched `$expr_ast` and `$op` should be appended to the `@ast` array. The prefix operations are handled by setting a state which is checked after term matching. The actual code is a bit more complicated because we need to parse array index expressions and function calls as well. This is done recursively during term matching; if a function call has multiple arguments, the parser is put into a new `$state`. 

So the end result is a minimally recursive parser, i.e. it only uses recursion when it is really necessary. 

There is a lot of repetition of the patterns for matching terms and operators because if I would instead abstract the `&lt;pattern&gt;` and `&lt;integer&gt;` values by e.g. storing them in an array, the array accesses would considerably reduce the performance. I do store the precedence levels in an array because there are so many of them that the logic for appending terms to the AST would otherwise become very hard to read and update. --&gt;

&lt;!-- ## Expression parser performance

I tested the new expression parser on a set of 50 different expressions taken from a weather simulation code. The old expression parser takes 45 s to run this test a thousand times; the new expression parser takes only 2 s. In other words, the new parser is *more than twenty times faster* than the old one. 

It is also quite easy to maintain and adapt despite its minimal use of abstractions, and because it is Fortran-specific, the rest of the code has become a lot cleaner too. You can find the code in [my GitHub repo](https://github.com/wimvanderbauwhede/RefactorF4Acc/blob/devel/RefactorF4Acc/Parser/Expressions.pm). --&gt;

&lt;!-- Here is a summary of all optimisations I tested. The tests were run using Perl v5.28 on a MacBook Pro (late 2013), timings are averages over 5 runs and measured using `time`.

&lt;table&gt;
  &lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;
Optimisation
&lt;/th&gt;
&lt;th&gt;
Speed-up
&lt;/th&gt;

&lt;/tr&gt;
  &lt;/thead&gt;
   &lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; Hash key testing is faster than regexp matching &lt;/td&gt;&lt;td&gt; 3&amp;times; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; Custom tree traversals are faster than generic ones &lt;/td&gt;&lt;td&gt; 2&amp;times; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; `foreach` is faster than `map` &lt;/td&gt;&lt;td&gt; 1.3&amp;times; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; `foreach` is faster than indexed `for` &lt;/td&gt;&lt;td&gt; 1.4&amp;times; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; `foreach` is faster than C-style `for` &lt;/td&gt;&lt;td&gt; 1.7&amp;times; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; Integer comparison is faster than string comparison &lt;/td&gt;&lt;td&gt; 1.5&amp;times; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; Regexp matching is faster than successive string comparisons &lt;/td&gt;&lt;td&gt; 2.2&amp;times; &lt;/td&gt;
&lt;/tr&gt;

 &lt;/tbody&gt;
&lt;table&gt; --&gt;

        </content>
    </entry>
    
    <entry>
        <title>Reconstructing Raku's Junctions</title>
        <link href="https://wimvanderbauwhede.github.io/articles/reconstructing-raku-junctions/"/>
        <updated>2020-10-05T00:00:00+01:00</updated>
        <id>https://wimvanderbauwhede.github.io/articles/reconstructing-raku-junctions</id>
        <author>
					<name>Wim Vanderbauwhede</name>
					<uri>https://wimvanderbauwhede.github.io/</uri>
					
				</author>
        <content type="html">
        	&lt;img src=&quot;https://wimvanderbauwhede.github.io/images/reconstructing-raku-junctions_1600x600.jpg&quot;&gt;&lt;br/&gt;
        	&lt;p&gt;Junctions in Raku are cool but at first glance they do not follow the rules for static typing. I was curious about their formal typing semantics, so I deconstructed and then reconstructed junctions from a functional, static typing perspective.&lt;/p&gt;

&lt;p&gt;If you don&amp;#39;t know Raku or are unfamiliar with the functional style of programming, I suggest you read my introductory article &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/decluttering-with-functional-programming&quot;&gt;&amp;quot;Cleaner code with functional programming&amp;quot;&lt;/a&gt;. If you have not heard of algebraic data types before, I suggest my article &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/roles-as-adts-in-raku&quot;&gt;&amp;quot;Roles as Algebraic Data Types in Raku&amp;quot;&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Junctions in Raku&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://raku.org/&quot;&gt;Raku&lt;/a&gt; has this neat feature called &lt;a href=&quot;https://docs.raku.org/&quot;&gt;Junctions&lt;/a&gt;. A junction is an unordered composite value. When a junction is used instead of a value, the operation is carried out for each junction element, and the result is the junction of the return values of all those operators. Junctions collapse into a single value when used in a Boolean context. Junctions can be of type &lt;em&gt;all&lt;/em&gt; (&lt;code&gt;&amp;amp;&lt;/code&gt;), &lt;em&gt;any&lt;/em&gt; (&lt;code&gt;|&lt;/code&gt;), &lt;em&gt;one&lt;/em&gt; (&lt;code&gt;^&lt;/code&gt;) or &lt;em&gt;none&lt;/em&gt; (empty junction).&lt;/p&gt;

&lt;p&gt;For example, &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$j&lt;/span&gt; = &lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;# short for any(11,22)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;33&lt;/span&gt; == &lt;span class=&quot;nv&quot;&gt;$j&lt;/span&gt; + &lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt; {
    &lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;yes&amp;#39;&lt;/span&gt;;
}

&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;so&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; == (&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;).&lt;span class=&quot;nb&quot;&gt;one&lt;/span&gt;;         &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; True &lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;so&lt;/span&gt; (&lt;span class=&quot;s&quot;&gt;&amp;quot;a&amp;quot;&lt;/span&gt; ^ &lt;span class=&quot;s&quot;&gt;&amp;quot;b&amp;quot;&lt;/span&gt; ^ &lt;span class=&quot;s&quot;&gt;&amp;quot;c&amp;quot;&lt;/span&gt;) &lt;span class=&quot;o&quot;&gt;eq&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;a&amp;quot;&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; True&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The function &lt;code&gt;so&lt;/code&gt; forces the Boolean context.&lt;/p&gt;

&lt;p&gt;Junctions have type &lt;em&gt;Junction&lt;/em&gt;, and I was curious about the typing rules, because at first sight there is something strange. Let&amp;#39;s say we have a function &lt;code&gt;sq&lt;/code&gt; from &lt;em&gt;Int&lt;/em&gt; to &lt;em&gt;Int&lt;/em&gt; :&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sq&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt;) { &lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt;*&lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt; }

&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$res&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;sq&lt;/span&gt;(&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;); &lt;span class=&quot;c1&quot;&gt;# OK&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$res&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; 121 &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now let&amp;#39;s define a junction of type &lt;em&gt;any&lt;/em&gt; of &lt;em&gt;Int&lt;/em&gt; values:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Junction&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$j&lt;/span&gt; = &lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt; | &lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When we apply &lt;code&gt;sq&lt;/code&gt; to &lt;code&gt;$j&lt;/code&gt;, we do not get a type error, even though the functions has type &lt;code&gt;:(Int --&amp;gt; Int)&lt;/code&gt; and the junction has type &lt;code&gt;Junction&lt;/code&gt;. Instead, we get a junction of the results:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sq&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$j&lt;/span&gt;); &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; any(121, 484)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we assign this to a variable of type &lt;em&gt;Int&lt;/em&gt; as before, we get a type error:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$rj&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;sq&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$j&lt;/span&gt;); &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; Type check failed in assignment to $rj; expected Int but got Junction (any(121, 484))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Instead, the return value is now of type &lt;em&gt;Junction&lt;/em&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;my Junction $rj = sq(11|22); # OK
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So the &lt;em&gt;Junction&lt;/em&gt; type can take the place of any other type but then the operation becomes a junction as well.&lt;/p&gt;

&lt;p&gt;On the other hand, junctions are implicitly typed by their constituent values, even though they seem to be of the opaque type &lt;em&gt;Junction&lt;/em&gt;. For example, if we create a junction of &lt;em&gt;Str&lt;/em&gt; values, and try to pass this junction value into &lt;code&gt;sq&lt;/code&gt;, we get a type error:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$sj&lt;/span&gt; = &lt;span class=&quot;s&quot;&gt;&amp;#39;11&amp;#39;&lt;/span&gt; | &lt;span class=&quot;s&quot;&gt;&amp;#39;22&amp;#39;&lt;/span&gt;;
&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$sj&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;WHAT&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt;(Junction)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Junction&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$svj&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;sq&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$sj&lt;/span&gt;); &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; Type check failed in binding to parameter &amp;#39;x&amp;#39;; expected Int but got Str (&amp;quot;11&amp;quot;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Do junctions follow static typing rules?&lt;/h2&gt;

&lt;p&gt;Although this &lt;em&gt;kind of&lt;/em&gt; makes sense (we don&amp;#39;t want it to work with &lt;em&gt;Str&lt;/em&gt; if the original function expects &lt;em&gt;Int&lt;/em&gt;), this does flout the rules for static typing, even with subtyping. If an argument is of type &lt;em&gt;Int&lt;/em&gt; then any type below it in the type graph can be used instead. But the simplified type graph for &lt;em&gt;Int&lt;/em&gt; and &lt;em&gt;Junction&lt;/em&gt; is as follows:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Int -&amp;gt; Cool -&amp;gt; Any -&amp;gt; Mu &amp;lt;- Junction
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So a &lt;em&gt;Junction&lt;/em&gt; is never a subtype of anything below &lt;em&gt;Any&lt;/em&gt;. Therefore putting a junction in a slot of type &lt;em&gt;Any&lt;/em&gt; or subtype thereof should be a type error.&lt;/p&gt;

&lt;p&gt;Furthermore, because the &lt;em&gt;Junction&lt;/em&gt; type is opaque (i.e. it is not a parametrised type), it should not hold any information about the type of the values inside the junction. And yet it does type check against these invisible, inaccessible values. &lt;/p&gt;

&lt;p&gt;So what is happening here? &lt;/p&gt;

&lt;h2&gt;A working hypothesis&lt;/h2&gt;

&lt;p&gt;A working hypothesis is that a &lt;em&gt;Junction&lt;/em&gt; type does not really take the place of any other type: it is merely a syntactic sugar that makes it seem so.&lt;/p&gt;

&lt;h2&gt;Reconstructing junctions part 1: types&lt;/h2&gt;

&lt;p&gt;Let&amp;#39;s try and reconstruct this. The aim is to come up with a data type and some actions that will replicate the observed behaviour of Raku&amp;#39;s junctions.
First we discuss the types, using Haskell notation for clarity. Then I present the implementation in Raku. This implementation will behave like Raku&amp;#39;s native junctions but without the magic syntactic sugar. In this way I show that Raku&amp;#39;s junctions do follow proper typing rules after all.&lt;/p&gt;

&lt;h3&gt;The Junction type&lt;/h3&gt;

&lt;p&gt;A &lt;em&gt;Junction&lt;/em&gt; is a data structure consisting of a junction type &lt;em&gt;JType&lt;/em&gt; and a set of values. 
I restrict this set of values to a single type for convenience and also because a junction of mixed types does actually not make much sense. I use a list to model the set, again for convenience. Because a &lt;em&gt;Junction&lt;/em&gt; can contain values of any type, it is a polymorphic algebraic data type:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;JType&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;JAny&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;JAll&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;JOne&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;JNone&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Junction&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Junction&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;JType&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Applying junctions&lt;/h3&gt;

&lt;p&gt;Doing anything with a junction means applying a function to it. We can consider three cases, and I introduce an ad-hoc custom operator for each of them:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Apply a non-&lt;em&gt;Junction&lt;/em&gt; function to a &lt;em&gt;Junction&lt;/em&gt; expression&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;•￮&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Junction&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;Junction&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Apply a &lt;em&gt;Junction&lt;/em&gt; function to a non-&lt;em&gt;Junction&lt;/em&gt; expression&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;￮•&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;Junction&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Junction&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Apply a &lt;em&gt;Junction&lt;/em&gt; function to a &lt;em&gt;Junction&lt;/em&gt; expression, creating a nested junction&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;￮￮&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;Junction&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Junction&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Junction&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Junction&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For convenience, we can also create custom comparison operators between &lt;em&gt;Junction a&lt;/em&gt; and &lt;em&gt;a&lt;/em&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;-- and similar for /-, &amp;gt;, &amp;lt;, &amp;lt;=,&amp;gt;=&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;￮&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;•&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Junction&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Collapsing junctions&lt;/h3&gt;

&lt;p&gt;Then we have &lt;code&gt;so&lt;/code&gt;, the Boolean coercion function. What it does is to collapse a junction of Booleans into a single Boolean. &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;so&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Junction&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Finally we have &lt;code&gt;collapse&lt;/code&gt;, which returns the value from a junction, provided that it is a junction where all stored values are the same. &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;collapse&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Show&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Eq&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Junction&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This may seem like a strange function but it is necessary because of the behaviour of junctions. As we will see, the above semantics imply that junctions are greedy: if a single argument of a function is a junction, then all other arguments also become junctions, but all values in the junction are identical. I have discussed this in &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/greedy-junctions&quot;&gt;&amp;quot;The strange case of the greedy junction&amp;quot;&lt;/a&gt;, but we can now formalise this behaviour.&lt;/p&gt;

&lt;h3&gt;Revisiting the strange case of the greedy junction&lt;/h3&gt;

&lt;p&gt;Suppose we have a function of two arguments &lt;code&gt;f :: a -&amp;gt; b -&amp;gt; c&lt;/code&gt;, and we apply a junction &lt;code&gt;j :: Junction a&lt;/code&gt; to the first argument, &lt;code&gt;f •￮ j&lt;/code&gt;. Then the result is a partially applied function wrapped in a Junction: &lt;code&gt;fp :: Junction b -&amp;gt; c&lt;/code&gt;. If we now want to apply this function a non-Junction value &lt;code&gt;v :: b&lt;/code&gt; using &lt;code&gt;fp ￮• v&lt;/code&gt;, the result is of type &lt;code&gt;Junction c&lt;/code&gt;. So already we see that the non-Junction value &lt;code&gt;v&lt;/code&gt; is assimilated into the junction.&lt;/p&gt;

&lt;p&gt;Now, let&amp;#39;s consider the particular case where the type &lt;code&gt;c&lt;/code&gt; is &lt;code&gt;forall d . (a -&amp;gt; b -&amp;gt; d) -&amp;gt; d&lt;/code&gt;, so we have &lt;code&gt;Junction (forall d . (a-&amp;gt;b-&amp;gt;d) -&amp;gt; d)&lt;/code&gt;. This is a function which takes a function argument and returns something of the return type of that function. We use the &lt;code&gt;forall&lt;/code&gt; so that &lt;code&gt;d&lt;/code&gt; can be anything, but in practice we want it to be either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s assume we apply this function (call it &lt;code&gt;p&lt;/code&gt;) to &lt;code&gt;fst :: a-&amp;gt;b-&amp;gt;a&lt;/code&gt;, using &lt;code&gt;p ￮• fst&lt;/code&gt;, then we get &lt;code&gt;Junction a&lt;/code&gt;. But if we apply it to &lt;code&gt;snd :: a-&amp;gt;b-&amp;gt;b&lt;/code&gt;, using &lt;code&gt;p ￮• snd&lt;/code&gt;, then we get &lt;code&gt;Junction b&lt;/code&gt;. Recall that we applied the original function &lt;code&gt;f&lt;/code&gt; to a &lt;code&gt;Junction a&lt;/code&gt; and a non-Junction &lt;code&gt;b&lt;/code&gt;. Yet whatever we do, we can&amp;#39;t recover the &lt;code&gt;b&lt;/code&gt;. The result is always wrapped in a junction. &lt;/p&gt;

&lt;p&gt;This is the formal type-based analysis of why we can&amp;#39;t return a non-Junction value from a pair as explained in &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/greedy-junctions&quot;&gt;&amp;quot;The strange case of the greedy junction&amp;quot;&lt;/a&gt;. And this is why we need the &lt;code&gt;collapse&lt;/code&gt; function.&lt;/p&gt;

&lt;h2&gt;Reconstructing junctions part 2: Raku implementation&lt;/h2&gt;

&lt;p&gt;We start by creating the Junction type, using an enum for the four types of junctions, and a role for the actual &lt;em&gt;Junction&lt;/em&gt; data type:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# The types of Junctions&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JType&lt;/span&gt; &amp;lt;&lt;span class=&quot;n&quot;&gt;JAny&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;JAll&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;JOne&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;JNone&lt;/span&gt; &amp;gt;;

&lt;span class=&quot;c1&quot;&gt;# The actual Junction type&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Junction&lt;/span&gt;[\&lt;span class=&quot;n&quot;&gt;jt&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;@vs&lt;/span&gt;] {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JType&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.junction-type&lt;/span&gt;=&lt;span class=&quot;n&quot;&gt;jt&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@.values&lt;/span&gt;=&lt;span class=&quot;nv&quot;&gt;@vs&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Next, the constructors for the four types of junctions (underscore to avoid the name conflict with the builtins):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;our&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;all_&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;@vs&lt;/span&gt;) {
    &lt;span class=&quot;nb&quot;&gt;Junction&lt;/span&gt;[ &lt;span class=&quot;n&quot;&gt;JAll&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;@vs&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
}

&lt;span class=&quot;k&quot;&gt;our&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;any_&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;@vs&lt;/span&gt;) {
    &lt;span class=&quot;nb&quot;&gt;Junction&lt;/span&gt;[ &lt;span class=&quot;n&quot;&gt;JAny&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;@vs&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
}

&lt;span class=&quot;k&quot;&gt;our&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;one_&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;@vs&lt;/span&gt;) {
    &lt;span class=&quot;nb&quot;&gt;Junction&lt;/span&gt;[ &lt;span class=&quot;n&quot;&gt;JOne&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;@vs&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
}

&lt;span class=&quot;k&quot;&gt;our&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;none_&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;@vs&lt;/span&gt;) {
    &lt;span class=&quot;nb&quot;&gt;Junction&lt;/span&gt;[ &lt;span class=&quot;n&quot;&gt;JNone&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;@vs&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To apply a (single-argument) function to a junction argument&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;infix:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;lt;●○&amp;gt;&lt;/span&gt;( &lt;span class=&quot;nv&quot;&gt;&amp;amp;f&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; ) &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;jt&lt;/span&gt;=&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;junction-type&lt;/span&gt;; 
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@vs&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;values&lt;/span&gt;;

    &lt;span class=&quot;nb&quot;&gt;Junction&lt;/span&gt;[ &lt;span class=&quot;n&quot;&gt;jt&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;( {&lt;span class=&quot;nv&quot;&gt;&amp;amp;f&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;)}, &lt;span class=&quot;nv&quot;&gt;@vs&lt;/span&gt;)].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To apply a function inside a junction to a non-junction an argument&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;infix:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;lt;○●&amp;gt;&lt;/span&gt;( \&lt;span class=&quot;n&quot;&gt;jf&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; ) &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;jt&lt;/span&gt;=&lt;span class=&quot;n&quot;&gt;jf&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;junction-type&lt;/span&gt;; 
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@fs&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;jf&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;values&lt;/span&gt;;

    &lt;span class=&quot;nb&quot;&gt;Junction&lt;/span&gt;[ &lt;span class=&quot;n&quot;&gt;jt&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;( {&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;( &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;)}, &lt;span class=&quot;nv&quot;&gt;@fs&lt;/span&gt;)].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To apply a function to two junction arguments is equivalent to applying a function inside a junction to a junction. There is a complication here: Raku imposes an ordering on the nesting such that &lt;code&gt;all&lt;/code&gt; is always the outer nest. Therefore we must check the types of the junctions and swap the maps if required. &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;infix:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;lt;○○&amp;gt;&lt;/span&gt;( \&lt;span class=&quot;n&quot;&gt;jf&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;jv&lt;/span&gt; ) &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;jft&lt;/span&gt;= &lt;span class=&quot;n&quot;&gt;jf&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;junction-type&lt;/span&gt;; 
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@fs&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;jf&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;values&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;jvt&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;jv&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;junction-type&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@vs&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;jv&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;values&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;n&quot;&gt;jvt&lt;/span&gt; == &lt;span class=&quot;n&quot;&gt;JAll&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jft&lt;/span&gt; != &lt;span class=&quot;n&quot;&gt;JAll&lt;/span&gt;) {        
        &lt;span class=&quot;nb&quot;&gt;Junction&lt;/span&gt;[ &lt;span class=&quot;n&quot;&gt;jvt&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;( &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (\&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;){&lt;span class=&quot;n&quot;&gt;jf&lt;/span&gt; ○● &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;}, &lt;span class=&quot;nv&quot;&gt;@vs&lt;/span&gt;)].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;  
    } &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; {        
        &lt;span class=&quot;nb&quot;&gt;Junction&lt;/span&gt;[ &lt;span class=&quot;n&quot;&gt;jft&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;( &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;&amp;amp;f&lt;/span&gt;){ &lt;span class=&quot;nv&quot;&gt;&amp;amp;f&lt;/span&gt; ●○ &lt;span class=&quot;n&quot;&gt;jv&lt;/span&gt;}, &lt;span class=&quot;nv&quot;&gt;@fs&lt;/span&gt;)].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For completeness, here is the definition of &lt;code&gt;○==●&lt;/code&gt;. Definitions of &lt;code&gt;○!=●&lt;/code&gt;, &lt;code&gt;○&amp;gt;●&lt;/code&gt;. etc are analogous.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;infix:&lt;/span&gt;&amp;lt; ○==● &amp;gt;( \&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; ) &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (\&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;){&lt;span class=&quot;o&quot;&gt;x==&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;} ●○ &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Next we have &lt;code&gt;so&lt;/code&gt;, which turns a junction of Booleans into a Boolean:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;our&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;so&lt;/span&gt; (\&lt;span class=&quot;n&quot;&gt;jv&lt;/span&gt;) { 
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@vs&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;jv&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;values&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;given&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jv&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;junction-type&lt;/span&gt; {
        &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JAny&lt;/span&gt; { &lt;span class=&quot;nb&quot;&gt;elems&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; {&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;},  &lt;span class=&quot;nv&quot;&gt;@vs&lt;/span&gt;) &amp;gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;}
        &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JAll&lt;/span&gt; { &lt;span class=&quot;nb&quot;&gt;elems&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; {!&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;}, &lt;span class=&quot;nv&quot;&gt;@vs&lt;/span&gt;)==&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;}
        &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JOne&lt;/span&gt; { &lt;span class=&quot;nb&quot;&gt;elems&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; {&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;},  &lt;span class=&quot;nv&quot;&gt;@vs&lt;/span&gt;)==&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;}
        &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JOne&lt;/span&gt; { &lt;span class=&quot;nb&quot;&gt;elems&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; {&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;},  &lt;span class=&quot;nv&quot;&gt;@vs&lt;/span&gt;)==&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;}
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And finally we have &lt;code&gt;collapse&lt;/code&gt;, as defined in &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/greedy-junctions&quot;&gt;the article on greedy junctions&lt;/a&gt;. &lt;code&gt;collapse&lt;/code&gt; returns the value form a junction provided they are all the same:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;our&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;collapse&lt;/span&gt;( \&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; ) {
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;jt&lt;/span&gt;=&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;junction-type&lt;/span&gt;; 
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@vvs&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;values&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$v&lt;/span&gt; =  &lt;span class=&quot;nb&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@vvs&lt;/span&gt;;        
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@ts&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; {!(&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt; ~~ &lt;span class=&quot;nv&quot;&gt;$v&lt;/span&gt;)}, &lt;span class=&quot;nv&quot;&gt;@vvs&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;@ts&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;elems&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;) {  
        &lt;span class=&quot;nv&quot;&gt;$v&lt;/span&gt;
    } &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; {
        &lt;span class=&quot;k&quot;&gt;die&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;Can&amp;#39;t collapse this Junction: elements are not identical: {$v,@vvs}&amp;quot;&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Junctions desugared&lt;/h2&gt;

&lt;p&gt;Let&amp;#39;s now look at our working hypothesis again, the interpretation of actions on Raku&amp;#39;s junctions as syntactic sugar for the above type and operators.  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sq&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt;) { &lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt;*&lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt; }
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Junction&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$j&lt;/span&gt; = &lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt; | &lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;; 
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Junction&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$rj&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;sq&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$j&lt;/span&gt;); 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Desugared this becomes:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Junction&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;any_&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Junction&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rj&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sq&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;●○&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Similarly, &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;$j&lt;/span&gt; == &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;) {...} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;becomes&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;if (so ($j ○==● 42)) {...}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and similar for other Boolean contexts. &lt;/p&gt;

&lt;p&gt;If we look closer at &lt;a href=&quot;https://wimvanderbauwhede.github.io/greedy-junctions&quot;&gt;the pair example from the greedy junctions article&lt;/a&gt;, then applying a junction to a function with multiple arguments &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Junction&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;p1j&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;pair&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;,(&lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;43&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is desugared as&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Junction&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;p1j&lt;/span&gt; = &lt;span class=&quot;nv&quot;&gt;&amp;amp;pair&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;assuming&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;) ●○ &lt;span class=&quot;n&quot;&gt;one_&lt;/span&gt; [&lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;43&lt;/span&gt;];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We use &lt;code&gt;.assuming()&lt;/code&gt; because we need partial application. It does not matter whether we apply first the non-junction argument or the junction argument:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;p1jr&lt;/span&gt; = ( &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;$y&lt;/span&gt;){ &lt;span class=&quot;nv&quot;&gt;&amp;amp;pair&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;assuming&lt;/span&gt;(*,&lt;span class=&quot;nv&quot;&gt;$y&lt;/span&gt;) } ●○ &lt;span class=&quot;n&quot;&gt;one_&lt;/span&gt; [&lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;43&lt;/span&gt;] ) ○● &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Finally, an example where both arguments are junctions. Because of the definition of &lt;code&gt;○○&lt;/code&gt;, the order of application does not matter.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;m(\x,\y)&lt;/span&gt;{&lt;span class=&quot;o&quot;&gt;x*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;}

&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;p4&lt;/span&gt; = ( &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (\&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;){ &lt;span class=&quot;nv&quot;&gt;&amp;amp;m&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;assuming&lt;/span&gt;(&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;) } ●○ &lt;span class=&quot;n&quot;&gt;any_&lt;/span&gt; [&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;] ) ○○ &lt;span class=&quot;n&quot;&gt;all_&lt;/span&gt; [&lt;span class=&quot;mi&quot;&gt;33&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;44&lt;/span&gt;];
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;p4r&lt;/span&gt; = ( &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (\&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;){ &lt;span class=&quot;nv&quot;&gt;&amp;amp;m&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;assuming&lt;/span&gt;(*,&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;) } ●○ &lt;span class=&quot;n&quot;&gt;all_&lt;/span&gt; [&lt;span class=&quot;mi&quot;&gt;33&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;44&lt;/span&gt;] ) ○○ &lt;span class=&quot;n&quot;&gt;any_&lt;/span&gt; [&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Starting from the hypothesis that the magic typing behaviour of Raku&amp;#39;s junctions is actually syntactic sugar, I have reconstructed the Junction type and its actions using a polymorphic algebraic data type operating on functions via a set of higher-order functions. I have shown that the interpretation of Raku&amp;#39;s behaviour as syntactic sugar holds for the presented implementation. In other words, Raku&amp;#39;s Junctions do follow static typing rules.&lt;/p&gt;

        </content>
    </entry>
    
    <entry>
        <title>The strange case of the greedy junction</title>
        <link href="https://wimvanderbauwhede.github.io/articles/greedy-junctions/"/>
        <updated>2020-10-04T00:00:00+01:00</updated>
        <id>https://wimvanderbauwhede.github.io/articles/greedy-junctions</id>
        <author>
					<name>Wim Vanderbauwhede</name>
					<uri>https://wimvanderbauwhede.github.io/</uri>
					
				</author>
        <content type="html">
        	&lt;img src=&quot;https://wimvanderbauwhede.github.io/images/greedy-junctions_1600x600.jpg&quot;&gt;&lt;br/&gt;
        	&lt;p&gt;&lt;a href=&quot;https://raku.org/&quot;&gt;Raku&lt;/a&gt; has a neat feature called &lt;a href=&quot;https://docs.raku.org/type/Junction&quot;&gt;Junctions&lt;/a&gt;. In this short article I want to highlight a peculiar consequence of the interaction of junctions with functions: they are &lt;em&gt;greedy&lt;/em&gt;, by which I mean that they inadvertently turn other arguments of functions into junctions. &lt;/p&gt;

&lt;p&gt;If you don&amp;#39;t know Raku or are unfamiliar with the functional style of programming, I suggest you read my introductory article &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/decluttering-with-functional-programming&quot;&gt;&amp;quot;Cleaner code with functional programming&amp;quot;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To illustrate the greedy behaviour, let&amp;#39;s create a &lt;code&gt;pair&lt;/code&gt; data structure that can take two values of different types, using a closure.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Pair Constructor: the arguments of pair() are captured&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# in a closure that is returned&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;pair&lt;/span&gt;(\&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;) {
    &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;&amp;amp;p&lt;/span&gt;){ &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;(&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;) } 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So &lt;code&gt;pair&lt;/code&gt; takes two arguments of arbitrary type and returns a closure which takes a function as argument. We will use this function to access the values stored in the pair. I will call these accessor functions &lt;code&gt;fst&lt;/code&gt; and &lt;code&gt;snd&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Accessors to get the values from the closure&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fst&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;&amp;amp;p&lt;/span&gt;) {&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;( &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (\&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;,\&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;){&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;})}
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;snd&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;&amp;amp;p&lt;/span&gt;) {&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;( &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (\&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;,\&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;){&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;})}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The function that does the actual selection is the anonymous subroutine returned by &lt;code&gt;fst&lt;/code&gt; and &lt;code&gt;snd&lt;/code&gt;, this is purely so that I can apply them to the pair rather than have to pass them as an argument. Let&amp;#39;s look at an example, a pair of an &lt;code&gt;Int&lt;/code&gt; and an &lt;code&gt;enum RGB&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RGB&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;R G B&amp;gt;&lt;/span&gt;;

&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;pair&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; ( &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt; == &lt;span class=&quot;n&quot;&gt;fst&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;) {
    &lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;snd&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; says &amp;quot;R&amp;quot;&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So we create a pair by calling &lt;code&gt;pair&lt;/code&gt; with two values, and use &lt;code&gt;fst&lt;/code&gt; and &lt;code&gt;snd&lt;/code&gt; to access the values in the pair. This is an immutable data structure so updates are not possible.&lt;/p&gt;

&lt;p&gt;Now let&amp;#39;s use a junction for one of the arguments.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Example instance with a &amp;#39;one&amp;#39;-type junction&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Junction&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;p1j&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;pair&lt;/span&gt; (&lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;43&lt;/span&gt;),&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; ( &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt; == &lt;span class=&quot;n&quot;&gt;fst&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1j&lt;/span&gt;) {
    &lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;snd&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1j&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; one(R, R)&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What has happened here is that the original argument &lt;code&gt;R&lt;/code&gt; has been irrevocably turned into a junction with itself. This happens despite the fact that we never explicitly created a junction on &lt;code&gt;R&lt;/code&gt;. This is a consequence of the application of a junction type to a function, and it is not a bug, simply an effect of junction behaviour. For a more detailed explanation, see my article &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/reconstructing-raku-junctions&quot;&gt;&amp;quot;Reconstructing Raku&amp;#39;s Junctions&amp;quot;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://docs.raku.org/type/Junction&quot;&gt;Raku documentation of junctions&lt;/a&gt; says that you should not really try to get values out of a junction:&lt;/p&gt;

&lt;p&gt;&amp;quot;Junctions are meant to be used as matchers in Boolean context; introspection of junctions is not supported. If you feel the urge to introspect a junction, use a Set or a related type instead.&amp;quot;&lt;/p&gt;

&lt;p&gt;Luckily, there is a FAQ that &lt;a href=&quot;https://docs.raku.org/language/faq#index-entry-Junction_(FAQ)&quot;&gt;grudgingly shows you how to do it&lt;/a&gt;. The FAQ once again warns against doing this:&lt;/p&gt;

&lt;p&gt;&amp;quot;If you want to extract the values (eigenstates) from a Junction, you are probably doing something wrong and should be using a Set instead.&amp;quot;&lt;/p&gt;

&lt;p&gt;However, as demonstrated by the example I have given, there is a clear use case for recovering values from junctions. It is of course not the intention that one of the values stored in the pair becomes inaccessible simply because the other value happens to be a junction.&lt;/p&gt;

&lt;p&gt;I therefore propose the addition of a &lt;code&gt;collapse&lt;/code&gt; function which will allow to collapse these inadvertent junction values into their original values.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; ( &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt; == &lt;span class=&quot;n&quot;&gt;fst&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1j&lt;/span&gt;) {
    &lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;collapse&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;snd&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1j&lt;/span&gt;); &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; says &amp;#39;R&amp;#39;&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The implementation of this function is taken from &lt;a href=&quot;https://docs.raku.org/language/faq#index-entry-Junction_(FAQ)&quot;&gt;the above-mentioned FAQ&lt;/a&gt;, with the addition of a check to ensure that all values on the junction are identical. &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;collapse&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;Junction&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;) {    
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@vvs&lt;/span&gt;;
    -&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; \&lt;span class=&quot;o&quot;&gt;s&lt;/span&gt; { &lt;span class=&quot;nb&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@vvs&lt;/span&gt;, &lt;span class=&quot;o&quot;&gt;s&lt;/span&gt; }.(&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;);    
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$v&lt;/span&gt; =  &lt;span class=&quot;nb&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@vvs&lt;/span&gt;;        
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@ts&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; {!(&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt; ~~ &lt;span class=&quot;nv&quot;&gt;$v&lt;/span&gt;)}, &lt;span class=&quot;nv&quot;&gt;@vvs&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;@ts&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;elems&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;) {  
        &lt;span class=&quot;nv&quot;&gt;$v&lt;/span&gt;
    } &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; {
        &lt;span class=&quot;k&quot;&gt;die&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;Can&amp;#39;t collapse this Junction: elements are not identical: {$v,@vvs}&amp;quot;&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the first draft of this article, which I shared as a gist, I wrote that it would be nice if this &lt;code&gt;collapse&lt;/code&gt; would be added as an additional method to the &lt;code&gt;Junction&lt;/code&gt; class. And thanks to &lt;a href=&quot;https://twitter.com/liztormato&quot;&gt;Elizabeth Mattijsen&lt;/a&gt;, there is already &lt;a href=&quot;https://github.com/rakudo/rakudo/pull/3944&quot;&gt;a pull request implementing this feature in Rakudo&lt;/a&gt;!&lt;br&gt;
I will update the post when it has made it into a release. &lt;/p&gt;

        </content>
    </entry>
    
    <entry>
        <title>A universal interpreter</title>
        <link href="https://wimvanderbauwhede.github.io/articles/universal-interpreter-part-2/"/>
        <updated>2020-09-13T00:00:00+01:00</updated>
        <id>https://wimvanderbauwhede.github.io/articles/universal-interpreter-part-2</id>
        <author>
					<name>Wim Vanderbauwhede</name>
					<uri>https://wimvanderbauwhede.github.io/</uri>
					
				</author>
        <content type="html">
        	&lt;img src=&quot;https://wimvanderbauwhede.github.io/images/universal-interpreter-part-2_1600x600.jpg&quot;&gt;&lt;br/&gt;
        	&lt;p&gt;In &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/universal-interpreter-part-1&quot;&gt;the previous article&lt;/a&gt; I explained the basic idea behind a technique called &lt;a href=&quot;http://okmij.org/ftp/tagless-final/course/Boehm-Berarducci.html&quot;&gt;Böhm-Berarducci encoding&lt;/a&gt; of algebraic data types, and showed a way to implement this technique in &lt;a href=&quot;https://raku.org/&quot;&gt;Raku&lt;/a&gt;. Unless you are already familiar with this formalism, I recommend you read that article first. &lt;/p&gt;

&lt;p&gt;In this article I want to illustrate how the Böhm-Berarducci (BB) encoding of a data structure based on algebraic data types can be considered as a universal interpreter. What this means is that it is easy to perform computations that turn the data structure into something else. As an example, I will demonstrate how to create an evaluator and pretty-printer for a parsed polynomial expression.&lt;/p&gt;

&lt;h2&gt;A parse tree type&lt;/h2&gt;

&lt;p&gt;Consider expressions of the form &lt;code&gt;a*x^2+b*x+c&lt;/code&gt; or &lt;code&gt;x^3+1&lt;/code&gt; or &lt;code&gt;x*y^2-x^2*y&lt;/code&gt;. Let&amp;#39;s assume we have a parser for such an expression, for example built using &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/list-based-parser-combinators/&quot;&gt;parser combinators&lt;/a&gt;. Let&amp;#39;s also assume that this parser returns the parsed data as an algebraic data type, defined in Haskell as:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Term&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; 
      &lt;span class=&quot;kt&quot;&gt;Var&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Par&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; 
    &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Pow&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Term&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Add&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Term&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Mult&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Term&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and in Raku:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Term&lt;/span&gt; {}
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Var&lt;/span&gt; [&lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Term&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.var&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;;
}
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Par&lt;/span&gt; [&lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Term&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.par&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;;
}
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Const&lt;/span&gt; [&lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Term&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.const&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;;
}
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pow&lt;/span&gt; [&lt;span class=&quot;n&quot;&gt;Term&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Term&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Term&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.term&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.exp&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;;
}
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt; [&lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;Term&lt;/span&gt;] \&lt;span class=&quot;n&quot;&gt;ts&lt;/span&gt;] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Term&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;Term&lt;/span&gt;] &lt;span class=&quot;nv&quot;&gt;$.terms&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;ts&lt;/span&gt;;
}
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Mult&lt;/span&gt; [&lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;Term&lt;/span&gt;] \&lt;span class=&quot;n&quot;&gt;ts&lt;/span&gt;] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Term&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;Term&lt;/span&gt;] &lt;span class=&quot;nv&quot;&gt;$.terms&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;ts&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The additional complexity compared to the types discussed in &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/universal-interpreter-part-1&quot;&gt;the previous article&lt;/a&gt; is that this type is recursive: the &lt;code&gt;Pow&lt;/code&gt;, &lt;code&gt;Add&lt;/code&gt; and &lt;code&gt;Mult&lt;/code&gt; roles take parameters of type &lt;code&gt;Term&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;Before we look at the BB encoding, let&amp;#39;s first write a pretty-printer for this type, using recursive &lt;code&gt;multi sub&lt;/code&gt;s. &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Pretty-print a Term &lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ppTerm&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Var&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;) { &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt; }
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ppTerm&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Par&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;) { &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;par&lt;/span&gt; }
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ppTerm&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Const&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;) { &lt;span class=&quot;s&quot;&gt;&amp;quot;{n.const}&amp;quot;&lt;/span&gt; }
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ppTerm&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Pow&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;pw&lt;/span&gt;){ 
    &lt;span class=&quot;n&quot;&gt;ppTerm&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;pw&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;term&lt;/span&gt;) ~ &lt;span class=&quot;s&quot;&gt;&amp;#39;^&amp;#39;&lt;/span&gt; ~ &lt;span class=&quot;s&quot;&gt;&amp;quot;{pw.exp}&amp;quot;&lt;/span&gt; 
}
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ppTerm&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;) { 
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@pts&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; {&lt;span class=&quot;n&quot;&gt;ppTerm&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;)}, |&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;terms&lt;/span&gt;;
    &lt;span class=&quot;s&quot;&gt;&amp;quot;(&amp;quot;&lt;/span&gt;~&lt;span class=&quot;nb&quot;&gt;join&lt;/span&gt;( &lt;span class=&quot;s&quot;&gt;&amp;quot; + &amp;quot;&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;@pts&lt;/span&gt;)~&lt;span class=&quot;s&quot;&gt;&amp;quot;)&amp;quot;&lt;/span&gt;
}
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ppTerm&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Mult&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;){ 
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@pts&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; {&lt;span class=&quot;n&quot;&gt;ppTerm&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;)}, |&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;terms&lt;/span&gt;;
    &lt;span class=&quot;nb&quot;&gt;join&lt;/span&gt;( &lt;span class=&quot;s&quot;&gt;&amp;quot; * &amp;quot;&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;@pts&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the same way we can write an evaluator for this type:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Evaluate a Term &lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;evalTerm&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;%vars&lt;/span&gt;,  &lt;span class=&quot;nv&quot;&gt;%pars&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;Var&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;) { &lt;span class=&quot;nv&quot;&gt;%vars&lt;/span&gt;{&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt;} }
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;evalTerm&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;%vars&lt;/span&gt;,  &lt;span class=&quot;nv&quot;&gt;%pars&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;Par&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;) { &lt;span class=&quot;nv&quot;&gt;%pars&lt;/span&gt;{&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;par&lt;/span&gt;} }
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;evalTerm&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;%vars&lt;/span&gt;,  &lt;span class=&quot;nv&quot;&gt;%pars&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;Const&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;) { &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;const&lt;/span&gt; }
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;evalTerm&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;%vars&lt;/span&gt;,  &lt;span class=&quot;nv&quot;&gt;%pars&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;Pow&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;pw&lt;/span&gt;){ 
    &lt;span class=&quot;n&quot;&gt;evalTerm&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;%vars&lt;/span&gt;,  &lt;span class=&quot;nv&quot;&gt;%pars&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;pw&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;term&lt;/span&gt;) ** &lt;span class=&quot;n&quot;&gt;pw&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;exp&lt;/span&gt; 
}
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;evalTerm&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;%vars&lt;/span&gt;,  &lt;span class=&quot;nv&quot;&gt;%pars&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;) { 
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@pts&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; {&lt;span class=&quot;n&quot;&gt;evalTerm&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;%vars&lt;/span&gt;,  &lt;span class=&quot;nv&quot;&gt;%pars&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;)}, |&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;terms&lt;/span&gt;;
    [+] &lt;span class=&quot;nv&quot;&gt;@pts&lt;/span&gt;
}
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;evalTerm&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;%vars&lt;/span&gt;,  &lt;span class=&quot;nv&quot;&gt;%pars&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;Mult&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;){ 
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@pts&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; {&lt;span class=&quot;n&quot;&gt;evalTerm&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;%vars&lt;/span&gt;,  &lt;span class=&quot;nv&quot;&gt;%pars&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;)}, |&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;terms&lt;/span&gt;;
    [*] &lt;span class=&quot;nv&quot;&gt;@pts&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Example parse trees&lt;/h3&gt;

&lt;p&gt;As an example, let&amp;#39;s create the parse tree for a few expressions using the &lt;code&gt;Term&lt;/code&gt; type.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# a*x^2 + b*x + x&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;qterm1&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt;[ 
    &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;Term&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;(
    &lt;span class=&quot;n&quot;&gt;Mult&lt;/span&gt;[ &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;Term&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;(
        &lt;span class=&quot;n&quot;&gt;Par&lt;/span&gt;[ &lt;span class=&quot;s&quot;&gt;&amp;quot;a&amp;quot;&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;, 
        &lt;span class=&quot;n&quot;&gt;Pow&lt;/span&gt;[ &lt;span class=&quot;n&quot;&gt;Var&lt;/span&gt;[ &lt;span class=&quot;s&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;, &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;) 
        ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;,
    &lt;span class=&quot;n&quot;&gt;Mult&lt;/span&gt;[
        &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;Term&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;(
            &lt;span class=&quot;n&quot;&gt;Par&lt;/span&gt;[ &lt;span class=&quot;s&quot;&gt;&amp;quot;b&amp;quot;&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;, 
            &lt;span class=&quot;n&quot;&gt;Var&lt;/span&gt;[ &lt;span class=&quot;s&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;) 
        ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;,
    &lt;span class=&quot;n&quot;&gt;Par&lt;/span&gt;[ &lt;span class=&quot;s&quot;&gt;&amp;quot;c&amp;quot;&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;
    )
    ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;

&lt;span class=&quot;c1&quot;&gt;#   x^3 + 1    &lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;qterm2&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt;[ 
    &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;Term&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;(
        &lt;span class=&quot;n&quot;&gt;Pow&lt;/span&gt;[ &lt;span class=&quot;n&quot;&gt;Var&lt;/span&gt;[ &lt;span class=&quot;s&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;, &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;, 
        &lt;span class=&quot;n&quot;&gt;Const&lt;/span&gt;[ &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;
    )
    ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;

&lt;span class=&quot;c1&quot;&gt;#   qterm1 * qterm2    &lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;qterm&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;Mult&lt;/span&gt;[ 
    &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;Term&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;(
        &lt;span class=&quot;n&quot;&gt;qterm1&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;qterm2&lt;/span&gt;
    )
    ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Calling the pretty-printer and evaluator on this term: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ppTerm&lt;/span&gt;( &lt;span class=&quot;n&quot;&gt;qterm&lt;/span&gt;); &lt;span class=&quot;c1&quot;&gt;# =&amp;gt; (a * x^2 + b * x + c) * (x^3 + 1)&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;evalTerm&lt;/span&gt;(
    {&lt;span class=&quot;s&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt; =&amp;gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;}, {&lt;span class=&quot;s&quot;&gt;&amp;quot;a&amp;quot;&lt;/span&gt; =&amp;gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;s&quot;&gt;&amp;quot;b&amp;quot;&lt;/span&gt;=&amp;gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;s&quot;&gt;&amp;quot;c&amp;quot;&lt;/span&gt;=&amp;gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;},  &lt;span class=&quot;n&quot;&gt;qterm&lt;/span&gt;
); &lt;span class=&quot;c1&quot;&gt;# =&amp;gt; 162&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;BB encoding of the parse tree type&lt;/h2&gt;

&lt;p&gt;The BB encoding of the &lt;code&gt;Term&lt;/code&gt; algebraic data type in Raku is pleasingly compact:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TermBB&lt;/span&gt;[&lt;span class=&quot;nv&quot;&gt;&amp;amp;f&lt;/span&gt;] {
    &lt;span class=&quot;k&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unTermBB&lt;/span&gt;(
        &lt;span class=&quot;nv&quot;&gt;&amp;amp;var:&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;),
        &lt;span class=&quot;nv&quot;&gt;&amp;amp;par:&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;),
        &lt;span class=&quot;nv&quot;&gt;&amp;amp;const:&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;),
        &lt;span class=&quot;nv&quot;&gt;&amp;amp;pow:&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;,&lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;),
        &lt;span class=&quot;nv&quot;&gt;&amp;amp;add:&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;] --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;),
        &lt;span class=&quot;nv&quot;&gt;&amp;amp;mult:&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;] --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;) 
        --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;
    ) {
        &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;&amp;amp;var&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;par&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;const&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;pow&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;add&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;mult&lt;/span&gt;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It would of course be even more compact without the signatures, but then we&amp;#39;d have no information about the encoded type.&lt;/p&gt;

&lt;p&gt;We could of course use this type directly, but instead I want to look at how we can convert between &lt;code&gt;Term&lt;/code&gt; and &lt;code&gt;TermBB&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;As before, we create our little helpers. Each of the functions below is a constructor which generates the &lt;code&gt;TermBB&lt;/code&gt; instance for the corresponding alternative in the &lt;code&gt;Term&lt;/code&gt; algebraic data type. (When Raku&amp;#39;s macro language is more developed, we will be able to generate these automatically.)&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VarBB&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; \&lt;span class=&quot;o&quot;&gt;s&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;TermBB&lt;/span&gt;) { 
    &lt;span class=&quot;n&quot;&gt;TermBB&lt;/span&gt;[ 
        &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (\&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;, \&lt;span class=&quot;sr&quot;&gt;m) { v.(s)&lt;/span&gt; }
    ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
    }
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ParBB&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; \&lt;span class=&quot;o&quot;&gt;s&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;TermBB&lt;/span&gt;) { 
    &lt;span class=&quot;n&quot;&gt;TermBB&lt;/span&gt;[ 
        &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (\&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;, \&lt;span class=&quot;sr&quot;&gt;m) { c.(s)&lt;/span&gt; }
    ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
    }
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ConstBB&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;TermBB&lt;/span&gt;) { 
    &lt;span class=&quot;n&quot;&gt;TermBB&lt;/span&gt;[ 
        &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (\&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;, \&lt;span class=&quot;sr&quot;&gt;m) { n.(i)&lt;/span&gt; }
    ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
    }    
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PowBB&lt;/span&gt;( &lt;span class=&quot;n&quot;&gt;TermBB&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;TermBB&lt;/span&gt;) {
    &lt;span class=&quot;n&quot;&gt;TermBB&lt;/span&gt;[  &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (\&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;, \&lt;span class=&quot;sr&quot;&gt;m) { &lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;        p.( t.unTermBB( v, c, n, p, a, m )&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;);
    }
    ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
}
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AddB&lt;/span&gt;( &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;TermBB&lt;/span&gt;] \&lt;span class=&quot;n&quot;&gt;ts&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;TermBB&lt;/span&gt;) {
    &lt;span class=&quot;n&quot;&gt;TermBB&lt;/span&gt;[  &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (\&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;, \&lt;span class=&quot;sr&quot;&gt;m) { &lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;        a.( map {.unTermBB( v, c, n, p, a, m )&lt;/span&gt;}, &lt;span class=&quot;n&quot;&gt;ts&lt;/span&gt; )
    }
    ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
}
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MultBB&lt;/span&gt;(  &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;TermBB&lt;/span&gt;] \&lt;span class=&quot;n&quot;&gt;ts&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;TermBB&lt;/span&gt;) { 
    &lt;span class=&quot;n&quot;&gt;TermBB&lt;/span&gt;[  &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (\&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;, \&lt;span class=&quot;sr&quot;&gt;m) { &lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;        m.( map {.unTermBB( v, c, n, p, a, m )&lt;/span&gt;}, &lt;span class=&quot;n&quot;&gt;ts&lt;/span&gt; )
    }
    ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The interesting generators are &lt;code&gt;PowBB&lt;/code&gt;, &lt;code&gt;AddBB&lt;/code&gt; and &lt;code&gt;MultBB&lt;/code&gt; because they are recursive. In &lt;code&gt;PowBB&lt;/code&gt;, the function passed as parameter to the &lt;code&gt;TermBB&lt;/code&gt; role constructor calls &lt;code&gt;p&lt;/code&gt; which has a signature of &lt;code&gt;:(Any,Int --&amp;gt; Any)&lt;/code&gt;, but actually requires an argument of the same type as the return value (we need &lt;code&gt;a -&amp;gt; Int -&amp;gt; a&lt;/code&gt;). The argument &lt;code&gt;t&lt;/code&gt;  is of type &lt;code&gt;TermBB&lt;/code&gt; which is a wrapper around a function which, when applied, will return the right type. In the Raku implementation, this function is the method &lt;code&gt;unTermBB&lt;/code&gt;. So we need to call &lt;code&gt;t.unTermBB( ... )&lt;/code&gt;.
In &lt;code&gt;AddBB&lt;/code&gt; and &lt;code&gt;MultBB&lt;/code&gt;, we have an &lt;code&gt;Array[TermBB]&lt;/code&gt; so we need to call &lt;code&gt;unTermBB&lt;/code&gt; on every element, hence the &lt;code&gt;map&lt;/code&gt; call.&lt;/p&gt;

&lt;p&gt;Using these generators we can write a single function to convert the algebraic data type into its BB encoding. Unsurprisingly, it is very similar to the pretty-printer and evaluator we wrote for &lt;code&gt;Term&lt;/code&gt; instances:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Turn a Term into a BB Term&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;termToBB&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Var&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;  ) { &lt;span class=&quot;n&quot;&gt;VarBB&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt;)}
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;termToBB&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Par&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;  ) { &lt;span class=&quot;n&quot;&gt;ParBB&lt;/span&gt;( &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;par&lt;/span&gt;)}
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;termToBB&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Const&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;) {&lt;span class=&quot;n&quot;&gt;ConstBB&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;const&lt;/span&gt;)}
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;termToBB&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Pow&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;pw&lt;/span&gt; ) { 
    &lt;span class=&quot;n&quot;&gt;PowBB&lt;/span&gt;( &lt;span class=&quot;n&quot;&gt;termToBB&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;pw&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;term&lt;/span&gt;), &lt;span class=&quot;n&quot;&gt;pw&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;exp&lt;/span&gt;)
}
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;termToBB&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;  ) { 
    &lt;span class=&quot;n&quot;&gt;AddBB&lt;/span&gt;( &lt;span class=&quot;n&quot;&gt;typed-map&lt;/span&gt;( &lt;span class=&quot;n&quot;&gt;TermBB&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;terms&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;&amp;amp;termToBB&lt;/span&gt; ))
}
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;termToBB&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Mult&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; ) { 
    &lt;span class=&quot;n&quot;&gt;MultBB&lt;/span&gt;( &lt;span class=&quot;n&quot;&gt;typed-map&lt;/span&gt;( &lt;span class=&quot;n&quot;&gt;TermBB&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;terms&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;&amp;amp;termToBB&lt;/span&gt; ))
}

&lt;span class=&quot;c1&quot;&gt;# map &amp;amp;f and return in an Array of type T&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;typed-map&lt;/span&gt; (\&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;,\&lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;f&lt;/span&gt;) {
    &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; {&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;) }, |&lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; )
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Because &lt;code&gt;PowBB&lt;/code&gt;, &lt;code&gt;AddBB&lt;/code&gt; and &lt;code&gt;MultBB&lt;/code&gt; require a &lt;code&gt;TermBB&lt;/code&gt;, we need to call &lt;code&gt;termToBB&lt;/code&gt; on the &lt;code&gt;Term&lt;/code&gt; fields. And because  &lt;code&gt;AddBB&lt;/code&gt; and &lt;code&gt;MultBB&lt;/code&gt; take an array of &lt;code&gt;Term&lt;/code&gt;,  we need a &lt;code&gt;map&lt;/code&gt;. However, Raku&amp;#39;s &lt;code&gt;map&lt;/code&gt; returns values of type &lt;code&gt;Seq&lt;/code&gt;, so we need an explicit conversion into &lt;code&gt;Array&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can now convert any data structure of type &lt;code&gt;Term&lt;/code&gt; into its BB encoding:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;qtermbb&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;termToBB&lt;/span&gt;( &lt;span class=&quot;n&quot;&gt;qterm&lt;/span&gt;);

&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;qtermbb&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;raku&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;# =&amp;gt; TermBB[Sub].new&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Interpreter 1: Pretty-printer with BB encoding&lt;/h3&gt;

&lt;p&gt;To create a pretty-printer for the BB-encoded type, we write implementations for each alternative, and the &lt;code&gt;unTermBB&lt;/code&gt; call magically combines these.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ppTermBB&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;TermBB&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt;){ 
    &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var&lt;/span&gt;( \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; ) { &lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; }
    &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;par&lt;/span&gt;( \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; ) { &lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; }
    &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;const&lt;/span&gt;(\&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; ) { &lt;span class=&quot;s&quot;&gt;&amp;quot;{x}&amp;quot;&lt;/span&gt; }
    &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;( \&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;, \&lt;span class=&quot;sr&quot;&gt;m ) { t ~ &amp;quot;^{m}&amp;quot; } &lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;    sub add( \ts )&lt;/span&gt; { &lt;span class=&quot;s&quot;&gt;&amp;quot;(&amp;quot;&lt;/span&gt;~&lt;span class=&quot;nb&quot;&gt;join&lt;/span&gt;( &lt;span class=&quot;s&quot;&gt;&amp;quot; + &amp;quot;&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;ts&lt;/span&gt;)~&lt;span class=&quot;s&quot;&gt;&amp;quot;)&amp;quot;&lt;/span&gt; }
    &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mult&lt;/span&gt;( \&lt;span class=&quot;n&quot;&gt;ts&lt;/span&gt; ) { &lt;span class=&quot;nb&quot;&gt;join&lt;/span&gt;( &lt;span class=&quot;s&quot;&gt;&amp;quot; * &amp;quot;&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;ts&lt;/span&gt;) }
    &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;unTermBB&lt;/span&gt;( &lt;span class=&quot;nv&quot;&gt;&amp;amp;var&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;&amp;amp;par&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;&amp;amp;const&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;&amp;amp;pow&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;&amp;amp;add&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;&amp;amp;mult&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Compared with &lt;code&gt;ppTerm&lt;/code&gt; (copied below for convenience), the main differences are that there is no recursion and no need to &lt;code&gt;map&lt;/code&gt; anything. We also don&amp;#39;t need a &lt;code&gt;multi sub&lt;/code&gt; to pattern match on the constructors, and there is no need to unpack the values stored in the type using attribute accessors. As a result, the BB version is markedly less cluttered.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ppTerm&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Var&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt;) { &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt; }
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ppTerm&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Par&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt;) { &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;par&lt;/span&gt; }
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ppTerm&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Const&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt;) { &lt;span class=&quot;s&quot;&gt;&amp;quot;{n.const}&amp;quot;&lt;/span&gt; }
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ppTerm&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Pow&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;pw&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt;){ 
    &lt;span class=&quot;n&quot;&gt;ppTerm&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;pw&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;term&lt;/span&gt;) ~ &lt;span class=&quot;s&quot;&gt;&amp;#39;^&amp;#39;&lt;/span&gt; ~ &lt;span class=&quot;s&quot;&gt;&amp;quot;{pw.exp}&amp;quot;&lt;/span&gt; 
}
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ppTerm&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt;) { 
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@pts&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; {&lt;span class=&quot;n&quot;&gt;ppTerm&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;)}, |&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;terms&lt;/span&gt;;
    &lt;span class=&quot;s&quot;&gt;&amp;quot;(&amp;quot;&lt;/span&gt;~&lt;span class=&quot;nb&quot;&gt;join&lt;/span&gt;( &lt;span class=&quot;s&quot;&gt;&amp;quot; + &amp;quot;&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;@pts&lt;/span&gt;)~&lt;span class=&quot;s&quot;&gt;&amp;quot;)&amp;quot;&lt;/span&gt;
}
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ppTerm&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Mult&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt;){ 
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@pts&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; {&lt;span class=&quot;n&quot;&gt;ppTerm&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;)}, |&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;terms&lt;/span&gt;;
    &lt;span class=&quot;nb&quot;&gt;join&lt;/span&gt;( &lt;span class=&quot;s&quot;&gt;&amp;quot; * &amp;quot;&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;@pts&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Interpreter 2: Evaluator with BB encoding&lt;/h3&gt;

&lt;p&gt;And an evaluator is equally simple:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;evalTermBB&lt;/span&gt;( &lt;span class=&quot;nv&quot;&gt;%vars&lt;/span&gt;,  &lt;span class=&quot;nv&quot;&gt;%pars&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;) {
    &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;unTermBB&lt;/span&gt;( 
        -&amp;gt; \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; { &lt;span class=&quot;nv&quot;&gt;%vars&lt;/span&gt;{&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;} }, 
        -&amp;gt; \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; { &lt;span class=&quot;nv&quot;&gt;%pars&lt;/span&gt;{&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;} },
        -&amp;gt; \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; {&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;},
        -&amp;gt; \&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;,\&lt;span class=&quot;sr&quot;&gt;m { t ** m}&lt;/span&gt;,
        -&amp;gt; \&lt;span class=&quot;n&quot;&gt;ts&lt;/span&gt; { [+] &lt;span class=&quot;n&quot;&gt;ts&lt;/span&gt;},
        -&amp;gt; \&lt;span class=&quot;n&quot;&gt;ts&lt;/span&gt; { [*] &lt;span class=&quot;n&quot;&gt;ts&lt;/span&gt;}
    );
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As with &lt;code&gt;evalTerm&lt;/code&gt; below, we pass hashes for variable and parameter definitions as arguments to provide context for the evaluation. In the BB version we need to do this only once, rather than for every multi variant, so I have written it below using a &lt;code&gt;given/when&lt;/code&gt;. Even then, the BB version is a lot cleaner, for the same reasons as above. &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;evalTerm&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;%vars&lt;/span&gt;,  &lt;span class=&quot;nv&quot;&gt;%pars&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;Term&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;) {
    &lt;span class=&quot;k&quot;&gt;given&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; {
        &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Var&lt;/span&gt; { &lt;span class=&quot;nv&quot;&gt;%vars&lt;/span&gt;{&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt;} }
        &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Par&lt;/span&gt; { &lt;span class=&quot;nv&quot;&gt;%pars&lt;/span&gt;{&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;par&lt;/span&gt;} }
        &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Const&lt;/span&gt; { &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;const&lt;/span&gt; }
        &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pow&lt;/span&gt; { &lt;span class=&quot;n&quot;&gt;evalTerm&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;%vars&lt;/span&gt;,  &lt;span class=&quot;nv&quot;&gt;%pars&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;term&lt;/span&gt;) ** &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;exp&lt;/span&gt; }
        &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt; {
            &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@pts&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; {
                &lt;span class=&quot;n&quot;&gt;evalTerm&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;%vars&lt;/span&gt;,  &lt;span class=&quot;nv&quot;&gt;%pars&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;)
                }, |&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;terms&lt;/span&gt;;
            [+] &lt;span class=&quot;nv&quot;&gt;@pts&lt;/span&gt;
        }
        &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Mult&lt;/span&gt; { 
            &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@pts&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; {
                &lt;span class=&quot;n&quot;&gt;evalTerm&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;%vars&lt;/span&gt;,  &lt;span class=&quot;nv&quot;&gt;%pars&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;)
                }, |&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;terms&lt;/span&gt;;
            [*] &lt;span class=&quot;nv&quot;&gt;@pts&lt;/span&gt;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;!-- ### Interpreter 3: Pretty-printer and evaluator combined

Now we can do one better and combine these two interpreters.

```perl6
sub evalAndppTermBB(%vars,  %pars, TermBB \t ){ 
    t.unTermBB( 
        -&gt; \x {[%vars{x},x]}, 
        -&gt; \x {[%pars{x},x]},
        -&gt; \x {[x,&quot;{x}&quot;]},
        -&gt; \t,\m {[t[0] ** m, t[1] ~ &quot;^{m}&quot;] },
        -&gt; \ts { 
            my \p = 
                reduce { [ $^a[0] + $^b[0], $^a[1] ~ &quot; + &quot; ~ $^b[1]] }, ts[0],  |ts[1..*];
            [ p[0], &quot;(&quot;~p[1]~&quot;)&quot; ]; 
        }, 
        -&gt; \ts { 
            reduce { [ $^a[0] * $^b[0], $^a[1] ~ &quot; * &quot; ~ $^b[1]] }, ts[0],  |ts[1..*]
        }
    )
}

say ppTermBB( qtermbb);
say evalTermBB(
    {&quot;x&quot; =&gt; 2}, {&quot;a&quot; =&gt;2,&quot;b&quot;=&gt;3,&quot;c&quot;=&gt;4},  qtermbb
);
say evalAndppTermBB(
    {&quot;x&quot; =&gt; 2}, {&quot;a&quot; =&gt;2,&quot;b&quot;=&gt;3,&quot;c&quot;=&gt;4},  qtermbb
);
``` --&gt;

&lt;h3&gt;Interpreter 3: Converting &lt;code&gt;TermBB&lt;/code&gt; to &lt;code&gt;Term&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Finally, let&amp;#39;s look at converting &lt;code&gt;TermBB&lt;/code&gt; to &lt;code&gt;Term&lt;/code&gt;. This is yet another type of interpreter so we can follow exactly the same approach as before: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;toTerm&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;TermBB&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;Term&lt;/span&gt;){ 
        &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var&lt;/span&gt;( \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; ) { &lt;span class=&quot;n&quot;&gt;Var&lt;/span&gt;[&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt; }
        &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;par&lt;/span&gt;( \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; ) { &lt;span class=&quot;n&quot;&gt;Par&lt;/span&gt;[&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt; }
        &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;const&lt;/span&gt;( &lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt; ) { &lt;span class=&quot;n&quot;&gt;Const&lt;/span&gt;[&lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt; }
        &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;( \&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$m&lt;/span&gt; ) { &lt;span class=&quot;n&quot;&gt;Pow&lt;/span&gt;[ &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$m&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt; } 
        &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;( \&lt;span class=&quot;n&quot;&gt;ts&lt;/span&gt; ) { &lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt;[ &lt;span class=&quot;n&quot;&gt;ts&lt;/span&gt; ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt; }
        &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mult&lt;/span&gt;( \&lt;span class=&quot;n&quot;&gt;ts&lt;/span&gt; ) { &lt;span class=&quot;n&quot;&gt;Mult&lt;/span&gt;[ &lt;span class=&quot;n&quot;&gt;ts&lt;/span&gt; ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;) }
        &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;unTermBB&lt;/span&gt;( &lt;span class=&quot;nv&quot;&gt;&amp;amp;var&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;&amp;amp;par&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;&amp;amp;const&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;&amp;amp;pow&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;&amp;amp;add&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;&amp;amp;mult&lt;/span&gt;);
}

&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;toTerm&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;qtermbb&lt;/span&gt;).&lt;span class=&quot;n&quot;&gt;raku&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Using the BB type directly&lt;/h2&gt;

&lt;p&gt;In the examples above I have created the data structures using the &lt;code&gt;Term&lt;/code&gt; type and converted the result to a &lt;code&gt;TermBB&lt;/code&gt; type. We can of course also directly use the BB type. If we don&amp;#39;t use strict typing and make the argument of &lt;code&gt;Add&lt;/code&gt; and &lt;code&gt;Mult&lt;/code&gt; slurpy, we get a nice and clean representation:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# a*x^2 + b*x + x&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;qtermbb1&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;AddBB&lt;/span&gt;(
    &lt;span class=&quot;n&quot;&gt;MultBB&lt;/span&gt;( 
        &lt;span class=&quot;n&quot;&gt;ParBB&lt;/span&gt;( &lt;span class=&quot;s&quot;&gt;&amp;quot;a&amp;quot;&lt;/span&gt;), 
        &lt;span class=&quot;n&quot;&gt;PowBB&lt;/span&gt;( &lt;span class=&quot;n&quot;&gt;VarBB&lt;/span&gt;( &lt;span class=&quot;s&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;), &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;) 
        ),
    &lt;span class=&quot;n&quot;&gt;MultBB&lt;/span&gt;(
        &lt;span class=&quot;n&quot;&gt;ParBB&lt;/span&gt;( &lt;span class=&quot;s&quot;&gt;&amp;quot;b&amp;quot;&lt;/span&gt;), 
        &lt;span class=&quot;n&quot;&gt;VarBB&lt;/span&gt;( &lt;span class=&quot;s&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;) 
        ),
    &lt;span class=&quot;n&quot;&gt;ParBB&lt;/span&gt;( &lt;span class=&quot;s&quot;&gt;&amp;quot;c&amp;quot;&lt;/span&gt;)
);

&lt;span class=&quot;c1&quot;&gt;#   x^3 + 1    &lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;qtermbb2&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;AddBB&lt;/span&gt;( 
    &lt;span class=&quot;n&quot;&gt;PowBB&lt;/span&gt;( &lt;span class=&quot;n&quot;&gt;VarBB&lt;/span&gt;( &lt;span class=&quot;s&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;), &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;), 
    &lt;span class=&quot;n&quot;&gt;ConstBB&lt;/span&gt;(&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;)
);

&lt;span class=&quot;c1&quot;&gt;#   qterm1 * qterm2    &lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;qtermbb3&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;MultBB&lt;/span&gt;( 
    &lt;span class=&quot;n&quot;&gt;qterm1&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;qterm2&lt;/span&gt;
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is structurally very similar to the examples using the &lt;code&gt;Term&lt;/code&gt; type. We can obtain exactly the same representation by using a slurpy helper function to wrap the role constructors for &lt;code&gt;Term&lt;/code&gt;. See the code in &lt;a href=&quot;https://github.com/wimvanderbauwhede/raku-examples/blob/master/no-bb-timing.raku&quot;&gt;no-b-timing.raku`&lt;/a&gt; and &lt;a href=&quot;https://github.com/wimvanderbauwhede/raku-examples/blob/master/ubb-timing.raku&quot;&gt;ubb-timing.raku&lt;/a&gt; for details. &lt;/p&gt;

&lt;p&gt;The code as presented above is not entirely correct: I have not always typed everything explicitly, but the explicit signatures in the role definition will cause type errors unless everything is explicitly typed. See the code in &lt;a href=&quot;https://github.com/wimvanderbauwhede/raku-examples/blob/master/tbb-timing.raku&quot;&gt;tbb-timing.raku&lt;/a&gt; for details.&lt;/p&gt;

&lt;p&gt;The code in &lt;code&gt;no-bb-timing&lt;/code&gt; and &lt;code&gt;ubb-timing&lt;/code&gt; is comparable in terms of complexity. I ran a timing test, and the BB implementation of the algebraic data type is about 20% slower than the &amp;#39;ordinary&amp;#39; implementation. However, the fully-typed version &lt;code&gt;tbb-timing&lt;/code&gt; is three times slower. Types in Raku are clearly not zero-cost abstractions. &lt;/p&gt;

&lt;p&gt;For info, here are the profiling reports (&lt;code&gt;raku --profile&lt;/code&gt;) for &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/no-bb-timing.html&quot;&gt;no-bb-timing&lt;/a&gt; and &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/ubb-timing.html&quot;&gt;ubb-timing&lt;/a&gt;. Profiling &lt;code&gt;tbb-timing&lt;/code&gt; proved infeasible.&lt;/p&gt;

&lt;p&gt;On the other hand, somewhat paradoxically, we don&amp;#39;t really need this explicit typing. It is useful to write down the function types for the BB encoding, and I think it helps with the explanations, but the actual type safety comes from the algebraic data types that we created. &lt;/p&gt;

&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;In this article and &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/universal-interpreter-part-1&quot;&gt;the previous one&lt;/a&gt; I have shown another way to implement algebraic data types in Raku. As with the approach discussed in &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/roles-as-adts-in-raku/&quot;&gt;&amp;#39;Roles as Algebraic Data Types in Raku&amp;#39;&lt;/a&gt;, I use a role to create the type. However, in this approach the entire data structure is encoded as a function using the &lt;a href=&quot;http://okmij.org/ftp/tagless-final/course/Boehm-Berarducci.html&quot;&gt;Böhm-Berarducci encoding&lt;/a&gt;. From a type theoretical perspective, both approaches are precisely equivalent. In terms of coding effort and performance, both approaches are comparable. &lt;/p&gt;

&lt;p&gt;The advantage of the BB approach is that because the data is encoded as a function, it becomes easier to create interpreters for the data type, and I have illustrated this with a pretty-printer and evaluator for a parsed expression. All interpreters for BB types have the same structure, which is why I call it a universal interpreter. The key feature is that these interpreters do not require any explicit recursion. &lt;/p&gt;

&lt;p&gt;The complete code for both articles is in &lt;a href=&quot;https://github.com/wimvanderbauwhede/raku-examples/blob/master/universal-interpreter.raku&quot;&gt;universal-interpreter.raku&lt;/a&gt;&lt;/p&gt;

&lt;!-- 

### Bonus: parsing the expression

In the article []() I presented a parser combinator library which uses the role-based algebraic data types.  The parser returns the following type:

```perl6
role TaggedEntry {}
# A string value
role Val[Str @v] does TaggedEntry {
    has Str @.val=@v;
} 
# A list of TaggedEntry values tagged with a string label
role ValMap [  @vm] does TaggedEntry {
    has @.valmap = @vm; 
}
```

It is quite straightforward to transform a data structure of this type into our `Term` type:

```perl6
multi sub taggedEntryToTerm (Var , Val \val_strs) { Var[ val_strs.val.head].new }
multi sub taggedEntryToTerm (Par , Val \par_strs) { Par[ par_strs.val.head].new }
multi sub taggedEntryToTerm (Const ,\const_strs) {Const[ Int(const_strs.val.head)].new } 
# multi sub taggedEntryToTerm (Pow , ValMap [t1,(_,Val [v2])]) { Pow[ taggedEntryToTerm(...,....), Int(...)].new}        
# multi sub taggedEntryToTerm (Add , ValMap hmap) = Add $ map taggedEntryToTerm hmap
# multi sub taggedEntryToTerm (Mult , ValMap hmap) = Mult $ map taggedEntryToTerm hmap
```


```perl6
my Str @val_strs = &quot;42&quot;;
my \v = taggedEntryToTerm(Const, Val[@val_strs].new);
say v.raku; 
```

 --&gt;

        </content>
    </entry>
    
    <entry>
        <title>Encoding types as functions in Raku</title>
        <link href="https://wimvanderbauwhede.github.io/articles/universal-interpreter-part-1/"/>
        <updated>2020-09-12T00:00:00+01:00</updated>
        <id>https://wimvanderbauwhede.github.io/articles/universal-interpreter-part-1</id>
        <author>
					<name>Wim Vanderbauwhede</name>
					<uri>https://wimvanderbauwhede.github.io/</uri>
					
				</author>
        <content type="html">
        	&lt;img src=&quot;https://wimvanderbauwhede.github.io/images/universal-interpreter-part-1_1600x600.jpg&quot;&gt;&lt;br/&gt;
        	&lt;p&gt;This is the first part of an article in my series about functional programming in general and algebraic data types and function types in particular in &lt;a href=&quot;https://raku.org/&quot;&gt;Raku&lt;/a&gt;. It builds on my earlier articles on &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/roles-as-adts-in-raku/&quot;&gt;algebraic data types in Raku&lt;/a&gt; and their use in the practical example of &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/list-based-parser-combinators/&quot;&gt;list-based parser combinators&lt;/a&gt;. It also makes heavily use of &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/function-types&quot;&gt;function types&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you are not familiar with functional programming or with Raku, I suggest you read my introduction &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/decluttering-with-functional-programming/&quot;&gt;&amp;quot;Cleaner code with functional programming&amp;quot;&lt;/a&gt;. If you are not familiar with algebraic data types or function types, you might want to read the other articles as well. &lt;/p&gt;

&lt;p&gt;In this article, I want to explain a technique called &lt;a href=&quot;http://okmij.org/ftp/tagless-final/course/Boehm-Berarducci.html&quot;&gt;Böhm-Berarducci encoding&lt;/a&gt; of algebraic data types. The link above is to Oleg Kiselyov&amp;#39;s explanation, which makes for interesting reading but is not required for what follows. Oleg says:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;quot;Boehm-Berarducci&amp;#39;s paper has many great insights. Alas, the generality of the presentation makes the paper very hard to understand. It has a Zen-like quality: it is incomprehensible unless you already know its results.&amp;quot;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Fortunately, to follow the explanation in this article, you don&amp;#39;t need to read either Böhm and Berarducci&amp;#39;s  original paper or Oleg&amp;#39;s explanation. For the purpose of this article, it is sufficient to say that the Böhm-Berarducci encoding is a way to encode an algebraic data type as a function type. This means that the data itself is also encoded as a function. As a result, the function encoding the data type becomes a &amp;quot;universal interpreter&amp;quot;. This makes it is easy to create various interpreters for algebraic data types. &lt;/p&gt;

&lt;p&gt;In this first part, I will explain a way to implement Böhm-Berarducci (BB) encoding using roles in Raku, with basic examples. In &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/universal-interpreter-part-2&quot;&gt;the second part&lt;/a&gt; I will show how to use BB encoding to construct a &amp;#39;universal interpreter&amp;#39; which makes it very easy to create specific interpreters for complex data structures. &lt;/p&gt;

&lt;h2&gt;The basic idea behind the Böhm-Berarducci encoding&lt;/h2&gt;

&lt;p&gt;The basic idea behind the Böhm-Berarducci (BB) encoding is to create a type which represents a function with an argument for every alternative in a sum type.
Every argument is itself a function which takes as arguments the arguments of each alternative product type, and returns a polymorphic type. Because the return type is polymorphic, we decide what it will be when we use the BB type. In this way a BB-encoded data structure is a generator for whatever type we like, in other words it is a universal interpreter. &lt;/p&gt;

&lt;p&gt;For example, if we define a sum type &lt;code&gt;S&lt;/code&gt; with three alternatives &lt;code&gt;A1&lt;/code&gt;, &lt;code&gt;A2&lt;/code&gt; and &lt;code&gt;A3&lt;/code&gt;, using the same notation as in the article on &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/roles-as-adts-in-raku/&quot;&gt;algebraic data types in Raku&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;datatype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A1&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A2&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;then the corresponding BB type will be&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;datatype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∀&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- A1 Int&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟶&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟶&lt;/span&gt; 
    &lt;span class=&quot;c1&quot;&gt;-- A2 String&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟶&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟶&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟶&lt;/span&gt; 
    &lt;span class=&quot;c1&quot;&gt;-- A3&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟶&lt;/span&gt; 
    &lt;span class=&quot;c1&quot;&gt;-- The return type&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I have put parentheses to show which part of the type is the function type corresponding to each alterative. 
Because the constructor for &lt;code&gt;A3&lt;/code&gt; takes no arguments, the corresponding function signature in the BB encoding is simply &lt;code&gt;a&lt;/code&gt;: a function which takes no arguments and returns something of type &lt;code&gt;a&lt;/code&gt;. The final &lt;code&gt;a&lt;/code&gt; is the return value of the top-level function: every type alternative is an argument to the function. When applying the function, it must return a value of a given type. This type is &lt;code&gt;a&lt;/code&gt; because &lt;code&gt;a&lt;/code&gt; is the return type of every function representing an alternative. I will explain the &lt;code&gt;∀ a .&lt;/code&gt; later.&lt;/p&gt;

&lt;h2&gt;Some simple examples&lt;/h2&gt;

&lt;p&gt;Let&amp;#39;s look at a few examples to see how this works in practice.&lt;/p&gt;

&lt;h3&gt;OpinionatedBool: an enum-style sum type&lt;/h3&gt;

&lt;p&gt;In a &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/roles-as-adts-in-raku/&quot;&gt;previous post&lt;/a&gt; I showed how you can use Raku&amp;#39;s &lt;em&gt;role&lt;/em&gt; feature to implement algebraic data types. I gave the example of 
&lt;code&gt;OpinionatedBool&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;datatype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;OpinionatedBool&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AbsolutelyTrue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TotallyFalse&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which in Raku becomes&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OpinionatedBool&lt;/span&gt; {}
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AbsolutelyTrue&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OpinionatedBool&lt;/span&gt; {}
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TotallyFalse&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OpinionatedBool&lt;/span&gt; {}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is a sum type with two alternatives. &lt;/p&gt;

&lt;p&gt;The type declaration of the BB type lists the types of all the arguments representing the alternatives. As in this case the constructors for the alternatives take no arguments, the corresponding functions also take no arguments:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;datatype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;OpinionatedBoolBB&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;OpinionatedBoolBB&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;∀&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- AbsolutelyTrue&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;⟶&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- TotallyFalse&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;⟶&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In &lt;a href=&quot;https://haskell.org&quot;&gt;Haskell&lt;/a&gt;, we would implement this type as follows:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;OpinionatedBoolBB&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;OpinionatedBoolBB&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;unBoolBB&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; 
       &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- AbsolutelyTrue&lt;/span&gt;
    &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- TotallyFalse&lt;/span&gt;
    &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You don&amp;#39;t need to know any Haskell for what follows, but as the Raku implementation is closely modeled on the Haskell one, it is worth explaining a bit.
The &lt;code&gt;newtype&lt;/code&gt; keyword in Haskell is used to declare types with a single constructor. What we have here is a record type with a single field, and this field has the accessor function &lt;code&gt;unBoolBB&lt;/code&gt;, which is a convenience to allow easy access to the function encoded in the type. The &lt;code&gt;∀ a&lt;/code&gt;  or &lt;code&gt;forall a&lt;/code&gt; allows us to introduce a type parameter that is only in scope in the expression on the right-hand side. Because the Haskell notation is so close to the formal notation, I will from now on use the Haskell notation.&lt;/p&gt;

&lt;p&gt;In Raku, we can implement this  BB type minimally as a parametric role with a method with a typed signature:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BoolBB&lt;/span&gt;[&lt;span class=&quot;nv&quot;&gt;&amp;amp;b&lt;/span&gt;] {
    &lt;span class=&quot;k&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unBoolBB&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;) {
        &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This tells us a lot:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the parameter to the role has an &lt;code&gt;&amp;amp;&lt;/code&gt; sigil so it of type &lt;code&gt;Callable&lt;/code&gt; (i.e. it is a function)&lt;/li&gt;
&lt;li&gt;the method&amp;#39;s type tells us that there are two arguments of type &lt;code&gt;Any&lt;/code&gt;. The method itself also returns a value of type &lt;code&gt;Any&lt;/code&gt;, i.e. there is no constraint on the type of the return value. &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With this implementation, the type safety is not quite as strong as in Haskell, where we guarantee that all these return values will be of the same type. The main purpose for using the types here is to make it provide documentation. We can enforce the type safety at a different point if desired.&lt;/p&gt;

&lt;p&gt;Now, the whole idea is that this role &lt;code&gt;BoolBB&lt;/code&gt; will serve the same purpose as my &lt;code&gt;OpinionatedBool&lt;/code&gt;. So instead of saying&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OpinionatedBool&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;trueOB&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;AbsolutelyTrue&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I want something like &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BoolBB&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;trueBB&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;BBTrue&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So in this example, &lt;code&gt;BBTrue&lt;/code&gt; will be an instance of &lt;code&gt;BoolBB&lt;/code&gt; with a specific function as parameter. Let&amp;#39;s call that function &lt;code&gt;true&lt;/code&gt;, so we have&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;BBTrue&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;BoolBB&lt;/span&gt;[ &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt; ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and similar for the &lt;code&gt;false&lt;/code&gt; case. We can make this a little nicer using a helper function to create &lt;code&gt;BoolBB&lt;/code&gt; instances:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bbb&lt;/span&gt;(\&lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;BoolBB&lt;/span&gt;) { &lt;span class=&quot;n&quot;&gt;BoolBB&lt;/span&gt;[ &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt; ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt; };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this way we can write&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BBTrue&lt;/span&gt; { &lt;span class=&quot;n&quot;&gt;bbb&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt; } 
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BBFalse&lt;/span&gt; { &lt;span class=&quot;n&quot;&gt;bbb&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;false&lt;/span&gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this particular case, because none of the constructors takes any arguments, we can also write this as&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BoolBB&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;BBTrue&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;bbb&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BoolBB&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;BBFalse&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;bbb&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;false&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;!-- ∀ --&gt;

&lt;p&gt;The question is then: what are the functions &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;? We know they are of type &lt;code&gt;a ⟶ a ⟶ a&lt;/code&gt;; an obvious choice is:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;  = -&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; { &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; }
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;false&lt;/span&gt; = &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (&lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;,&lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; ) { &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is the same choice we made in &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/everything-is-a-function/&quot;&gt;the article &amp;quot;Everything is a function&amp;quot;&lt;/a&gt;. In fact, these are simply &lt;em&gt;selector&lt;/em&gt; functions which select the first or second argument. &lt;/p&gt;

&lt;p&gt;In practice, we often want to convert between BB types and their algebraic counterparts.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;To turn a Bool into a BoolBB:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;boolBB&lt;/span&gt; (&lt;span class=&quot;nb&quot;&gt;Bool&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;BoolBB&lt;/span&gt;){ &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt; ?? &lt;span class=&quot;n&quot;&gt;BBTrue&lt;/span&gt; !! &lt;span class=&quot;n&quot;&gt;BBFalse&lt;/span&gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;To turn the BB Boolean into an actual Boolean:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;BoolBB&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Bool&lt;/span&gt;) { 
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;unBoolBB&lt;/span&gt;( &lt;span class=&quot;nb&quot;&gt;True&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;False&lt;/span&gt;) 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So we have:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BBTrue&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;# =&amp;gt; True&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BBFalse&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;# =&amp;gt; False&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;boolBB&lt;/span&gt;( &lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BBTrue&lt;/span&gt;); &lt;span class=&quot;c1&quot;&gt;# =&amp;gt; True&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;boolBB&lt;/span&gt;( &lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BBFalse&lt;/span&gt;); &lt;span class=&quot;c1&quot;&gt;# =&amp;gt; False&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Note that this works with either way of defining &lt;code&gt;BBTrue&lt;/code&gt; and &lt;code&gt;BBFalse&lt;/code&gt; because calling a function without arguments in Raku does not require parentheses.)&lt;/p&gt;

&lt;p&gt;We can do this more OO-like by making &lt;code&gt;bool&lt;/code&gt; a method of &lt;code&gt;BoolBB&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BoolBB&lt;/span&gt;[&lt;span class=&quot;nv&quot;&gt;&amp;amp;b&lt;/span&gt;] {
    &lt;span class=&quot;k&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unBoolBB&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;) {
        &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;);
    }

    &lt;span class=&quot;k&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt;() { 
        &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;unBoolBB&lt;/span&gt;( &lt;span class=&quot;nb&quot;&gt;True&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;False&lt;/span&gt;) 
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then we can say&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;BBTrue&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;# =&amp;gt; True&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;BBFalse&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;# =&amp;gt; False&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;boolBB&lt;/span&gt;( &lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BBTrue&lt;/span&gt;).&lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;# =&amp;gt; True&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;boolBB&lt;/span&gt;( &lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BBFalse&lt;/span&gt;).&lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;# =&amp;gt; False&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and I&amp;#39;m sure those dots will make some people happy.&lt;/p&gt;

&lt;p&gt;Note however that we do not really need the &lt;code&gt;bool&lt;/code&gt; method, instead we can simply compare the types:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;trueBB&lt;/span&gt; ~~ &lt;span class=&quot;n&quot;&gt;BBTrue&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;# =&amp;gt; True&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;BBFalse&lt;/span&gt; ~~ &lt;span class=&quot;n&quot;&gt;trueBB&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;# =&amp;gt; False&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can generalise this approach as an alternative to arbitrary enums. For example, and &lt;code&gt;RGB&lt;/code&gt; enum can be written very easily as a BB type:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RGB&lt;/span&gt;[&lt;span class=&quot;nv&quot;&gt;&amp;amp;b&lt;/span&gt;] {
    &lt;span class=&quot;k&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unRGB&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;) {
        &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;with selector functions &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;red&lt;/span&gt;  = -&amp;gt; \&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;,\&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;,\&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; { &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; }
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;green&lt;/span&gt; = -&amp;gt; \&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;,\&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;,\&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; { &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; }
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;blue&lt;/span&gt; = -&amp;gt; \&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;,\&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;,\&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; { &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, the main reason for using BB types is to make it easier to perform computations on the data structure encoded in the type. Constant sum types like &lt;code&gt;Bool&lt;/code&gt; and &lt;code&gt;RGB&lt;/code&gt; don&amp;#39;t store data to compute on, except in the most trivial way, and are therefore not the main target of this encoding. I presented them only because they are the easiest ones to explain.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/universal-interpreter-part-2&quot;&gt;second part&lt;/a&gt; of the article presents a worked example. But first, let&amp;#39;s look at a few more simple examples explaining more features of the BB approach.&lt;/p&gt;

&lt;h3&gt;The &lt;code&gt;Maybe&lt;/code&gt; type: a sum type with a polymorphic argument&lt;/h3&gt;

&lt;p&gt;The Boolean type above had two constructors without arguments. A simple algebraic data type where one of the constructors has an argument is the &lt;code&gt;Maybe&lt;/code&gt; type:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This type is used to express that a function does not always return a value of a given type. For example, if we look up a key in a map, it is possible that there is no entry for that key. So using &lt;code&gt;Maybe&lt;/code&gt; we could write a safe lookup function:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;safeLookup&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;%v&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$k&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;Maybe&lt;/span&gt;) {
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;  (&lt;span class=&quot;nv&quot;&gt;%v&lt;/span&gt;{&lt;span class=&quot;nv&quot;&gt;$k&lt;/span&gt;}:&lt;span class=&quot;n&quot;&gt;exists&lt;/span&gt;) {
        &lt;span class=&quot;n&quot;&gt;Just&lt;/span&gt;[&lt;span class=&quot;nv&quot;&gt;%v&lt;/span&gt;{&lt;span class=&quot;nv&quot;&gt;$k&lt;/span&gt;}].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
    } &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; {
        &lt;span class=&quot;n&quot;&gt;Nothing&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;Maybe&lt;/code&gt; type is polymorphic, so we have instances of &lt;code&gt;Maybe&lt;/code&gt; for any type we like.  In Haskell:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MayBB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MayBB&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;unMayBB&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- Just b &lt;/span&gt;
&lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- Nothing &lt;/span&gt;
&lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and in Raku:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MayBB&lt;/span&gt;[ &lt;span class=&quot;nv&quot;&gt;&amp;amp;mb&lt;/span&gt; ] {
    &lt;span class=&quot;k&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unMayBB&lt;/span&gt;(
        &lt;span class=&quot;nv&quot;&gt;&amp;amp;j:&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;),
        &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; 
        --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;
    ) {
        &lt;span class=&quot;n&quot;&gt;mb&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;&amp;amp;j&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We use a &lt;code&gt;Callable&lt;/code&gt; (&lt;code&gt;&amp;amp;j&lt;/code&gt;) for the &lt;code&gt;Just&lt;/code&gt; variant but a (sigil-less) scalar (&lt;code&gt;\n&lt;/code&gt;) for the &lt;code&gt;Nothing&lt;/code&gt; as it is a constant.&lt;/p&gt;

&lt;p&gt;As before for the BB Boolean, we create some helper functions. &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;First we have the &lt;em&gt;selectors&lt;/em&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# selectors&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bbj&lt;/span&gt;( \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; ) { -&amp;gt; &lt;span class=&quot;nv&quot;&gt;&amp;amp;j:&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;), &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; { &lt;span class=&quot;nv&quot;&gt;&amp;amp;j&lt;/span&gt;(&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;)} }
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bbn&lt;/span&gt; { -&amp;gt; &lt;span class=&quot;nv&quot;&gt;&amp;amp;j:&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;),&lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; {&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;} }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Then we have a wrapper to make role construction nicer:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mbb&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;&amp;amp;jm&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;MayBB&lt;/span&gt;) {
    &lt;span class=&quot;n&quot;&gt;MayBB&lt;/span&gt;[ &lt;span class=&quot;nv&quot;&gt;&amp;amp;jm&lt;/span&gt; ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;With these we can easily write the final BB type constructors:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Just&lt;/span&gt;(\&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;) { &lt;span class=&quot;n&quot;&gt;mbb&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bbj&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;) }
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Nothing&lt;/span&gt; { &lt;span class=&quot;n&quot;&gt;mbb&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bbn&lt;/span&gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we can create values of our &lt;code&gt;MayBB&lt;/code&gt; type, e.g.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MayBB&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;mbb&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MayBB&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;mbbn&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;Nothing&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As you can see, the BB type now functions exactly as an ordinary algebraic data type.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s make a simple printer for this type:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;printMayBB&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;MayBB&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;mb&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt;) {
    &lt;span class=&quot;n&quot;&gt;mb&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;unMayBB&lt;/span&gt;( &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (&lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt;) { &lt;span class=&quot;s&quot;&gt;&amp;quot;{x}&amp;quot;&lt;/span&gt; }, &lt;span class=&quot;s&quot;&gt;&amp;#39;NaN&amp;#39;&lt;/span&gt; );
}

&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;printMayBB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mbb&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;# =&amp;gt; 42&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;printMayBB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mbbn&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;# =&amp;gt; NaN&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As before, this function could be made a method of the &lt;code&gt;MayBB&lt;/code&gt; role if desired. The point to note however is that to create this printer, all we had to do was provide the right arguments to &lt;code&gt;unMayBB&lt;/code&gt;. We chose the concrete type &lt;code&gt;Str&lt;/code&gt; for the type parameter in the BB type. Recall that to turn the BB Boolean into an actual Boolean, all we had to do was to provide arguments of type &lt;code&gt;Bool&lt;/code&gt; to &lt;code&gt;unBoolBB&lt;/code&gt;. These are simple examples that already illustrate some of the power of the BB encoding.&lt;/p&gt;

&lt;h3&gt;A pair, the simplest product type&lt;/h3&gt;

&lt;p&gt;The two previous examples were for sum types. Let&amp;#39;s look at a simple product type, a pair of two values also known as a tuple. Assuming the tuple is polymorphic with type parameters &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt;, the BB type is in Haskell:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;PairBB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;PairBB&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;unPairBB&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and in Raku:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PairBB&lt;/span&gt;[ &lt;span class=&quot;nv&quot;&gt;&amp;amp;p&lt;/span&gt; ] {
    &lt;span class=&quot;k&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unPairBB&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;&amp;amp;p_:&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;,&lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;)  --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;) {
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;&amp;amp;p_&lt;/span&gt;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The selectors (for convenience we reuse the &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; functions used for the &lt;code&gt;BoolBB&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# To get the elements out of the pair&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fst&lt;/span&gt;( \&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; ){ &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;unPairBB&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;) }
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;snd&lt;/span&gt;( \&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; ){ &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;unPairBB&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;false&lt;/span&gt;) }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The pair constructor takes the values &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to be put in the pair, and uses them in an anonymous function used as the parameter for the role. The single argument of this anonymous function is a selector function &lt;code&gt;&amp;amp;p&lt;/code&gt;, which is applied to &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; in its body. &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Final pair constructor&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Pair&lt;/span&gt;(\&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;,\&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;PairBB&lt;/span&gt;) {
    &lt;span class=&quot;n&quot;&gt;PairBB&lt;/span&gt;[ -&amp;gt; &lt;span class=&quot;nv&quot;&gt;&amp;amp;p&lt;/span&gt; { &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;(&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;) } ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can use this to build pairs e.g.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PairBB&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;bbp&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;Pair&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;,&lt;span class=&quot;s&quot;&gt;&amp;quot;forty-two&amp;quot;&lt;/span&gt;;

&lt;span class=&quot;c1&quot;&gt;# print it&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;({fst bbp},{snd bbp})&amp;quot;&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;# =&amp;gt; (42,forty-two)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As with the Boolean, we can do this a bit more OO-like if you prefer by making &lt;code&gt;fst&lt;/code&gt; and &lt;code&gt;snd&lt;/code&gt; methods of the &lt;code&gt;PairBB&lt;/code&gt; role:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PairBB&lt;/span&gt;[ &lt;span class=&quot;nv&quot;&gt;&amp;amp;p&lt;/span&gt; ] {
    &lt;span class=&quot;k&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unPairBB&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;&amp;amp;p_:&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;,&lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;)  --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;) {
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;&amp;amp;p_&lt;/span&gt;);
    }

    &lt;span class=&quot;c1&quot;&gt;# To get the elements out of the pair&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fst&lt;/span&gt;( ){ &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;unPairBB&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;) }
    &lt;span class=&quot;k&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;snd&lt;/span&gt;( ){ &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;unPairBB&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;false&lt;/span&gt;) }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Thus we can say&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;({bbp.fst },{bbp.snd})&amp;quot;&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;# =&amp;gt; (42,forty-two)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;An important point is that the BB-encoded data structures are immutable, so you can&amp;#39;t update a field. Instead, you create a new variable:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PairBB&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;pbb2&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;Pair&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fst&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;pbb&lt;/span&gt;) + &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;s&quot;&gt;&amp;#39;forty-three&amp;#39;&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, let&amp;#39;s assume for a moment that our &lt;code&gt;PairBB&lt;/code&gt; represents a complex number and we want to convert it from (Real, Imaginary) into polar form (Modulus, Phase). Again we can use the same approach:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;toPolar&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;PairBB&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;mb&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;PairBB&lt;/span&gt;) {
    &lt;span class=&quot;n&quot;&gt;mb&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;unPairBB&lt;/span&gt;( &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (&lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;,&lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;PairBB&lt;/span&gt;) {
        &lt;span class=&quot;nb&quot;&gt;Pair&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sqrt&lt;/span&gt;(&lt;span class=&quot;o&quot;&gt;x*x+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;),&lt;span class=&quot;nb&quot;&gt;atan2&lt;/span&gt;(&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;);
    } );
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Summary&lt;/h2&gt;

&lt;p&gt;What we have learned so far is how to create sum (alternative) and product (record) types in Raku using a formalism called Böhm-Berarducci (BB) encoding, which uses functions to create data structures. We use Raku&amp;#39;s roles to implement BB types, and I have illustrated this with three simple examples: a sum type with two alternative constructors that do not take arguments (a Boolean), a sum type with two alternative constructors where one of them takes an argument (the Maybe type) and a product type for a pair of two values. &lt;/p&gt;

&lt;p&gt;In &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/universal-interpreter-part-2&quot;&gt;the next part&lt;/a&gt;, we will see how BB types make it easy tointerpreter create interpreters for complex data structures.&lt;/p&gt;

&lt;p&gt;The complete code for both articles is in &lt;a href=&quot;https://github.com/wimvanderbauwhede/raku-examples/blob/master/universal-interpreter.raku&quot;&gt;universal-interpreter.raku&lt;/a&gt;.&lt;/p&gt;

        </content>
    </entry>
    
    <entry>
        <title>Function types</title>
        <link href="https://wimvanderbauwhede.github.io/articles/function-types/"/>
        <updated>2020-08-07T00:00:00+01:00</updated>
        <id>https://wimvanderbauwhede.github.io/articles/function-types</id>
        <author>
					<name>Wim Vanderbauwhede</name>
					<uri>https://wimvanderbauwhede.github.io/</uri>
					
				</author>
        <content type="html">
        	&lt;img src=&quot;https://wimvanderbauwhede.github.io/images/function-types_1600x600.jpg&quot;&gt;&lt;br/&gt;
        	&lt;p&gt;This article builds on my earlier articles on &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/roles-as-adts-in-raku/&quot;&gt;algebraic data types&lt;/a&gt; in on &lt;a href=&quot;https://raku.org/&quot;&gt;Raku&lt;/a&gt; and their use in the practical example of &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/list-based-parser-combinators/&quot;&gt;list-based parser combinators&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;In this article I want to look at function types in some detail, and show a way to create well typed functions in Raku. If you are not familiar with functional programming (or with &lt;a href=&quot;https://raku.org/&quot;&gt;Raku&lt;/a&gt;), I suggest you read my introduction &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/decluttering-with-functional-programming/&quot;&gt;&amp;quot;Cleaner code with functional programming&amp;quot;&lt;/a&gt;. If you are not familiar with algebraic data types, you might want to read the other two articles as well. For most of the article, I provide examples in Raku, Python, Rust and Haskell. There is also some C and even some Fortran. &lt;/p&gt;

&lt;h2&gt;Type signatures&lt;/h2&gt;

&lt;p&gt;A function&amp;#39;s type signature consists of the types of each of its arguments and the return type. In most typed languages, the type is part of the function signature. &lt;/p&gt;

&lt;p&gt;For example in C&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sqsum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sqsum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;or in Fortran&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-fortran&quot; data-lang=&quot;fortran&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;integer &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sqsum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;integer&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sqsum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end function&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;or in Rust&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sqsum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;: &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sqsum&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;or in Raku&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqsum&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt;) {...}
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqsum&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt;) { &lt;span class=&quot;o&quot;&gt;x*x+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; }

&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&amp;amp;sqsum&lt;/span&gt; = &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (&lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt;) { &lt;span class=&quot;o&quot;&gt;x*x+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;or in Python, using the &lt;code&gt;typing&lt;/code&gt; module:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;typing&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Callable&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sqsum_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;  
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;sqsum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Callable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;The type of a function of functions&lt;/h2&gt;

&lt;p&gt;But what happens if we want to provide a function argument that is itself a function, or return a function (so-called &lt;em&gt;higher-order functions&lt;/em&gt;)?&lt;/p&gt;

&lt;p&gt;This is possible in most languages, but what I am interested in is the type information: what is the type signature of such a function of functions?&lt;/p&gt;

&lt;p&gt;C supports functions-of-functions indirectly through function pointers, by creating a function type through a &lt;code&gt;typedef&lt;/code&gt;. &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-C&quot; data-lang=&quot;C&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ten_times&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fun&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{...};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Maybe surprisingly, venerable old Fortran does support passing functions and subroutines as arguments. Functions are typed by their return type; subroutines are not typed. &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-fortran&quot; data-lang=&quot;fortran&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;program &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fof&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;external&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqsum&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;call &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ten_times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sqsum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end program &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fof&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;subroutine &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ten_times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;integer&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;! ...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end subroutine &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ten_times&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In Rust you can provide the complete type of a function-as-argument: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ten_times&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;: &lt;span class=&quot;nc&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;where&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;: &lt;span class=&quot;nb&quot;&gt;Fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;ten_times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sqsum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In Python we can use &lt;code&gt;Callable&lt;/code&gt;, which also allow for the complete type to be expressed.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;typing&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Callable&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ten_times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Callable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# ...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The same example in Raku becomes&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ten_times&lt;/span&gt; (&lt;span class=&quot;nb&quot;&gt;Sub&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;f:&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt;,&lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt;)) {
&lt;span class=&quot;c1&quot;&gt;#...&lt;/span&gt;
}

&lt;span class=&quot;n&quot;&gt;ten_times&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;sqsum&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So we can also pass the complete type. An equivalent way to write this is using the &lt;code&gt;&amp;amp;&lt;/code&gt; sigil &lt;a href=&quot;https://docs.raku.org/language/variables#index-entry-sigil_&amp;&quot;&gt;which imposes the &lt;code&gt;Callable&lt;/code&gt; type constraint&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ten_times&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;&amp;amp;f:&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt;,&lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt;)) {
&lt;span class=&quot;c1&quot;&gt;#...&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The types can be nested too, e.g. &lt;code&gt;((Int, Int --&amp;gt; Int), (Int, Int --&amp;gt; Int) --&amp;gt; Int))&lt;/code&gt; is a valid type signature.&lt;/p&gt;

&lt;!--


--------
fn main() {
 
    let sqsum  = |x : i32, y: i32| -&gt; i32 {x*x+y*y};
    let res = sqsum(4,3);
 
    fn ten_times&lt;F&gt;(f: F  ) -&gt; i3 where F: Fn(i32,i32) -&gt; i32 {
        for index in 0..10 {
            let res = f(index,index+1);
            println!(&quot;{}&quot;,res);
        }
    }    
    ten_times(sqsum);
}

--------

from typing import Callable

sqsum : Callable[[int,int], int]  = lambda x,y : x*x+y*y
def sqsum_(x: int, y: int) -&gt; int:  
    return x*x+y*y
res : int = sqsum(4,3)

def ten_times(f: Callable[[int, int],int]) -&gt; int:
    for index in range(0,11):
        res = f(index,index+1)
        print(res)
    
ten_times(sqsum)

--------
--&gt;

&lt;h2&gt;Introducing the arrow&lt;/h2&gt;

&lt;p&gt;All of the above ways to express function type signatures are perfectly adequate in their respective languages. However, with the exception of Raku, they all share the problem that these function-of-function type signatures don&amp;#39;t compose very well: what if we want to write a function-of-function-of-function type? This is less far-fetched than it may seem.
I would like to introduce a notation used in type theory. It is at the same time simple and powerful. If you are familiar with functional languages like Haskell, Idris or Agda, you already know it. &lt;/p&gt;

&lt;p&gt;Instead of mixing the type with the function declaration, it is written separately. The name of the function is followed by a colon and the list types of the arguments and the return value. Each argument is separated by an arrow. The above example of a function of two integer arguments returning an integer would be:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sqsum&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟶&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟶&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The function-of-a-function introduced above has as type:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ten_times&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟶&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟶&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟶&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The parentheses group the type of the function that is the only argument of &lt;code&gt;ten_times&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In this notation, the arrow can be interpreted as an operator which creates a function type from the two types that are its arguments. The important property of this operator is that it is right associative. What this means is that for example &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟶&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟶&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t3&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟶&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is the same as&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟶&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟶&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t3&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟶&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and as&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟶&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟶&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t3&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟶&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and for completeness&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟶&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟶&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t3&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟶&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;A detour into partial application&lt;/h2&gt;

&lt;p&gt;The above groupings imply that our function &lt;code&gt;f&lt;/code&gt; can be interpreted in three ways, as a function of:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;3 arguments of types &lt;code&gt;t1&lt;/code&gt;,&lt;code&gt;t2&lt;/code&gt;,&lt;code&gt;t3&lt;/code&gt;, returning a result of type &lt;code&gt;t4&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;2 arguments of types &lt;code&gt;t1&lt;/code&gt;,&lt;code&gt;t2&lt;/code&gt;, returning a result of type &lt;code&gt;t3 -&amp;gt; t4&lt;/code&gt;; &lt;/li&gt;
&lt;li&gt;1 argument of types &lt;code&gt;t1&lt;/code&gt;, returning a result of type &lt;code&gt;t2-&amp;gt;t3-&amp;gt;t4&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let&amp;#39;s say we have values &lt;code&gt;v1&lt;/code&gt;,&lt;code&gt;v2&lt;/code&gt;,&lt;code&gt;v3&lt;/code&gt; for the arguments and &lt;code&gt;v4&lt;/code&gt; as the result:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;v4&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t4&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;v4&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But suppose we only apply &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;pf1 : t3 ⟶ t4
pf1 = f v1 v2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We get a new function &lt;code&gt;pf1&lt;/code&gt; which takes a single argument &lt;code&gt;v3&lt;/code&gt;: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;v4&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pf1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And in the same way we can create &lt;code&gt;pf2&lt;/code&gt; and &lt;code&gt;pf3&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;pf2&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟶&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t3&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟶&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t4&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;pf2&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;pf3&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t3&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟶&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t4&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;pf3&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pf2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;v4&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pf3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Because &lt;code&gt;pf1&lt;/code&gt;, &lt;code&gt;pf2&lt;/code&gt; and &lt;code&gt;pf3&lt;/code&gt; are functions and the above is true for all values of &lt;code&gt;v1&lt;/code&gt;, &lt;code&gt;v2&lt;/code&gt;, &lt;code&gt;v3&lt;/code&gt; and &lt;code&gt;v4&lt;/code&gt;, it follows that&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;pf3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pf1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For completeness, we can also apply &lt;code&gt;pf2&lt;/code&gt; directly to two arguments:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;v4&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pf2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This concept of creating a new function by not providing values for some of the arguments is called &lt;em&gt;partial application&lt;/em&gt;, and many languages support it. Here are examples in Haskell, Raku, Python and Rust.&lt;/p&gt;

&lt;h3&gt;Haskell&lt;/h3&gt;

&lt;p&gt;In case you are not familiar with Haskell, this is what you need to know: it is whitespace-sensitive like Python, but has a markedly different syntax. Because everything is a function, there is no keyword to mark a function. Because there is only lexical scope, there is no need for any special scope identifiers. Function arguments are separated by spaces. Lambda functions (anonymous functions) start with a &lt;code&gt;\&lt;/code&gt;,  chosen because it looks a bit like the Greek letter lambda, λ. &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;-- named function of 2 arguments&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sqsum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- lambda function bound to a named variable&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sqsum&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The type of &lt;code&gt;sqsum&lt;/code&gt; is 
&lt;code&gt;haskell
sqsum :: Int -&amp;gt; Int -&amp;gt; Int
&lt;/code&gt;
(Haskell uses &lt;code&gt;::&lt;/code&gt; rather than &lt;code&gt;:&lt;/code&gt; for the type signature)&lt;/p&gt;

&lt;p&gt;In Haskell, partial application works exactly as in the examples above. So our function &lt;code&gt;sqsum&lt;/code&gt; can be partially applied like this: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sqsum4&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sqsum4&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqsum&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can apply &lt;code&gt;sqsum4&lt;/code&gt; to the remaining argument:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sqsum4&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- returns 25&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is very neat. But suppose you want to apply the second argument, rather than the first one? The Haskell Prelude library provides the function &lt;a href=&quot;https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html#v:flip&quot;&gt;flip&lt;/a&gt;, which simply flips the arguments:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;flip&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; 
&lt;span class=&quot;nf&quot;&gt;flip&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That is fine as far as it goes, but let&amp;#39;s do a somewhat contrived example. Let&amp;#39;s say we have a function of four arguments:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t3&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t4&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tr&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x4&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and we want to apply the 1st and 4th argument but not the others, something like &lt;code&gt;g v1 _ _ v4&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;One way to do this is to create yet another function (of course!):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;apply14&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t3&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t4&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t4&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t3&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;apply14&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x4&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x3&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And with this function we can partially apply the 1st and 4th argument of &lt;code&gt;g&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;g14&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;apply14&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This example mainly serves to illustrate the power of the arrow-based function type notation: it lays out the type of &lt;code&gt;apply14&lt;/code&gt; clearly and concisely. &lt;/p&gt;

&lt;h3&gt;Raku&lt;/h3&gt;

&lt;p&gt;Raku provides the method &lt;a href=&quot;https://docs.raku.org/routine/assuming&quot;&gt;assuming&lt;/a&gt;, which acts as a generalised version of our &lt;code&gt;apply14&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&amp;amp;g14&lt;/span&gt; = &lt;span class=&quot;nv&quot;&gt;&amp;amp;g&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;assuming&lt;/span&gt;( &lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;, *, *, &lt;span class=&quot;n&quot;&gt;v4&lt;/span&gt;);

&lt;span class=&quot;n&quot;&gt;g14&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;v3&lt;/span&gt;); 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The return type of &lt;code&gt;assuming&lt;/code&gt; is a &lt;code&gt;Callable&lt;/code&gt;. This is a role for objects which support calling them. Thus, &lt;code&gt;g14&lt;/code&gt; can be called as if it was a regular function.&lt;/p&gt;

&lt;h3&gt;Python&lt;/h3&gt;

&lt;p&gt;Python&amp;#39;s &lt;a href=&quot;https://docs.python.org/2/library/functools.html&quot;&gt;functools&lt;/a&gt; provide the &lt;code&gt;partial&lt;/code&gt; function:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;functools&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;partial&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;g14&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;partial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;g14&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The return type of &lt;code&gt;partial&lt;/code&gt; is a &lt;code&gt;partial&lt;/code&gt; object, which has an attribute &lt;code&gt;partial.func&lt;/code&gt;, a callable object or function. Calls to the partial object will be forwarded to func with new arguments and keywords, so you can say &lt;code&gt;g14(v2,v3)&lt;/code&gt; instead of &lt;code&gt;g14.func(v2,v3)&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Rust&lt;/h3&gt;

&lt;p&gt;Rust provides the &lt;code&gt;partial!&lt;/code&gt; macro via its &lt;a href=&quot;https://docs.rs/partial_application/0.2.1/partial_application/&quot;&gt;partial_application&lt;/a&gt; crate. Its behaviour is very similar to our &lt;code&gt;apply14&lt;/code&gt;: &amp;quot;&lt;code&gt;partial!(some_fn =&amp;gt; arg0, _, arg2, _)&lt;/code&gt; returns the closure &lt;code&gt;|x1, x3| some_fn(arg0, x1, arg2, x3)&lt;/code&gt;&amp;quot;. &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#[macro_use]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;crate&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;partial_application&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x1&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x3&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x4&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x4&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g14&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;partial&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;

&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g14&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Back to the function types&lt;/h2&gt;

&lt;p&gt;Suppose we want a type like the one we defined in C using a &lt;code&gt;typedef&lt;/code&gt;, which encapsulates the function type:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In Haskell, that would be&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Fun&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Fun&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and we can generalise this to be a generic function of two arguments by using type variables instead of concrete types:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Fun2Args&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Fun2Args&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So how would we use this? Let&amp;#39;s create an instance&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ft&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Fun2Args&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;ft&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Fun2Args&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is fine, but to apply the function we first must unwrap the type constructor:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Fun2Args&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ft&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That is not very handy. A better way is to use the record type syntax which gives us an accessor function:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Fun2Args&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Fun2Args&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unF&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;ft&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Fun2Args&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unF&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now I have applied this to integer, but the type of the function is &lt;code&gt;Num a =&amp;gt; a -&amp;gt; a -&amp;gt; a&lt;/code&gt;, so this works for any type in the &lt;code&gt;Num&lt;/code&gt; typeclass.&lt;/p&gt;

&lt;h2&gt;Named function types for Raku&lt;/h2&gt;

&lt;p&gt;In Raku, we can follow a similar approach of wrapping a function signature in a type, and it is actually simpler than in Haskell. We create a parametric role which takes the function as a parameter, and has a method with the signature of the function:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fun2NumArgs&lt;/span&gt;[&lt;span class=&quot;nv&quot;&gt;&amp;amp;b&lt;/span&gt;] {
    &lt;span class=&quot;k&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unF&lt;/span&gt;( &lt;span class=&quot;n&quot;&gt;Numeric&lt;/span&gt; \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;,  &lt;span class=&quot;n&quot;&gt;Numeric&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;Numeric&lt;/span&gt;) {
        &lt;span class=&quot;nv&quot;&gt;&amp;amp;b&lt;/span&gt;(&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;);
    }
}

&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;ft&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;Fun2NumArgs&lt;/span&gt;[ -&amp;gt;\&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;,\&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; {&lt;span class=&quot;o&quot;&gt;x*x+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;} ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;

&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ft&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;unF&lt;/span&gt;(&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;); 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But what is the benefit of doing this? Surely we could just have done&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&amp;amp;f&lt;/span&gt; =  -&amp;gt; &lt;span class=&quot;n&quot;&gt;Numeric&lt;/span&gt; \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;Numeric&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;Numeric&lt;/span&gt; {&lt;span class=&quot;o&quot;&gt;x*x+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;};

&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For this simple example, that would indeed be enough as we don&amp;#39;t have functions of functions. But what we gain is that we can now create a function with arguments of type &lt;code&gt;Fun2NumArgs&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fof&lt;/span&gt; (&lt;span class=&quot;n&quot;&gt;Fun2NumArgs&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;f1&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;Fun2NumArgs&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;f2&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;Fun2NumArgs&lt;/span&gt;) {
...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In other words, we can now have explicitly typed function signatures in Raku. Recall that without this approach, the type of a function would be &lt;code&gt;Code&lt;/code&gt; or any dependant in &lt;a href=&quot;https://docs.raku.org/type/Code#Type_Graph&quot;&gt;the Code type graph&lt;/a&gt;. With the role-based type, the function must have the type of the method &lt;code&gt;unF&lt;/code&gt;. Furthermore, these function types can be nested. Let&amp;#39;s create another type, for a function with two arguments of any type: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fun2Args&lt;/span&gt;[&lt;span class=&quot;nv&quot;&gt;&amp;amp;b&lt;/span&gt;] {
    &lt;span class=&quot;k&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unF&lt;/span&gt;( &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;) {
        &lt;span class=&quot;nv&quot;&gt;&amp;amp;b&lt;/span&gt;(&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We create two instances of &lt;code&gt;Fun2NumArgs&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;ft&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;Fun2NumArgs&lt;/span&gt;[ -&amp;gt;\&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;,\&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; {&lt;span class=&quot;o&quot;&gt;x*x+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;} ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;ft2&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;Fun2NumArgs&lt;/span&gt;[ -&amp;gt;\&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;,\&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; {&lt;span class=&quot;o&quot;&gt;x*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+x&lt;/span&gt;} ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And a function of these two functions using &lt;code&gt;Fun2Args&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;fof2&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;Fun2Args&lt;/span&gt;[ 
        &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (&lt;span class=&quot;n&quot;&gt;Fun2NumArgs&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;f1&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;Fun2NumArgs&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;f2&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;Fun2NumArgs&lt;/span&gt;) {
            &lt;span class=&quot;c1&quot;&gt;# returns another function of 2 Numeric arguments&lt;/span&gt;
        } 
    ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can now call the returned function like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fof2&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;unF&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;ft&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;ft2&lt;/span&gt;).&lt;span class=&quot;n&quot;&gt;unF&lt;/span&gt;(&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Having to call the &lt;code&gt;unF&lt;/code&gt; method is not optimal. A better way is to can make the object itself callable instead, by defining &lt;a href=&quot;https://docs.raku.org/routine/CALL-ME&quot;&gt;the submethod &lt;code&gt;CALL-ME&lt;/code&gt;&lt;/a&gt; instead of the method &lt;code&gt;unF&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fun2Args&lt;/span&gt;[&lt;span class=&quot;nv&quot;&gt;&amp;amp;b&lt;/span&gt;] {
    &lt;span class=&quot;k&quot;&gt;submethod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CALL-ME&lt;/span&gt;( \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;,  \&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;) {
        &lt;span class=&quot;nv&quot;&gt;&amp;amp;b&lt;/span&gt;(&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;);
    }
}

&lt;span class=&quot;c1&quot;&gt;# And similar for Fun2NumArgs&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this way, we can do:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fof2&lt;/span&gt;.(&lt;span class=&quot;n&quot;&gt;ft&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;ft2&lt;/span&gt;)(&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is almost what we want. But we can remove the &lt;code&gt;.&lt;/code&gt; as well, by making &lt;code&gt;fof2&lt;/code&gt; of type &lt;code&gt;Callable&lt;/code&gt;. We can indicate this with the &lt;code&gt;&amp;amp;&lt;/code&gt; sigil. But with the current definition of &lt;code&gt;Fun2Args&lt;/code&gt;, this will result in a type error because &lt;code&gt;Fun2Args&lt;/code&gt; is not callable. However, &lt;code&gt;Callable&lt;/code&gt; is a role so all we need to do is mix it in:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fun2ArgsC&lt;/span&gt;[&lt;span class=&quot;nv&quot;&gt;&amp;amp;b&lt;/span&gt;] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Callable&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;submethod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CALL-ME&lt;/span&gt;( \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;,  \&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Any&lt;/span&gt;) {
        &lt;span class=&quot;nv&quot;&gt;&amp;amp;b&lt;/span&gt;(&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this way we have created something very similar to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Function_object&quot;&gt;function object&lt;/a&gt;, but using a role rather than a class. And now we can write:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&amp;amp;fof3&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;Fun2ArgsC&lt;/span&gt;[ 
        &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (&lt;span class=&quot;n&quot;&gt;Fun2NumArgs&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;f1&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;Fun2NumArgs&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;f2&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;Fun2NumArgs&lt;/span&gt;) {
            ...
        } 
    ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;

&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fof3&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;ft&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;ft2&lt;/span&gt;)(&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To summarize, we create a parametric callable role where the parameter is the function to be called, and the signature of the CALL-ME submethod provides the type constraint to that function. Passing a function with a different signature will give a type error. &lt;/p&gt;

&lt;p&gt;I think this is a nice way to have some additional type safety in your functional Raku code.&lt;/p&gt;

&lt;h2&gt;Bonus Tracks&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=StKVS0eI85I&quot;&gt;&amp;quot;Call Me&amp;quot; by Blondie&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=_04CojexsYw&quot;&gt;&amp;quot;CALL ME&amp;quot; (「コール・ミー」) by Drop&amp;#39;s&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!--
But we can also have    

```haskell
newtype Fun2Args = Fun2Args forall a . a -&gt; a -&gt; a
```


Prelude&gt; newtype Fun2Args = Fun2Args { unF::forall a . Num a =&gt; a -&gt; a -&gt; a}
Prelude&gt; ft = Fun2Args (\x y -&gt; x+y)
Prelude&gt; :t ft
ft :: Fun2Args
Prelude&gt; :t unF ft
unF ft :: Num a =&gt; a -&gt; a -&gt; a
Prelude&gt; :t unF ft
unF ft :: Num a =&gt; a -&gt; a -&gt; a
Prelude&gt; (unF ft) 3 4
7
Prelude&gt; (unF ft) 3.4 4.5
7.9
Prelude&gt; 
--
--&gt;

        </content>
    </entry>
    
    <entry>
        <title>Cleaner code with functional programming</title>
        <link href="https://wimvanderbauwhede.github.io/articles/decluttering-with-functional-programming/"/>
        <updated>2020-07-18T00:00:00+01:00</updated>
        <id>https://wimvanderbauwhede.github.io/articles/decluttering-with-functional-programming</id>
        <author>
					<name>Wim Vanderbauwhede</name>
					<uri>https://wimvanderbauwhede.github.io/</uri>
					
				</author>
        <content type="html">
        	&lt;img src=&quot;https://wimvanderbauwhede.github.io/images/decluttering-with-functional-programming_1600x600.jpg&quot;&gt;&lt;br/&gt;
        	&lt;!-- To a functional programmer like me, every programming language is a functional language. --&gt; 

&lt;p&gt;Functional programming is a style of programming and modern languages support this style to a greater or lesser extent. In this article I want to explain how programming in a functional style provides you with powerful abstractions to make your code cleaner. I will illustrate this with examples in Raku and Python, which as we will see are both excellent languages for functional programming.&lt;/p&gt;

&lt;h2&gt;Raku: a quick introduction&lt;/h2&gt;

&lt;p&gt;The code examples in this article are written in &lt;a href=&quot;https://www.python.org/&quot;&gt;Python&lt;/a&gt; and &lt;a href=&quot;https://raku.org/&quot;&gt;Raku&lt;/a&gt;. I assume most people are familiar with Python, but Raku is less well known, so I will explain the basics first. The code in this article is not very idiomatic so you should be able to understand it easily if you know another programming language.&lt;/p&gt;

&lt;p&gt;Raku is most similar to &lt;a href=&quot;https://www.perl.org&quot;&gt;Perl&lt;/a&gt;. Both languages are syntactically similar to C/C++, Java and JavaScript: block-based, with statements separated by semicolons, blocks demarcated by braces, and argument lists in parentheses and separated by commas. The main feature that sets Perl and Raku apart from other languages is the use of sigils (&amp;#39;funny characters&amp;#39;) which identify the type of a variable: &lt;code&gt;$&lt;/code&gt; for a scalar, &lt;code&gt;@&lt;/code&gt; for an array, &lt;code&gt;%&lt;/code&gt; for a hash (map) and &lt;code&gt;&amp;amp;&lt;/code&gt; for a subroutine. Variables also have keywords to identify their scope, I will only use &lt;code&gt;my&lt;/code&gt; which marks the variable as lexically scoped. A subroutine is declared with the &lt;code&gt;sub&lt;/code&gt; keyword, and subroutines can be named or anonymous:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;square&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt;) {
    &lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt;*&lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt;;
}
&lt;span class=&quot;c1&quot;&gt;# anonymous subroutine &lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$anon_square&lt;/span&gt; = &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt;) {
    &lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt;*&lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In Python this would be:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;square&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# anonymous subroutine &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;anon_square&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;!-- Raku also has [twigils](https://docs.raku.org/language/variables#index-entry-Twigil), secondary sigils that influence the scoping of a variable. For this article, the only twigil used in the code is `.` which is used to declare a role or class attribute with automatically generated accessors (like `$.notes` in the example below). --&gt;

&lt;p&gt;Raku supports sigil-less variables, and uses the &lt;code&gt;\&lt;/code&gt; syntax to declare them. For more on the difference between ordinary and sigil-less variables, see &lt;a href=&quot;https://docs.raku.org/language/variables#Sigilless_variables&quot;&gt;the Raku documentation&lt;/a&gt;. For example (&lt;code&gt;say&lt;/code&gt; prints its argument followed by a newline):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; = &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;# sigilless&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$y&lt;/span&gt; = &lt;span class=&quot;mi&quot;&gt;43&lt;/span&gt;; 
&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; + &lt;span class=&quot;nv&quot;&gt;$y&lt;/span&gt;; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the code in this article, I will use the sigil-less variables whenever possible.&lt;/p&gt;

&lt;p&gt;Raku has several types of sequence data structures. In the code below I will use &lt;a href=&quot;https://docs.raku.org/language/list&quot;&gt;lists and arrays&lt;/a&gt; and &lt;a href=&quot;https://docs.raku.org/type/Range&quot;&gt;ranges&lt;/a&gt;. The main difference between a list and an array in Raku is that a list is immutable, which means that once created, it can&amp;#39;t be modified. So it is a read-only data structure. To &amp;#39;update&amp;#39; an immutable data structure, you need to create an updated copy. Arrays on the other hand are mutable, so we can update their elements, extend them, shrink them etc. All updates happen in place on the original. &lt;/p&gt;

&lt;p&gt;Raku&amp;#39;s arrays are similar to Python&amp;#39;s lists and Raku&amp;#39;s lists are similar to Python&amp;#39;s tuples, which are also immutable. Apart from the syntax, ranges in Raku are similar to ranges in Python, and both are immutable.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@array1&lt;/span&gt; = &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; an array because of the &amp;#39;@&amp;#39; sigil&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;array2&lt;/span&gt; = [&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;]; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; an array, because of the &amp;#39;[...]&amp;#39;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;range1&lt;/span&gt; = &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; .. &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; a range 1 .. 10&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@array3&lt;/span&gt; = &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; .. &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; an array from a range, because of the &amp;#39;@&amp;#39; sigil&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;list1&lt;/span&gt; = &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; a list&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$list2&lt;/span&gt; = (&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;); &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; also a list&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;list3&lt;/span&gt; = |(&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; .. &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;);  &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; an array from a range because of the &amp;#39;|&amp;#39; flattening operation&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The equivalent Python code would be&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; a list from a tuple&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;list2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; a list, because of the &amp;#39;[...]&amp;#39;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;range1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; a range 1 .. 10&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;list3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; a list from a range&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;tuple1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; a tuple&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tuple2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;tuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; a tuple from a list&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tuple3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;tuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; creates a tuple from a range&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Other specific bits of syntax or functionality will be explained for the particular examples. &lt;/p&gt;

&lt;h2&gt;&lt;em&gt;A function, by any other name&lt;/em&gt; &amp;mdash; functions as values&lt;/h2&gt;

&lt;p&gt;Functions are the essence of functional programming. As I explained in my article &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/everything-is-a-function&quot;&gt;&amp;quot;Everything is a function&amp;quot;&lt;/a&gt;, in a proper functional language, all constructs are built from functions. &lt;/p&gt;

&lt;p&gt;All modern programming languages have a notion of functions, procedures, subroutines or methods. They are an essential mechanism for code reuse.
Typically, we think of a function as something that operates on some input values to produce one or more output values. The input values can be globally declared, attributes of a class or passed as arguments to the function. Similarly, the output values can be returned directly, to global variables, as class attributes or by modifying the input values. &lt;/p&gt;

&lt;p&gt;To benefit most from functional programming, it is best if functions are &lt;em&gt;pure&lt;/em&gt;, which means that a call to the function always produces the same output for the same inputs. In practice, this is easier to achieve if the function only takes inputs as arguments and returns the output directly, but this is not essential.&lt;/p&gt;

&lt;p&gt;The crucial feature of functional programming is that the input and output values of a function &lt;em&gt;can themselves be functions&lt;/em&gt;. So functions must be values in your language. Sometimes this is called &amp;quot;functions must be first-class&amp;quot;, and a function that takes and/or returns a function is sometimes called a &amp;quot;higher-order function&amp;quot;. &lt;/p&gt;

&lt;p&gt;If functions are values, it follows that we can assign them to variables. In particular we will assign them to the arguments of other functions. But we can also assign them to ordinary variables. &lt;/p&gt;

&lt;p&gt;Let&amp;#39;s consider the following function, &lt;code&gt;choose&lt;/code&gt;, which takes three arguments &lt;code&gt;t&lt;/code&gt;, &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;. &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Raku&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;choose&lt;/span&gt; (\&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;) {
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;) {&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;} &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; {&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Python&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;choose&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;First let&amp;#39;s call &lt;code&gt;choose&lt;/code&gt; with strings as values for the first two arguments:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Raku&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;tstr&lt;/span&gt; = &lt;span class=&quot;s&quot;&gt;&amp;quot;True!&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;fstr&lt;/span&gt; = &lt;span class=&quot;s&quot;&gt;&amp;quot;False!&amp;quot;&lt;/span&gt;;

&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;res_str&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;choose&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;tstr&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;fstr&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;True&lt;/span&gt;);

&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res_str&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; says &amp;quot;True!&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Python&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tstr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;True!&amp;quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fstr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;False!&amp;quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;res_str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;choose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;res_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; says &amp;quot;True!&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now let&amp;#39;s try with functions as arguments:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Raku&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tt&lt;/span&gt; (\&lt;span class=&quot;o&quot;&gt;s&lt;/span&gt;) { &lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;True {s}!&amp;quot;&lt;/span&gt; }
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;ff&lt;/span&gt; (\&lt;span class=&quot;o&quot;&gt;s&lt;/span&gt;) { &lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;False {s}!&amp;quot;&lt;/span&gt; }

&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&amp;amp;res_f&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;choose&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;&amp;amp;tt&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;&amp;amp;ff&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;False&lt;/span&gt;);

&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&amp;amp;res_f&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; says &amp;amp;ff&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;res_f&lt;/span&gt;(&lt;span class=&quot;s&quot;&gt;&amp;quot;rumour&amp;quot;&lt;/span&gt;); &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; says &amp;quot;False rumour!&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Python&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;tt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;True &amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;!&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;  
  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;False&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;!&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;res_f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;choose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;res_f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; says &amp;lt;function tt at 0x7f829c3aa310&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;res_f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;rumour&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; says &amp;quot;False rumour!&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So our function &lt;code&gt;choose&lt;/code&gt; took two functions as its first two arguments, and returned a function. In Raku we need the &lt;code&gt;&amp;amp;&lt;/code&gt; sigil on the function names because otherwise they would be evaluated: a bare function name like &lt;code&gt;tt&lt;/code&gt; is the same as calling the function without arguments, &lt;code&gt;tt()&lt;/code&gt;. By assigning this function to a variable (&lt;code&gt;res_f&lt;/code&gt;), we can now call &lt;code&gt;res_f&lt;/code&gt; as a function and it will eventually call &lt;code&gt;tt&lt;/code&gt; or &lt;code&gt;ff&lt;/code&gt; depending of the choice.&lt;/p&gt;

&lt;h2&gt;Functions don&amp;#39;t need a name&lt;/h2&gt;

&lt;p&gt;Now, if we can assign functions to variables, they don&amp;#39;t really need a name themselves. So our functions can be anonymous. Most languages support anonymous functions. In functional languages they are usually called &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/everything-is-a-function/&quot;&gt;&amp;quot;lambda functions&amp;quot;&lt;/a&gt;. In Raku, we have two ways to create anonymous functions:&lt;/p&gt;

&lt;p&gt;Using the &lt;code&gt;sub (...)&lt;/code&gt; syntax:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;tt&lt;/span&gt; = &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (\&lt;span class=&quot;o&quot;&gt;s&lt;/span&gt;) { &lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;True {s}!&amp;quot;&lt;/span&gt; };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or using the &lt;a href=&quot;https://docs.raku.org/language/functions#index-entry-pointy_blocks&quot;&gt;&amp;#39;pointy block&amp;#39; syntax&lt;/a&gt;, which is a little bit more compact:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;o&quot;&gt;ff&lt;/span&gt; = -&amp;gt; \&lt;span class=&quot;o&quot;&gt;s&lt;/span&gt; { &lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;False {s}!&amp;quot;&lt;/span&gt; };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Python uses the &lt;code&gt;lambda&lt;/code&gt; keyword:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;True &amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;!&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ff&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;False &amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;!&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So now we can say&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&amp;amp;res_f&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;choose&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;tt&lt;/span&gt;, &lt;span class=&quot;o&quot;&gt;ff&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;True&lt;/span&gt;);

&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&amp;amp;res_f&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; says sub { }&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;res_f&lt;/span&gt;(&lt;span class=&quot;s&quot;&gt;&amp;quot;story&amp;quot;&lt;/span&gt;); &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; says &amp;quot;True story!&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When we print out the variable to which the function is bound, Raku returns &lt;code&gt;sub { }&lt;/code&gt; to indicate that the variable contains a function.&lt;/p&gt;

&lt;p&gt;In Python:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;res_f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;choose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res_f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; says &amp;lt;function &amp;lt;lambda&amp;gt; at 0x7f829b298b80&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;res_f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;story&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; says &amp;quot;True story!&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Examples: &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;grep&lt;/code&gt; and &lt;code&gt;reduce&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Functions of functions have many uses, and I just want to highlight three examples that are available readily in Raku: &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt; and &lt;code&gt;grep&lt;/code&gt;. Python has &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt;, and provides &lt;code&gt;reduce&lt;/code&gt; via the &lt;code&gt;functools&lt;/code&gt; module. What these functions have in common is that they offer an alternative to &lt;code&gt;for&lt;/code&gt;-loops over lists.&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;map&lt;/code&gt; : applying a function to all elements of a list&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;map&lt;/code&gt; takes two arguments: a function and a list. It applies the function to all values in the list in order and returns the results, for example to square all values in a list:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; -&amp;gt; \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; {&lt;span class=&quot;o&quot;&gt;x*x&lt;/span&gt;} , &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; .. &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In Python we need to explicitly create the tuple, but apart from the syntax differences, the structure is quite the same:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;tuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is the functional alternative to the more conventional &lt;code&gt;for&lt;/code&gt;-loop:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Raku&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; = [];
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; .. &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; -&amp;gt; \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; {
    &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;o&quot;&gt;x*x&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Python&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that in both Raku and Python we need to use a mutable data structure for the &lt;code&gt;for&lt;/code&gt;-loop version, whereas the &lt;code&gt;map&lt;/code&gt; version uses immutable data structures.&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;grep&lt;/code&gt; : filtering a list&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;grep&lt;/code&gt; (called &lt;code&gt;filter&lt;/code&gt; in Python) also takes arguments, a function and a list, but it only returns the values from the list for which the function returns &lt;code&gt;true&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Raku&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; -&amp;gt; \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; { &lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; % &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; == &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; }, &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; .. &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Python&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;tuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can of course write this using a &lt;code&gt;for&lt;/code&gt;-loop and an &lt;code&gt;if&lt;/code&gt;-statement, but that again requires a mutable data structure:  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Raku&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; = [];
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; .. &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt; -&amp;gt; \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; % &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; == &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;) {
    &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Python&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What&amp;#39;s nice about &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;grep&lt;/code&gt; is that you can easily chain them together:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Raku&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; -&amp;gt; \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; { &lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; % &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; == &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; }, &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; -&amp;gt; \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; {&lt;span class=&quot;o&quot;&gt;x*x&lt;/span&gt;}, &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Python&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;tuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is because &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;grep&lt;/code&gt; take a list and return a list, so as long as you need to operate on a list, you can do this by chaining the calls.&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;reduce&lt;/code&gt; : combining all elements of a list into a single value&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;reduce&lt;/code&gt; also takes a function and a list, but it uses the function to combine all elements of the list into a single result. So the function must take two arguments. The &lt;em&gt;second&lt;/em&gt; argument is the element taken from the list, and the first argument is used as a state variable to combine all elements. For example, calculating the sum of a list of numbers:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Raku&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;reduce&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (\&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;,\&lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;) {&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;}, &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; .. &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;;

&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt;; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; says 55&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Python&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;functools&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;reduce&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;reduce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; says 55&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What happens here is that &lt;code&gt;acc&lt;/code&gt; is first set to the first element of the list (1), and then the second element is added to it, so &lt;code&gt;acc&lt;/code&gt; becomes 1+2=3; then the third element (3) is added to this, and so on. The effect is to consecutively sum all the numbers in list.&lt;/p&gt;

&lt;p&gt;To make this more clear, let&amp;#39;s write our own version of &lt;code&gt;reduce&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Writing your own&lt;/h3&gt;

&lt;p&gt;In many functional languages, a distinction is made between a left-to-right (starting at the lowest index) and right-to-left (starting at the highest index) reduction. This matters because depending on the function doing the reducing, the result can be different if the list is consumed from the left or from the right. For example, suppose our reducing function is&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Raku&lt;/span&gt;
-&amp;gt; \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;,\&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; {&lt;span class=&quot;o&quot;&gt;x+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Python&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;then it does not matter which direction we traverse the list. But consider the following function:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Raku&lt;/span&gt;
-&amp;gt; \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;,\&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; { &lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; &amp;lt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; ?? &lt;span class=&quot;o&quot;&gt;x+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; !! &lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Python&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;( &lt;code&gt;... ?? ... !! ...&lt;/code&gt; is the Raku syntax for the conditional operator which is  &lt;code&gt;... ? ... : ...&lt;/code&gt; in most other languages and &lt;code&gt;... if ... else ...&lt;/code&gt; in Python)&lt;/p&gt;

&lt;p&gt;In this case the result will be different if the list is reduced from the left or from the right. In Raku and Python, &lt;code&gt;reduce&lt;/code&gt; is a left-to-right reduction.     &lt;/p&gt;

&lt;p&gt;Also, instead of using the first element of the list, the reduction function can take an additional argument, usually called the accumulator. In functional languages, reduce is usually  called &lt;em&gt;fold&lt;/em&gt;, so we can have a left fold and a right fold. Let&amp;#39;s have a look how we could implement these. &lt;/p&gt;

&lt;h4&gt;Left fold&lt;/h4&gt;

&lt;p&gt;A straightforward way to implement a left fold (so the same as &lt;code&gt;reduce&lt;/code&gt;) is to use a &lt;code&gt;for&lt;/code&gt;-loop inside the function. That means we have to update the value of the accumulator on every iteration of the loop. In Raku, sigil-less variables are immutable (I am simplifying here, see &lt;a href=&quot;https://docs.raku.org/language/containers#Binding&quot;&gt;the Raku documentation&lt;/a&gt; for the full story) so we need to use a sigiled variable, &lt;code&gt;$acc&lt;/code&gt;. &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Raku&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foldll&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;&amp;amp;f&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;iacc&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;) { 
  &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;iacc&lt;/span&gt;; 
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; -&amp;gt; \&lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt; {
    &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;);
  }
  &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Python&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foldll&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iacc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iacc&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we want to use immutable variables only, we can use recursion. Raku makes this easy because it allows multiple signatures for a subroutine (&lt;code&gt;multi sub&lt;/code&gt;s), and it will call the variant that matches the signature. In Python, there is the module &lt;a href=&quot;https://pypi.org/project/multipledispatch/&quot;&gt;multipledispatch&lt;/a&gt; that lets you do something similar to multi subs.&lt;/p&gt;

&lt;p&gt;Our &lt;code&gt;foldl&lt;/code&gt; will consume the input list &lt;code&gt;lst&lt;/code&gt; and use &lt;code&gt;f&lt;/code&gt; combine its elements into the accumulator &lt;code&gt;acc&lt;/code&gt;. When the list has been consumed, the computation is finished and we can return &lt;code&gt;acc&lt;/code&gt; as the result. So our first variant says that if the input list is empty, we should return &lt;code&gt;acc&lt;/code&gt;.
The second variant takes an element &lt;code&gt;elt&lt;/code&gt; from the list (see &lt;a href=&quot;https://docs.raku.org/type/Range&quot;&gt;the Raku documentation&lt;/a&gt; for details on the &lt;code&gt;*&lt;/code&gt;) and combines it with &lt;code&gt;acc&lt;/code&gt; into &lt;code&gt;f(acc,elt)&lt;/code&gt;. It then calls &lt;code&gt;foldl&lt;/code&gt; again with this new accumulator and the remainder of the list, &lt;code&gt;rest&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# When the list is empty, return the accumulator&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foldl&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;&amp;amp;f&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;, ()) { &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; }
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foldl&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;&amp;amp;f&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;) {
  &lt;span class=&quot;c1&quot;&gt;# Raku&amp;#39;s way of splitting a list in the first elt and the rest&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# The &amp;#39;*&amp;#39; is a shorthand for the end of the list&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; (\&lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;,\&lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;) = &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;[&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; .. * ]; 
   &lt;span class=&quot;c1&quot;&gt;# The actual recursion&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;foldl&lt;/span&gt;( &lt;span class=&quot;nv&quot;&gt;&amp;amp;f&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;), &lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Python does not allow pattern matching of this kind so we need to write the recursion using a conditional:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foldl&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# Python&amp;#39;s way of splitting a tuple in the first elt and the rest&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# rest will be a list, not a tuple, but we&amp;#39;ll let that pass&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; 
   &lt;span class=&quot;c1&quot;&gt;# The actual recursion&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foldl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this implementation, none of the variables is ever updated. So all variables can be immutable. &lt;/p&gt;

&lt;h4&gt;Right fold&lt;/h4&gt;

&lt;p&gt;The right fold is quite similar to the left fold. For the loop-based version, all we do is &lt;code&gt;reverse&lt;/code&gt; the list.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Raku&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foldrl&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;&amp;amp;f&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;) { 
  &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$res&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;reverse&lt;/span&gt; -&amp;gt; \&lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt; {
    &lt;span class=&quot;nv&quot;&gt;$res&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$res&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;);
  }
  &lt;span class=&quot;nv&quot;&gt;$res&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Python&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foldlr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iacc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iacc&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the recursive version, we take the last element from the list instead of the first one. For details on the &lt;code&gt;..^ * - 1&lt;/code&gt; syntax please see &lt;a href=&quot;https://docs.raku.org/language/operators#infix_..%5E&quot;&gt;the Raku documentation&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Raku&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foldr&lt;/span&gt; ( &lt;span class=&quot;nv&quot;&gt;&amp;amp;f&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;, ()) { &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; }
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foldr&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;&amp;amp;f&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;) {
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; (\&lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;,\&lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;) = &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;[&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;..^*-&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;, *  ];
    &lt;span class=&quot;n&quot;&gt;foldr&lt;/span&gt;( &lt;span class=&quot;nv&quot;&gt;&amp;amp;f&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;), &lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Python&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foldr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; 
   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foldr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;code&gt;map&lt;/code&gt; and &lt;code&gt;grep&lt;/code&gt; are folds&lt;/h4&gt;

&lt;p&gt;Now, what about &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;grep&lt;/code&gt;? We can of course implement these with &lt;code&gt;for&lt;/code&gt;-loops, but we can also implement them using our &lt;code&gt;foldl&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Raku&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;&amp;amp;f&lt;/span&gt;,\&lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;) {
    &lt;span class=&quot;n&quot;&gt;foldl&lt;/span&gt;( &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (\&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;,\&lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;) {
            (|&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;))
            }, (), &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Python&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foldl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; 
      &lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;,()&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Because the function &lt;code&gt;f&lt;/code&gt; is mappable, it only has a single argument. But &lt;code&gt;foldl&lt;/code&gt; needs a function with two arguments, the first for the accumulator. So we call &lt;code&gt;foldl&lt;/code&gt; with an anonymous function of two arguments. The accumulator itself is an empty list. Although we said earlier that a reduction combines all elements of the original list into a single return value, this return value can of course be any data type, so also a list. So we call &lt;code&gt;f&lt;/code&gt; on every element of the original list and add it to the end of the accumulator list. (The &lt;code&gt;|&lt;/code&gt; flattens the list, so &lt;code&gt;(|acc,f(elt))&lt;/code&gt; is a new list built from the elements of &lt;code&gt;acc&lt;/code&gt; and result of &lt;code&gt;f(elt)&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;In a similar way we can also define &lt;code&gt;grep&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Raku&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;&amp;amp;f&lt;/span&gt;,\&lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;) {
    &lt;span class=&quot;n&quot;&gt;foldl&lt;/span&gt;( &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (\&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;,\&lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;) {
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;)) {
          (|&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;)
      } &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; {
          &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;
      }
    }, (), &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Python&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;filter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foldl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; 
      &lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Just like in the &lt;code&gt;map&lt;/code&gt; implementation, we call &lt;code&gt;foldl&lt;/code&gt; with an anonymous function. In this function we test if &lt;code&gt;f(elt)&lt;/code&gt; is true for every &lt;code&gt;elt&lt;/code&gt; in &lt;code&gt;lst&lt;/code&gt;. If it is true we create a new list from &lt;code&gt;acc&lt;/code&gt; and &lt;code&gt;elt&lt;/code&gt;, otherwise we just return &lt;code&gt;acc&lt;/code&gt;. Because &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;grep&lt;/code&gt; operate on each element of the list separately, we could implement them using the right fold as well. &lt;/p&gt;

&lt;p&gt;With these examples I hope that both the concept of a function working on functions and the possible ways of implementing them has become more clear. The advantage of the recursive implementation is that it allows us to use immutable data structures. &lt;/p&gt;

&lt;h3&gt;Why immutable data structures?&lt;/h3&gt;

&lt;p&gt;You may wonder why I focus on these immutable data structures. As we will have seen, functional programming works really well with immutable data structures. And they have one big advantage: you never have to worry if you have accidentally modified your data, or whether you should make a copy to be sure. So using immutable data structures make code less error-prone and easier to debug. They also have potential performance benefits. And as we&amp;#39;ll see next, in Raku there is yet another advantage.&lt;/p&gt;

&lt;h2&gt;Functions returning functions&lt;/h2&gt;

&lt;p&gt;Functions can also return functions. This is in particular useful if we want to have a parametrisable function. As a trivial example, suppose we want a series of functions that increments a number with a fixed value: &lt;code&gt;add1&lt;/code&gt;, &lt;code&gt;add2&lt;/code&gt; etc. We could of course write each of them separately:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Raku&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add_1&lt;/span&gt; (\&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;) {&lt;span class=&quot;o&quot;&gt;x+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;}
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add_2&lt;/span&gt; (\&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;) {&lt;span class=&quot;o&quot;&gt;x+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;}
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add_3&lt;/span&gt; (\&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;) {&lt;span class=&quot;o&quot;&gt;x+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;}
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add_4&lt;/span&gt; (\&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;) {&lt;span class=&quot;o&quot;&gt;x+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;}
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add_5&lt;/span&gt; (\&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;) {&lt;span class=&quot;o&quot;&gt;x+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;}

&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add_1&lt;/span&gt;(&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;); &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; says 5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Python&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add_1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add_2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add_3&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add_4&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add_5&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add_1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; says 5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or we could use a list filled with anonymous functions:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Raku&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; =
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (\&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;) {&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;},
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (\&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;) {&lt;span class=&quot;o&quot;&gt;x+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;},
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (\&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;) {&lt;span class=&quot;o&quot;&gt;x+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;},
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (\&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;) {&lt;span class=&quot;o&quot;&gt;x+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;},
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (\&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;) {&lt;span class=&quot;o&quot;&gt;x+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;},
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (\&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;) {&lt;span class=&quot;o&quot;&gt;x+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;};

&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;[&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;].(&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;); &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; says 5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Python&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; says 5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We could do better and use a loop to fill an array with anonymous functions:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Raku&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; = [];
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; .. &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; -&amp;gt; \&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; {
  &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (\&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;) {&lt;span class=&quot;o&quot;&gt;x+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;});
}

&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;[&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;].(&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;); &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; says 5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Python&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We create a new anonymous function with every loop iteration, and add it to the array. But instead, we could use a function to create these anonymous functions, and then we could use &lt;code&gt;map&lt;/code&gt; instead of a loop, and use an immutable data structure:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Raku&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gen_add&lt;/span&gt;(\&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;) {  
  &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (\&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;) {&lt;span class=&quot;o&quot;&gt;x+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;}
}

&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&amp;amp;gen_add&lt;/span&gt;, &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;;

&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;[&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;].(&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;); &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; says 5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Python&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;gen_add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;  
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;tuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gen_add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; says 5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Laziness&lt;/h3&gt;

&lt;p&gt;In Raku, using a range has an additional benefit: we can set the end of the range to infinity, which in Raku can be written as &lt;code&gt;∞&lt;/code&gt; (unicode 221E), &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;Inf&lt;/code&gt;. &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Raku&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&amp;amp;gen_add&lt;/span&gt;, &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; .. ∞;  

&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;[&lt;span class=&quot;mi&quot;&gt;244&lt;/span&gt;].(&lt;span class=&quot;mi&quot;&gt;7124&lt;/span&gt;); &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; says 7368&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is an example of what is called &amp;quot;lazy evaluation&amp;quot;, or laziness for short: Raku is not going to try (and fail) to process this infinite list. Instead, it will do the processing when we actually use an element of that list. The evaluation of the expression is delayed until the result is needed, so when we call &lt;code&gt;add[244]&lt;/code&gt;, what happens is that &lt;code&gt;gen_add(244)&lt;/code&gt; is called to generate that function. 
Note that this will not work with the for-loop, because to use the for-loop we need a mutable data structure, and the lazy lists have to be immutable. So this is a nice example of how the functional programming style allows you to benefit from laziness. For the full story of laziness in Raku, please see &lt;a href=&quot;https://docs.raku.org/language/list#index-entry-laziness_in_Iterable_objects&quot;&gt;the documentation&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;Python does not have lazy lists but is have a different form of laziness: the call to &lt;code&gt;map&lt;/code&gt; (or &lt;code&gt;filter&lt;/code&gt;) does not return the sequence of results but instead it returns a &lt;em&gt;generator&lt;/em&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Pythom&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;map_gen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gen_add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6666&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map_gen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; says &amp;lt;map object at 0x7f344caefdc0&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It is only when we wrap the generator in a sequence constructor such as &lt;code&gt;tuple()&lt;/code&gt; that the results are actually generated. &lt;/p&gt;

&lt;h2&gt;Function composition&lt;/h2&gt;

&lt;p&gt;We saw above that you can chain calls to &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;grep&lt;/code&gt; together. Often you only need to chain &lt;code&gt;map&lt;/code&gt; calls together, for example&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Raku&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; -&amp;gt; \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; { &lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; + &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; }, &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; -&amp;gt; \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; {&lt;span class=&quot;o&quot;&gt;x*x&lt;/span&gt;}, &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Python&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In that case, we can do this a little bit more efficient: rather than creating a list and then calling map on that list, we can do both computations at once by composing the functions. Raku provides a special operator for this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; -&amp;gt; \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; { &lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; + &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; } ∘ -&amp;gt; \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; { &lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; * &lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; }, &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The operator &lt;code&gt;∘&lt;/code&gt; (the &amp;quot;ring operator&amp;quot;, unicode 2218, but you can also use a plain &lt;code&gt;o&lt;/code&gt;) is the function composition operator, and it&amp;#39;s pronounced &amp;quot;after&amp;quot;, so &lt;code&gt;f ∘ g&lt;/code&gt; is &amp;quot;f after g&amp;quot;. What it does is create a new function by combining two existing functions:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&amp;amp;h&lt;/span&gt; = &lt;span class=&quot;nv&quot;&gt;&amp;amp;f&lt;/span&gt; ∘ &lt;span class=&quot;nv&quot;&gt;&amp;amp;g&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is the same as&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; (\&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;) {
    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;(&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The advantage of the composition operator is that that it works for any function, including anonymous ones. But in fact, it is just another higher-order functions. It is simply the operator form of the following function:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Raku&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compose&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;&amp;amp;f&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;g&lt;/span&gt;) {
    &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (\&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;) { &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;(&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt;)) }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Python does not have a function composition operator, but you can easily have &lt;code&gt;compose&lt;/code&gt; in Python too:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Python&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;compose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;In this article I have used Raku and Python examples to introduce three key functional programming techniques: functions that operate on functions, functions that return functions and function composition. I have shown how you to use the functions &lt;em&gt;map&lt;/em&gt;, &lt;em&gt;reduce&lt;/em&gt; (&lt;em&gt;fold&lt;/em&gt;) and &lt;em&gt;grep&lt;/em&gt; (&lt;em&gt;filter&lt;/em&gt;) to operate on immutable lists. I have explained how yo(u can implement such functions with and without recursion, and what the advantage is of the recursive implementation. Here is the code from the article, &lt;a href=&quot;https://github.com/wimvanderbauwhede/raku-examples/blob/master/decluttering-with-functional-programming.raku&quot;&gt;Raku&lt;/a&gt; and &lt;a href=&quot;https://github.com/wimvanderbauwhede/raku-examples/blob/master/decluttering-with-functional-programming.py&quot;&gt;Python&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;There is of course a lot more to functional programming and I have written &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/&quot;&gt;a few articles on more advanced topics&lt;/a&gt;. The concepts introduced in this article should provide a good basis for understanding those more advanced topics. If you want to learn more about functional programming, you might consider &lt;a href=&quot;https://www.futurelearn.com/courses/functional-programming-haskell&quot;&gt;my free online course&lt;/a&gt;.&lt;/p&gt;

&lt;!-- (reduce -&gt;\x,\y {x o y}, -&gt; \x {x+1},-&gt; \x {x*2}, -&gt; \x {2*x-1})(33) --&gt;

&lt;!-- ([∘] fs)(x) --&gt;

&lt;!-- List comprehensions
[ expression for item in list if conditional ] --&gt;

&lt;!-- From my perspective:
∘ Partial application 
∘ Pureness of I/O --&gt;

        </content>
    </entry>
    
    <entry>
        <title>Everything is a function</title>
        <link href="https://wimvanderbauwhede.github.io/articles/everything-is-a-function/"/>
        <updated>2020-07-03T00:00:00+01:00</updated>
        <id>https://wimvanderbauwhede.github.io/articles/everything-is-a-function</id>
        <author>
					<name>Wim Vanderbauwhede</name>
					<uri>https://wimvanderbauwhede.github.io/</uri>
					
				</author>
        <content type="html">
        	&lt;img src=&quot;https://wimvanderbauwhede.github.io/images/everything-is-a-function_1600x600.jpg&quot;&gt;&lt;br/&gt;
        	&lt;p&gt;This is an article I wrote several years ago. It is part of the &lt;a href=&quot;https://www.futurelearn.com/courses/functional-programming-haskell&quot;&gt;&amp;quot;Functional Programming in Haskell&amp;quot; online course&lt;/a&gt;. It discusses one of the aspects of functional programming that I like in particular, the fact that the entire language can be build starting from the &lt;a href=&quot;https://www.futurelearn.com/courses/functional-programming-haskell/0/steps/27249&quot;&gt;lambda calculus&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;In a functional language, there are only functions&lt;/h2&gt;

&lt;p&gt;Although it might seem that a language like Haskell has a lot of different objects and constructs, they can all be reduced to functions. We will demonstrate how variables, tuples, lists, conditionals, Booleans and numbers can all be constructed from lambda functions. The article assumes some familiarity with Haskell, but here is a quick introduction.&lt;/p&gt;

&lt;h3&gt;Haskell: a quick introduction&lt;/h3&gt;

&lt;p&gt;Haskell is whitespace-sensitive like Python, but has a markedly different syntax. Because everything is a function, there is no keyword to mark a function; because there is only lexical scope, there is no need for any special scope identifiers. Function arguments are separated by spaces; anonymous functions are called &lt;em&gt;lambda functions&lt;/em&gt; and have a special syntax to identify them: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;-- named function&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;square&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- lambda function bound to a named variable&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;anon_square&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Several of the examples use the  &lt;code&gt;let ... in ...&lt;/code&gt;  construct, which behaves as a lexically scoped block:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;let_square&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x1&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x0&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;x0&lt;/code&gt;, &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are in scope only in the expression after the &lt;code&gt;in&lt;/code&gt; keyword.&lt;/p&gt;

&lt;p&gt;Haskell is statically typed, and the type of a function or variable is written in a separate annotation, for example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;isEmpty&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;isEmpty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;isEmpty&lt;/code&gt; function has a type signature, identified by &lt;code&gt;::&lt;/code&gt;, that reads &amp;quot;&lt;code&gt;isEmpty&lt;/code&gt; is a function from a list of anything to a Boolean&amp;quot;. Types must be written with an initial capital. The &lt;code&gt;a&lt;/code&gt; is a &lt;em&gt;type variable&lt;/em&gt; which can take on any type, as explained in &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/everything-is-a-function/&quot;&gt;my post on algebraic data types&lt;/a&gt;. Most of the time, you don&amp;#39;t need to write type declarations as Haskell works them out automatically. In the rest of the article, I&amp;#39;m not focusing on the types so I have omitted them.&lt;/p&gt;

&lt;h3&gt;Variables and &lt;code&gt;let&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Haskell uses &lt;code&gt;let&lt;/code&gt; expressions to define variables used in a final expression, for example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can rewrite this to use only one variable per &lt;code&gt;let&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt;
      &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt;  
        &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
      &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we rewrite any named functions (&lt;code&gt;f&lt;/code&gt;) as lambda functions:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt;
      &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt;  
        &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
      &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then we rewrite the &lt;code&gt;let&lt;/code&gt; expressions themselves as lambdas, first the inner &lt;code&gt;let&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We do this by turning the variable in the &lt;code&gt;let&lt;/code&gt; part of the expression (&lt;code&gt;f&lt;/code&gt;) into a parameter of a lambda function (&lt;code&gt;\f -&amp;gt; ...&lt;/code&gt;). The body of the function is the expression after the &lt;code&gt;in&lt;/code&gt; (&lt;code&gt;f n&lt;/code&gt;). Then we apply this lambda function to the expression bound to the variable (&lt;code&gt;\x -&amp;gt; x+1&lt;/code&gt;).   &lt;/p&gt;

&lt;p&gt;Then we rewrite outer &lt;code&gt;let&lt;/code&gt; in the same way:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This expression consists only of lambda expressions, which shows that variables and &lt;code&gt;let&lt;/code&gt;-expressions are just syntactic sugar for lambda expressions.    &lt;/p&gt;

&lt;h3&gt;Tuples&lt;/h3&gt;

&lt;p&gt;Haskell has &lt;em&gt;tuples&lt;/em&gt;, also called record types or product types, ordered collections of expressions of potentially different types:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;tp&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;2&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The tuple notation is syntactic sugar for a function application:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;tp&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mkTup&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;2&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The tuple construction function can again be defined purely using lambdas:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;          &lt;span class=&quot;n&quot;&gt;mkTup&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What we do here is to use the elements of the tuple as the arguments of a lambda function. So what &lt;code&gt;mkTup&lt;/code&gt; returns is also a lambda function, in other words &lt;code&gt;mkTup&lt;/code&gt; is a higher-order function. Now we rewrite the &lt;code&gt;mkTup&lt;/code&gt; named function as lambda function as well:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;          &lt;span class=&quot;n&quot;&gt;mkTup&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So our tuples are now also encoded purely as lambda functions.&lt;/p&gt;

&lt;p&gt;The same goes for the tuple accessor functions:          &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;fst&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tp&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tp&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;snd&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tp&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tp&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let&amp;#39;s see what happens here: the argument &lt;code&gt;tp&lt;/code&gt; of &lt;code&gt;fst&lt;/code&gt; is a function: &lt;code&gt;\t -&amp;gt; t x&amp;#39; y&amp;#39; z&amp;#39;&lt;/code&gt;. We now apply this function to another function, &lt;code&gt;\x y z -&amp;gt; x&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&amp;#39;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&amp;#39;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Applying the function gives:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&amp;#39;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&amp;#39;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And so the result will of course be &lt;code&gt;x&amp;#39;&lt;/code&gt;, which is indeed the first element of the tuple. &lt;/p&gt;

&lt;h3&gt;Lists&lt;/h3&gt;

&lt;p&gt;Lists can be defined in terms of the empty lists &lt;code&gt;[]&lt;/code&gt; and the &lt;code&gt;cons&lt;/code&gt; operation &lt;code&gt;(:)&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Rewriting this using &lt;code&gt;:&lt;/code&gt; and &lt;code&gt;[]&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;[]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or using &lt;code&gt;cons&lt;/code&gt; explicitly:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cons&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cons&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Defining &lt;code&gt;cons&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;We can define &lt;code&gt;cons&lt;/code&gt; using only lambda functions as&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;cons&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xs&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xs&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We&amp;#39;ve used the same approach as for the tuples: &lt;code&gt;cons&lt;/code&gt; returns a lambda function. So we can write a list as:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
       &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can also define &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt; using only lambdas, similar to what we did for &lt;code&gt;fst&lt;/code&gt; and &lt;code&gt;snd&lt;/code&gt; above:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;The empty list&lt;/h4&gt;

&lt;p&gt;We can define the empty list as follows:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is a lambda function which always returns &lt;code&gt;true&lt;/code&gt;, regardless of its argument. The definitions for &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; are given below under Booleans.  With this definition we can check if a list is empty or not:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;isEmpty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xs&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let&amp;#39;s see how this works. A non-empty list is always defined as:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xs&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which with our definition of &lt;code&gt;(:)&lt;/code&gt; (i.e. &lt;code&gt;cons&lt;/code&gt;) is:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xs&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xs&lt;/span&gt;
    &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xs&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And therefore:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;isEmpty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;
    &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isEmpty&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xs&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;false&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;isEmpty&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isEmpty&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xs&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And so we have a pure-lambda definition of lists, including construction, access and testing for empty. &lt;/p&gt;

&lt;h4&gt;Recursion on lists&lt;/h4&gt;

&lt;p&gt;Now that we can test for the empty list we can define recursions on lists such as &lt;code&gt;foldl&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt; etc.:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;foldl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;
      &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isEmpty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foldl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;  &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;
      &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;map&amp;#39;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&amp;#39;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; 
          &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isEmpty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; 
            &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reverse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
            &lt;span class=&quot;kr&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&amp;#39;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;map&amp;#39;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;[]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;with&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;reverse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foldl&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The definitions of &lt;code&gt;foldl&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt; use an if-then-else expression which is defined below under Conditionals.&lt;/p&gt;

&lt;h4&gt; List concatenation&lt;/h4&gt;

&lt;p&gt;With &lt;code&gt;foldl&lt;/code&gt; and &lt;code&gt;reverse&lt;/code&gt; it is easy to express list concatenation:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst2&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;foldl&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reverse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt; The length of a list&lt;/h4&gt;

&lt;p&gt;To compute the length of a list we need integers, they are defined below. We increment the lent counter for every element of the list consumed by the fold.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foldl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calc_length&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;
      &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;calc_length&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Conditionals&lt;/h3&gt;

&lt;p&gt;We have used conditionals in the above expressions:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cond&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;if_true_exp&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;if_false_exp&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here &lt;code&gt;cond&lt;/code&gt; is an expression returning either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, these are defined below.&lt;/p&gt;

&lt;p&gt;We can write the if-then-else clause as a pure function:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;ifthenelse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cond&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;if_true_exp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;if_false_exp&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Booleans&lt;/h3&gt;

&lt;p&gt;To evaluate the condition we need to define Booleans as lambda functions:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The Boolean is a function selecting the expression corresponding to true or false. With this definition, the if-then-else becomes simply:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;ifthenelse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cond&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;if_true_exp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;if_false_exp&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;cond&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;if_true_exp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;if_false_exp&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Basic Boolean operations: &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;not&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;Using &lt;code&gt;ifthenelse&lt;/code&gt; we can define &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;not&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ifthenelse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ifthenelse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;false&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ifthenelse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ifthenelse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ifthenelse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Boolean equality: &lt;code&gt;xnor&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;We note that to test equality of Booleans we can use &lt;code&gt;xnor&lt;/code&gt;, and we can of course define &lt;code&gt;xor&lt;/code&gt; in terms of &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;not&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;xor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;xnor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Signed Integers&lt;/h3&gt;

&lt;p&gt;The common way to define integers in the lambda calculus is as &lt;a href=&quot;https://en.wikipedia.org/wiki/Church_encoding&quot;&gt;Church numerals&lt;/a&gt;. Here we take a different approach, but it is of course equivalent. We define an integer as a list of Booleans, using &lt;a href=&quot;https://en.wikipedia.org/wiki/Unary_coding&quot;&gt;thermometer code&lt;/a&gt;, and with the following definitions:&lt;/p&gt;

&lt;p&gt;We define unsigned &lt;code&gt;0&lt;/code&gt; as a 1-element list containing &lt;code&gt;false&lt;/code&gt;. To get signed integers we simply define the first bit of the list as the sign bit. We define unsigned and signed versions of &lt;code&gt;0&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;u0&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:[]&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u0&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For convenience we define also:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;isPos&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;isNeg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;isZero&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sign&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Integer equality&lt;/h4&gt;

&lt;p&gt;The definition of &lt;code&gt;0&lt;/code&gt; makes the integer equality &lt;code&gt;(==)&lt;/code&gt; easier:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;b1&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;b2&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xnor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
          &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;true&lt;/span&gt;
          &lt;span class=&quot;kr&quot;&gt;else&lt;/span&gt;
            &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
              &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
              &lt;span class=&quot;kr&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;false&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;false&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Negation&lt;/h4&gt;

&lt;p&gt;We can also easily define negation:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;neg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Increment and Decrement&lt;/h4&gt;

&lt;p&gt;For convenience we define also define increment and decrement operations:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;inc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isPos&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; 
      &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
      &lt;span class=&quot;kr&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isZero&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; 
        &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; 
        &lt;span class=&quot;kr&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dec&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isZero&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; 
      &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; 
      &lt;span class=&quot;kr&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isNeg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; 
        &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; 
        &lt;span class=&quot;kr&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Addition and Subtraction&lt;/h4&gt;

&lt;p&gt;General addition is quite easy:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foldl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add_if_true&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt;
      &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;add_if_true&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the same way, subtraction is also straightforward:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foldl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sub_if_true&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt;
      &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sub_if_true&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Multiplication&lt;/h4&gt;

&lt;p&gt;An easy way to define multiplication is by defining the &lt;code&gt;replicate&lt;/code&gt; and &lt;code&gt;sum&lt;/code&gt; operations:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;replicate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;
      &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;repl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; 
          &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; 
          &lt;span class=&quot;kr&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;repl&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dec&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;repl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;[]&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foldl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then multiplication simply becomes&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;mult&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;replicate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In a similar way we can define integer division and modulo.&lt;/p&gt;

&lt;h3&gt;Floats, Characters and Strings&lt;/h3&gt;

&lt;p&gt;We note that floating-point numbers and characters use an integer representation, and strings are simply lists of characters. So we don&amp;#39;t need to do any additional work to represent them, and the operations on them are analogous to the ones defined above. &lt;/p&gt;

&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;In this way, we have defined a language with variables, (higher-order) functions, conditionals and recursion. We can manipulate lists and tuples of integers, floats, chars and strings. And yet it consists of nothing more than lambda functions!&lt;/p&gt;

        </content>
    </entry>
    
    <entry>
        <title>List-based parser combinators in Haskell and Raku</title>
        <link href="https://wimvanderbauwhede.github.io/articles/list-based-parser-combinators/"/>
        <updated>2020-06-22T00:00:00+01:00</updated>
        <id>https://wimvanderbauwhede.github.io/articles/list-based-parser-combinators</id>
        <author>
					<name>Wim Vanderbauwhede</name>
					<uri>https://wimvanderbauwhede.github.io/</uri>
					
				</author>
        <content type="html">
        	&lt;img src=&quot;https://wimvanderbauwhede.github.io/images/list-based-parser-combinators_1600x600.jpg&quot;&gt;&lt;br/&gt;
        	&lt;p&gt;This is a follow-on from my article &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/roles-as-adts-in-raku/&quot;&gt;introducing algebraic data types and explaining how to implement them in Raku&lt;/a&gt;. 
If you are not familiar with algebraic data types, I suggest you read that article first. In this article I use algebraic data types to create a statically typed version of a list-based parser combinators library which I originally created for dynamic languages. The article introduces list-based parser combinators are and how to implement them in Raku and Haskell using algebraic data types.&lt;/p&gt;

&lt;h2&gt;Perl, Haskell and Raku: a quick introduction&lt;/h2&gt;

&lt;p&gt;The code examples in this article are written in &lt;a href=&quot;https://www.perl.org/&quot;&gt;Perl&lt;/a&gt;, &lt;a href=&quot;https://www.haskell.org/&quot;&gt;Haskell&lt;/a&gt; and &lt;a href=&quot;https://raku.org/&quot;&gt;Raku&lt;/a&gt;. If you are familiar with these languages, you can skip this section. The code is written in a functional style and is not very idiomatic so you should be able to understand it easily if you know another programming language.&lt;/p&gt;

&lt;p&gt;Perl and Raku are syntactically similar to C/C++, Java and JavaScript: block-based, with statements separated by semicolons, blocks demarcated by braces, and argument lists in parentheses and separated by commas. The main feature that sets Perl and Raku apart is the use of sigils (&amp;#39;funny characters&amp;#39;) which identify the type of a variable: &lt;code&gt;$&lt;/code&gt; for a scalar, &lt;code&gt;@&lt;/code&gt; for an array, &lt;code&gt;%&lt;/code&gt; for a hash (map) and &lt;code&gt;&amp;amp;&lt;/code&gt; for a subroutine. Variables also have keywords to identify their scope, I will only use &lt;code&gt;my&lt;/code&gt; which marks the variable as lexically scoped. A subroutine is declared with the &lt;code&gt;sub&lt;/code&gt; keyword, and subroutines can be named or anonymous:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;square&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt;) {
    &lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt;*&lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt;;
}
&lt;span class=&quot;c1&quot;&gt;# anonymous subroutine &lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$anon_square&lt;/span&gt; = &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt;) {
    &lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt;*&lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Haskell is whitespace-sensitive like Python, but has a markedly different syntax. Because everything is a function, there is no keyword to mark a function; because there is only lexical scope, there is no need for any special scope identifiers. Function arguments are separated by spaces; anonymous functions have a special syntax to identify them: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;-- named function&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;square&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- lambda function bound to a named variable&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;anon_square&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Several of the examples use the  &lt;code&gt;let ... in ...&lt;/code&gt;  construct, which behaves as a lexically scoped block:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;let_square&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x1&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x0&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;x0&lt;/code&gt;, &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are in scope only in the expression after the &lt;code&gt;in&lt;/code&gt; keyword.&lt;/p&gt;

&lt;p&gt;Haskell is statically typed, and the type of a function or variable is written in a separate annotation, for example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;isEmpty&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;isEmpty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;isEmpty&lt;/code&gt; function has a type signature, identified by &lt;code&gt;::&lt;/code&gt;, that reads &amp;quot;&lt;code&gt;isEmpty&lt;/code&gt; is a function from a list of anything to a Boolean&amp;quot;. Types must be written with an initial capital. The &lt;code&gt;a&lt;/code&gt; is a &lt;em&gt;type variable&lt;/em&gt; which can take on any type, as explained in &lt;a href=&quot;https://wimvanderbauwhede.github.io/articles/roles-as-adts-in-raku/&quot;&gt;my previous post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Raku has optional typing: you can add type information as part of the declarations, for example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isOfSz&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;@lst&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$sz&lt;/span&gt; --&amp;gt; &lt;span class=&quot;nb&quot;&gt;Bool&lt;/span&gt;) {
    &lt;span class=&quot;nv&quot;&gt;@lst&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;elems&lt;/span&gt; == &lt;span class=&quot;nv&quot;&gt;$sz&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This function takes array of any type and an integer and returns a Boolean. &lt;/p&gt;

&lt;p&gt;Other specific bits of syntax or functionality will be explained for the particular examples. &lt;/p&gt;

&lt;h2&gt;Parsers and parser combinators&lt;/h2&gt;

&lt;p&gt;What I call a parser here is technically a combination of a lexer or tokeniser and a parser. The lexical analysis (splitting a sequence of characters into a sequence of tokens, strings with an identified meaning) meaning and parsing (syntactic analysis, analysing the sequence of tokens in terms of a formal grammar) are not separate stages.&lt;/p&gt;

&lt;p&gt;Parser combinators are building blocks to create parsers by combining small parsers into very complex ones. In Haskell they became popular because of the &lt;a href=&quot;http://book.realworldhaskell.org/read/using-parsec.html&quot;&gt;Parsec&lt;/a&gt; library. This library provides &lt;a href=&quot;http://jakewheat.github.io/intro_to_parsing/&quot;&gt;monadic parser combinators&lt;/a&gt;. My parser combinator library implements a subset of Parsec&amp;#39;s functionality. I am not going to explain what monads are because the point of creating list-based parser combinators is precisely that they do not require monads. There is a connection however, and you can read about it in &lt;a href=&quot;https://dl.acm.org/doi/pdf/10.1145/2617548.2617551&quot;&gt;my paper&lt;/a&gt; if you&amp;#39;re interested. &lt;/p&gt;

&lt;p&gt;I created the original version of the list-based parser combinators library for dynamically typed languages: there are versions in &lt;a href=&quot;https://metacpan.org/pod/Parser::Combinators&quot;&gt;Perl&lt;/a&gt;, &lt;a href=&quot;https://gitlab.com/wim_v12e/parser-combinators-py&quot;&gt;Python&lt;/a&gt; and &lt;a href=&quot;https://github.com/wimvanderbauwhede/parser-combinators-ls&quot;&gt;LiveScript&lt;/a&gt;, &lt;a href=&quot;http://livescript.net/&quot;&gt;a Haskell-like language which compiles to JavaScript&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;Because I like Raku and it has gradual typing, I was interested in what &lt;a href=&quot;https://github.com/wimvanderbauwhede/raku-examples/blob/master/ListBasedCombinators.pm6&quot;&gt;a statically typed Raku version&lt;/a&gt; would look like. As a little detour I first implemented them in Haskell, just for fun really. &lt;/p&gt;

&lt;p&gt;Raku has &lt;a href=&quot;https://docs.raku.org/language/grammars&quot;&gt;Grammars&lt;/a&gt;, which also let you build powerful parsers. If you are familiar with them it will be interesting to compare the parser combinator approach to the inheritance mechanism used to compose Grammars.&lt;/p&gt;

&lt;h2&gt;List-based parser combinators&lt;/h2&gt;

&lt;p&gt;So what are list-based parser combinators? Let&amp;#39;s say I want to parse a string containing this very simple bit of code:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;assignStr&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;   answer = 42&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We have an identifier, an assignment operator and a natural number, maybe preceded by whitespace, and with some whitespace that doesn&amp;#39;t matter between these tokens. I am assuming that the string which we want to parse is code written in a language which is whitespace-insensitive. 
What I would like is that I can write a parser for as close as possible to the following:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;assignParser&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;maybe&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;whiteSpace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;identifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;symbol&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;=&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;natural&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And when I apply &lt;code&gt;assignParser&lt;/code&gt; to &lt;code&gt;assignStr&lt;/code&gt;, it should return the parsed tokens, a status, and the remainder of the string, if any. So each parser takes a string and returns this triplet of values (I&amp;#39;ll call it a tuple instead of a triplet). We&amp;#39;ll define this more formally in the next sections.&lt;/p&gt;

&lt;p&gt;What we have here is that the list acts as the sequencing combinator for the specific parsers. The &lt;code&gt;maybe&lt;/code&gt; is a combinator to make the token optional. We can provide more combinators, such as &lt;code&gt;choice&lt;/code&gt;, (to try several parsers), &lt;code&gt;many&lt;/code&gt; (to repeatedly apply a parser), etc. And because every parser is a function, complex parsers can easily be composed of smaller parsers expressed in terms of the building blocks. For example, if we had many assignments, we could have something like&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;assignsParser&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;many&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;assignParser&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now suppose that we want to extend our parser to include declarations, something like&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;    int answer&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which we parse as&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;declParser&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maybe&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;whiteSpace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;identifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;identifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;then we need to add get the following parser:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;statementsParser&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;many&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;choice&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;assignParser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;declParser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It is also essential that we can label tokens or groups of tokens, so that we can easily extract the relevant information from a parse tree, as the intermediate step in transforming the parse tree into an abstract syntax tree. In the above example, we are only interested in the variable name and the value. The whitespace and equal sign are not important. So we could label the relevant tokens, for example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl&quot; data-lang=&quot;perl&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;assignParser&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;whiteSpace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;var&amp;quot;&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;identifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;symbol&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;=&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;val&amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;natural&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Implementation in a dynamically typed language&lt;/h2&gt;

&lt;p&gt;How do we implement the above mechanism in a dynamically typed language? A parser like &lt;code&gt;identifier&lt;/code&gt; is simply a function which takes a string and returns a tuple. In Perl, the code looks like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl&quot; data-lang=&quot;perl&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;identifier&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;( $str ) {&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=~&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt; /^([a-z_]\w*)/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$matches&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=~&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;s/^$matches\s*//&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$matches&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;undef&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(In Perl, &lt;code&gt;=~ /.../&lt;/code&gt; is the regular expression matching syntax, and &lt;code&gt;s/.../.../&lt;/code&gt; is regular expression substitution.)&lt;/p&gt;

&lt;p&gt;But what about a parser like &lt;code&gt;symbol&lt;/code&gt;? It takes the string representing the symbol as an argument, so in the example, &lt;code&gt;symbol( &amp;quot;=&amp;quot; )&lt;/code&gt; should be the actual parser. What we need is that a call to &lt;code&gt;symbol&lt;/code&gt; will return a function to do the parsing, like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl&quot; data-lang=&quot;perl&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;symbol&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;( $lit_str ) {&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$gen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;( $str ) {&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=~&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt; /^\s*$lit_str\s*/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$matches&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$lit_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=~&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;s/^\s*$lit_str\s*//&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$matches&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;undef&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$gen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is of course not limited to string arguments, any argument of the outer function can be used inside the inner function. In particular, if a parser combinator takes parsers as arguments, like &lt;code&gt;choice&lt;/code&gt; and &lt;code&gt;maybe&lt;/code&gt;, then these parsers can be passed on to the inner function. &lt;/p&gt;

&lt;p&gt;This is fine as far as it goes, but what about the labelled parsers? and what about the lists of parsers? Neither of these can be directly applied to a string, but neither is a function that can generate a function either. So to apply them to a string, we will need to get the parsers out of label-parser pair and the list. We do that using a helper function which I call &lt;code&gt;apply&lt;/code&gt;, and which in Perl looks like&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl&quot; data-lang=&quot;perl&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;( $p, $str ) {&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;eq&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;CODE&amp;#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;eq&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;ARRAY&amp;#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;eq&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;HASH&amp;#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;retag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(The syntax &lt;code&gt;$p-&amp;gt;($str)&lt;/code&gt; applies the anonymous function referenced by &lt;code&gt;$p&lt;/code&gt; to its arguments.)&lt;/p&gt;

&lt;p&gt;This function checks the type of &lt;code&gt;$p&lt;/code&gt; using the &lt;code&gt;ref&lt;/code&gt; built-in: it can either be code (i.e. a subroutine), an array or a hash. If it&amp;#39;s subroutine it&amp;#39;s applied directly to the string, otherwise it calls &lt;code&gt;sequence&lt;/code&gt; or &lt;code&gt;retag&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl&quot; data-lang=&quot;perl&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sequence&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;( $plst ) {&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$gen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;( $str ) {&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$st1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$matches&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$st2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$ms&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$str1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$st2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$st1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$matches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$ms&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$matches&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
            &lt;span class=&quot;n&quot;&gt;foldl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$plst&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
            &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$matches&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$gen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;foldl&lt;/code&gt; function is my Perl version of the left-to-right reduction in Haskell or &lt;code&gt;reduce&lt;/code&gt; in Raku.&lt;/p&gt;

&lt;p&gt;What &lt;code&gt;retag&lt;/code&gt; does is taking the parser from the label pair (which is a single-element hash), apply it to the string, and label the resulting matches with the label of the parser:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl&quot; data-lang=&quot;perl&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;retag&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;($p, $str) {&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%hp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$pp&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%hp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$mms&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$pp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$matches&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$mms&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$matches&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(The syntax &lt;code&gt;%{$p}&lt;/code&gt; is dereferencing, a bit like the &lt;code&gt;*&lt;/code&gt; prefix in C.)&lt;/p&gt;

&lt;p&gt;Here is a simple example of how to use the list-based parser combinators. &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl&quot; data-lang=&quot;perl&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;    Hello, brave new world!&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str_parser&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;whiteSpace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;comma&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Adjectives&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Adword&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Noun&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;symbol&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;!&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str_parser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Implementation in a language with algebraic data types&lt;/h2&gt;

&lt;p&gt;All of the above is fine in a dynamically typed language, but in a statically typed language, the list can&amp;#39;t contain a function and a hash and another list, as they all have different types. Also, only testing if an entry of the list is code, hash or list is rather weak, as it does not guarantee that the code is an actual parser. So let&amp;#39;s see what it looks like in Haskell and Raku.
list-based parser combinators 
In Haskell, we start (of course) by defining a few types:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;-- The list-based combinator&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;LComb&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; 
      &lt;span class=&quot;kt&quot;&gt;Seq&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;LComb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; 
    &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Comb&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MTup&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Tag&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;LComb&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- The match, i.e. the bit of the string the parser matches&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Match&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; 
      &lt;span class=&quot;kt&quot;&gt;Match&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; 
    &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TaggedMatches&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Match&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; 
    &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UndefinedMatch&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Eq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- The tuple returned by the parser  &lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MTup&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MTup&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Matches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- some aliases&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Matches&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Match&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Status&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Integer&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(In Haskell, &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;newtype&lt;/code&gt; define a new algebraic datatype; &lt;code&gt;type&lt;/code&gt; defines an alias for an existing type.)&lt;/p&gt;

&lt;p&gt;So our list of parsers will be a list of &lt;code&gt;LComb&lt;/code&gt;, and this can be a parser, sequence of parsers or tagged pair. Because the tag eventually is used to label the matched string, the &lt;code&gt;Match&lt;/code&gt; type also has a tagged variant. In principle, the return type of the parser could just be a tuple, but I define the &lt;code&gt;MTup&lt;/code&gt; polymorphic type so I can make it an instance of a type class later on, e.g. to make it a monad.&lt;/p&gt;

&lt;p&gt;With these types we can define our parser combinators and the &lt;code&gt;apply&lt;/code&gt; and &lt;code&gt;sequence&lt;/code&gt; functions. Here is the &lt;code&gt;symbol&lt;/code&gt; parser. Many of the parsers in the library are implemented using &lt;a href=&quot;http://pcre.org/&quot;&gt;Perl-Compatible Regular Expressions&lt;/a&gt; (&lt;a href=&quot;https://hackage.haskell.org/package/regex-pcre&quot;&gt;&lt;code&gt;Text.Regex.PCRE&lt;/code&gt;&lt;/a&gt;), because what else can you expect of a &lt;a href=&quot;https://andrewshitov.com/2015/05/05/interview-with-audrey-tang/&quot;&gt;lamdacamel&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;symbol&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;LComb&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;symbol&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lit_str&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; 
    &lt;span class=&quot;kt&quot;&gt;Comb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt;  &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; 
            &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=~&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;^&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s*&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lit_str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s*&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;
            &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt;
                &lt;span class=&quot;kt&quot;&gt;MTup&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Match&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lit_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
            &lt;span class=&quot;kr&quot;&gt;else&lt;/span&gt;
                &lt;span class=&quot;kt&quot;&gt;MTup&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;UndefinedMatch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(The &lt;code&gt;$&lt;/code&gt; behaves like an opening parenthesis that does not need a closing parenthesis; &lt;code&gt;++&lt;/code&gt; is the list concatenation operator, in Haskell strings are lists of characters.)&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;apply&lt;/code&gt; function pattern matches against the type alternatives for &lt;code&gt;LComb&lt;/code&gt;. Because of the pattern matching there is not need for an &lt;code&gt;untag&lt;/code&gt; function. It is clear from this implementation that we can write a sequence of parsers both as &lt;code&gt;Seq [...]&lt;/code&gt; or &lt;code&gt;sequence [...]&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;LComb&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MTup&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;of&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;Comb&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&amp;#39;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&amp;#39;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;Seq&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&amp;#39;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;Comb&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&amp;#39;&amp;#39;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&amp;#39;&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;p&amp;#39;&amp;#39;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;Tag&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pp&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt;
                &lt;span class=&quot;kt&quot;&gt;MTup&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;matches&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;TaggedMatches&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; 
            &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt;
                &lt;span class=&quot;kt&quot;&gt;MTup&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Apart from the static typing, the &lt;code&gt;sequence&lt;/code&gt; function is very close to the Perl version. That is of course because I wrote the Perl code in a functional style. &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sequence&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;LComb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;LComb&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sequence&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pseq&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; 
    &lt;span class=&quot;kt&quot;&gt;Comb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt;
                    &lt;span class=&quot;kt&quot;&gt;MTup&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;
                    &lt;span class=&quot;kt&quot;&gt;MTup&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str1&lt;/span&gt;
                    &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt;
                        &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
                            &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt;
                                &lt;span class=&quot;kt&quot;&gt;MTup&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emptyMatches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                            &lt;span class=&quot;kr&quot;&gt;else&lt;/span&gt;
                                &lt;span class=&quot;kt&quot;&gt;MTup&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
                &lt;span class=&quot;kt&quot;&gt;MTup&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;matches&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; 
                    &lt;span class=&quot;n&quot;&gt;foldl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;MTup&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emptyMatches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pseq&lt;/span&gt;
            &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt;
                &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt;
                    &lt;span class=&quot;kt&quot;&gt;MTup&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emptyMatches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;kr&quot;&gt;else&lt;/span&gt;
                    &lt;span class=&quot;kt&quot;&gt;MTup&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matches&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In Raku, I use roles as algebraic datatypes as explained in &lt;a href=&quot;&quot;&gt;my previous post&lt;/a&gt;. Essentially, each alternative of a sum types mixes in an empty role which is only used to name the type; product types are just roles with some attributes that are declared in the role&amp;#39;s parameter list.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# The list-based combinator type&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LComb&lt;/span&gt; {}
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Seq&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;LComb&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@combs&lt;/span&gt;] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LComb&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LComb&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@.combs&lt;/span&gt; = &lt;span class=&quot;nv&quot;&gt;@combs&lt;/span&gt;;
}
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Comb&lt;/span&gt;[&lt;span class=&quot;nb&quot;&gt;Sub&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$comb&lt;/span&gt;] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LComb&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Sub&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.comb&lt;/span&gt; = &lt;span class=&quot;nv&quot;&gt;$comb&lt;/span&gt;;
}
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tag&lt;/span&gt;[&lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$tag&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;LComb&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$comb&lt;/span&gt;] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LComb&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.tag&lt;/span&gt; = &lt;span class=&quot;nv&quot;&gt;$tag&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LComb&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.comb&lt;/span&gt; = &lt;span class=&quot;nv&quot;&gt;$comb&lt;/span&gt;; 
} 

&lt;span class=&quot;c1&quot;&gt;# The matches&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Matches&lt;/span&gt; {}
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Match&lt;/span&gt;[&lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Matches&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.match&lt;/span&gt;=&lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;;
} 
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TaggedMatch&lt;/span&gt;[&lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$tag&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;Matches&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@ms&lt;/span&gt;] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Matches&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.tag&lt;/span&gt; = &lt;span class=&quot;nv&quot;&gt;$tag&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Matches&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@.matches&lt;/span&gt; = &lt;span class=&quot;nv&quot;&gt;@ms&lt;/span&gt;;
} 
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UndefinedMatch&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Matches&lt;/span&gt; {}

&lt;span class=&quot;c1&quot;&gt;# The tuple returned by the parser&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MTup&lt;/span&gt;[&lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$st&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$rest&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;Matches&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@ms&lt;/span&gt;] {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.status&lt;/span&gt; = &lt;span class=&quot;nv&quot;&gt;$st&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.rest&lt;/span&gt; = &lt;span class=&quot;nv&quot;&gt;$rest&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Matches&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@.matches&lt;/span&gt; = &lt;span class=&quot;nv&quot;&gt;@ms&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The way the Raku regular expressions are used in this implementation of &lt;code&gt;symbol&lt;/code&gt; is closer to the Haskell version than the Perl 5 version. But the main difference with the Perl 5 version is that the combinator and the return tuple are statically typed. The function &lt;code&gt;undef-match&lt;/code&gt; is a convenience to return an array with an undefined match. &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;symbol&lt;/span&gt; (&lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$lit_str&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;LComb&lt;/span&gt;) {
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$lit_str_&lt;/span&gt; = &lt;span class=&quot;nv&quot;&gt;$lit_str&lt;/span&gt;;
    &lt;span class=&quot;n&quot;&gt;Comb&lt;/span&gt;[ &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (&lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;MTup&lt;/span&gt;) {
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; (
                &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; ~~ &lt;span class=&quot;sr&quot;&gt;m/^\s*$lit_str_\s* $&amp;lt;r&amp;gt; = [.*]/&lt;/span&gt; 
          ) {
            &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$matches&lt;/span&gt;=&lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;Matches&lt;/span&gt;](&lt;span class=&quot;nb&quot;&gt;Match&lt;/span&gt;[&lt;span class=&quot;nv&quot;&gt;$lit_str_&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;);
            &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str_&lt;/span&gt; = ~&lt;span class=&quot;nv&quot;&gt;$&amp;lt;r&amp;gt;&lt;/span&gt;; 
            &lt;span class=&quot;n&quot;&gt;MTup&lt;/span&gt;[&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$str_&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$matches&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
        } &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; {
            &lt;span class=&quot;n&quot;&gt;MTup&lt;/span&gt;[&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;undef-match&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;; 
        }
    }
    ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As explained in &lt;a href=&quot;&quot;&gt;my previous post&lt;/a&gt;, we use Raku&amp;#39;s &lt;code&gt;multi sub&lt;/code&gt;s for pattern matching on the types. In Haskell this is also possible, and the definition of &lt;code&gt;apply&lt;/code&gt; can be rewritten as:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Comb&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&amp;#39;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Seq&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; 
&lt;span class=&quot;nf&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Tag&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt;
                &lt;span class=&quot;kt&quot;&gt;MTup&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;matches&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;TaggedMatches&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; 
            &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt;
                &lt;span class=&quot;kt&quot;&gt;MTup&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The Raku version of &lt;code&gt;apply&lt;/code&gt; is quite close to this Haskell version. For convenience, I use a function &lt;code&gt;unmtup&lt;/code&gt; to unpack the &lt;code&gt;MTup&lt;/code&gt;. &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Comb&lt;/span&gt;[ &lt;span class=&quot;nb&quot;&gt;Sub&lt;/span&gt; ] &lt;span class=&quot;nv&quot;&gt;$p&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;MTup&lt;/span&gt;) {
    (&lt;span class=&quot;nv&quot;&gt;$p&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;comb&lt;/span&gt;)(&lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;);
}
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;Seq&lt;/span&gt;[ &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt; ] &lt;span class=&quot;nv&quot;&gt;$ps&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;MTup&lt;/span&gt;) {
    &lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt;( &lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt;( &lt;span class=&quot;nv&quot;&gt;$ps&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;combs&lt;/span&gt;), &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;);
}
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Tag&lt;/span&gt;[ &lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;LComb&lt;/span&gt; ] &lt;span class=&quot;nv&quot;&gt;$t&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;MTup&lt;/span&gt;) {
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MTup&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$res&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$t&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;comb&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;);
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;$status&lt;/span&gt;,  &lt;span class=&quot;nv&quot;&gt;$str2&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;@mms&lt;/span&gt;) = &lt;span class=&quot;n&quot;&gt;unmtup&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$res&lt;/span&gt;);
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Matches&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@matches&lt;/span&gt; = ( &lt;span class=&quot;n&quot;&gt;TaggedMatch&lt;/span&gt;[&lt;span class=&quot;nv&quot;&gt;$t&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;@mms&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt; );
    &lt;span class=&quot;n&quot;&gt;MTup&lt;/span&gt;[&lt;span class=&quot;nv&quot;&gt;$status&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$str2&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;@matches&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Finally, the &lt;code&gt;sequence&lt;/code&gt; code in Raku. It follows closely the structure of the Perl 5 and Haskell versions. Raku&amp;#39;s &lt;code&gt;reduce&lt;/code&gt; is equivalent to Haskell&amp;#39;s &lt;code&gt;foldl&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt; (&lt;span class=&quot;n&quot;&gt;LComb&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@combs&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;LComb&lt;/span&gt;) {
    &lt;span class=&quot;n&quot;&gt;Comb&lt;/span&gt;[
        &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (&lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;MTup&lt;/span&gt;) {
            &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Sub&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$f&lt;/span&gt; = &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; ( &lt;span class=&quot;n&quot;&gt;MTup&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;LComb&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$p&lt;/span&gt; --&amp;gt; &lt;span class=&quot;n&quot;&gt;MTup&lt;/span&gt;) {
                &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;$st1&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$str1&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$ms1&lt;/span&gt;) = &lt;span class=&quot;n&quot;&gt;unmtup&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;);
                &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MTup&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$res&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$p&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$str1&lt;/span&gt;);
                &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;$st2&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$str2&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$ms2&lt;/span&gt;) = &lt;span class=&quot;n&quot;&gt;unmtup&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$res&lt;/span&gt;);
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;$st2&lt;/span&gt;*&lt;span class=&quot;nv&quot;&gt;$st1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;) {
                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MTup&lt;/span&gt;[&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$str1&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;empty-match&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
                } &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; {
                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MTup&lt;/span&gt;[&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$str2&lt;/span&gt;,  
                        &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;Matches&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;(|&lt;span class=&quot;nv&quot;&gt;$ms1&lt;/span&gt;,|&lt;span class=&quot;nv&quot;&gt;$ms2&lt;/span&gt;) ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
                }
            }
            &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MTup&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$res&lt;/span&gt; = 
                &lt;span class=&quot;nb&quot;&gt;reduce&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$f&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;MTup&lt;/span&gt;[&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;empty-match&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;,|&lt;span class=&quot;nv&quot;&gt;@combs&lt;/span&gt;;
            &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;$status&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$rest&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$matches&lt;/span&gt;) = &lt;span class=&quot;n&quot;&gt;unmtup&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;$res&lt;/span&gt;);
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;$status&lt;/span&gt; == &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;) {
                &lt;span class=&quot;n&quot;&gt;MTup&lt;/span&gt;[&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$rest&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;empty-match&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
            } &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;n&quot;&gt;MTup&lt;/span&gt;[&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$rest&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$matches&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
            }
        }
    ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There is still a minor issue with this definition of &lt;code&gt;sequence&lt;/code&gt;: Because of the signature, we can&amp;#39;t write &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;, ...)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Instead, we would have to write&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;LComb&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;, ...))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which is a bit tedious. So I rename &lt;code&gt;sequence&lt;/code&gt; to &lt;code&gt;sequence_&lt;/code&gt; and wrap it in a new function &lt;code&gt;sequence&lt;/code&gt; which has a &amp;#39;slurpy&amp;#39; argument (i.e. it is variadic) like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt; (*&lt;span class=&quot;nv&quot;&gt;@ps&lt;/span&gt;) &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; {
    &lt;span class=&quot;n&quot;&gt;sequence_&lt;/span&gt;( &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;LComb&lt;/span&gt;](&lt;span class=&quot;nv&quot;&gt;@ps&lt;/span&gt;) ); 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I do the same for all combinators that take a list of combinators as argument. If you wanted to type check the arguments of the wrapper function, you could do this with a &lt;code&gt;where&lt;/code&gt; clause:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;choice&lt;/span&gt; (*&lt;span class=&quot;nv&quot;&gt;@ps&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; { .&lt;span class=&quot;nb&quot;&gt;all&lt;/span&gt; ~~ &lt;span class=&quot;n&quot;&gt;LComb&lt;/span&gt;} ) &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; {
    &lt;span class=&quot;n&quot;&gt;choice_&lt;/span&gt;( &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;LComb&lt;/span&gt;](&lt;span class=&quot;nv&quot;&gt;@ps&lt;/span&gt;));
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The type constructor based tagging (&lt;code&gt;Tag label parser&lt;/code&gt;) is nice in Haskell but in Raku it would look like &lt;code&gt;Tag[label, parser].new&lt;/code&gt; which I don&amp;#39;t like. Therefore, I wrap the constructor in a &lt;code&gt;tag&lt;/code&gt; function so I can write &lt;code&gt;tag(label, parser)&lt;/code&gt;. &lt;/p&gt;

&lt;h2&gt;An example of typical usage&lt;/h2&gt;

&lt;p&gt;As an example, we can construct the following parser for a part of a Fortran 90-style variable declaration, apply it to the given string and get the parse tree:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;type_parser&lt;/span&gt; =     
    &lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt;(
        &lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;( &lt;span class=&quot;s&quot;&gt;&amp;quot;Type&amp;quot;&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;),
        &lt;span class=&quot;k&quot;&gt;maybe&lt;/span&gt;( &lt;span class=&quot;n&quot;&gt;parens&lt;/span&gt;( 
            &lt;span class=&quot;n&quot;&gt;choice&lt;/span&gt;( 
                &lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;( &lt;span class=&quot;s&quot;&gt;&amp;quot;Kind&amp;quot;&lt;/span&gt; ,&lt;span class=&quot;n&quot;&gt;natural&lt;/span&gt;),
                &lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt;(
                    &lt;span class=&quot;n&quot;&gt;symbol&lt;/span&gt;( &lt;span class=&quot;s&quot;&gt;&amp;quot;kind&amp;quot;&lt;/span&gt;),
                    &lt;span class=&quot;n&quot;&gt;symbol&lt;/span&gt;( &lt;span class=&quot;s&quot;&gt;&amp;quot;=&amp;quot;&lt;/span&gt;),
                    &lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;( &lt;span class=&quot;s&quot;&gt;&amp;quot;Kind&amp;quot;&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;natural&lt;/span&gt;)
                )
            )
        ))
      ); 

&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;type_str&lt;/span&gt; = &lt;span class=&quot;s&quot;&gt;&amp;quot;integer(kind=8), &amp;quot;&lt;/span&gt;;

&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; (\&lt;span class=&quot;n&quot;&gt;tpst&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;tpstr&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;tpms&lt;/span&gt;) = &lt;span class=&quot;n&quot;&gt;unmtup&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt;( &lt;span class=&quot;n&quot;&gt;type_parser&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;type_str&lt;/span&gt;);   
&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getParseTree&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;tpms&lt;/span&gt;); 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(In Raku, variables declared with a &lt;code&gt;\&lt;/code&gt; are sigil-less )&lt;/p&gt;

&lt;p&gt;For reference, here is the Haskell code:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;type_parser&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;     
    &lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;Tag&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;Type&amp;quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;maybe&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parens&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; 
            &lt;span class=&quot;n&quot;&gt;choice&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
                &lt;span class=&quot;kt&quot;&gt;Tag&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;Kind&amp;quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;natural&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;symbol&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;kind&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;symbol&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;=&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Tag&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;Kind&amp;quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;natural&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; 
            &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;type_str&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;integer(kind=8), &amp;quot;&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;MTup&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tpst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tpstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tpms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type_parser&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type_str&lt;/span&gt;    
    &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getParseTree&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tpms&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(If you wonder about the strange signature of &lt;code&gt;main&lt;/code&gt;, the &lt;code&gt;do&lt;/code&gt; keyword or the &lt;code&gt;let&lt;/code&gt; without an &lt;code&gt;in&lt;/code&gt;, the answers are &lt;a href=&quot;http://learnyouahaskell.com/&quot;&gt;here&lt;/a&gt;. Or you could take &lt;a href=&quot;https://www.futurelearn.com/courses/functional-programming-haskell&quot;&gt;my free online course&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;As is clear from this example, in both languages, list-based parser combinators provide a clean and highly composable way of constructing powerful and complex parsers. It is also quite easy to extend the library with additional parsers. I think this is a nice practical application of algebraic data types in particular and functional programming in general. You can find both the &lt;a href=&quot;https://github.com/wimvanderbauwhede/list-based-combinators-hs&quot;&gt;Haskell code&lt;/a&gt; and the &lt;a href=&quot;https://github.com/wimvanderbauwhede/list-based-combinators-raku&quot;&gt;Raku code&lt;/a&gt; in my repo. &lt;/p&gt;

        </content>
    </entry>
    
    <entry>
        <title>Roles as Algebraic Data Types in Raku</title>
        <link href="https://wimvanderbauwhede.github.io/articles/roles-as-adts-in-raku/"/>
        <updated>2020-06-05T00:00:00+01:00</updated>
        <id>https://wimvanderbauwhede.github.io/articles/roles-as-adts-in-raku</id>
        <author>
					<name>Wim Vanderbauwhede</name>
					<uri>https://wimvanderbauwhede.github.io/</uri>
					
				</author>
        <content type="html">
        	&lt;img src=&quot;https://wimvanderbauwhede.github.io/images/roles-as-adts-in-raku_1600x600.jpg&quot;&gt;&lt;br/&gt;
        	&lt;p&gt;I have been a &lt;a href=&quot;https://andrewshitov.com/2015/05/05/interview-with-audrey-tang/&quot;&gt;lambdacamel&lt;/a&gt;, one of those who like &lt;a href=&quot;https://www.perl.org/&quot;&gt;Perl&lt;/a&gt; and functional programming, especially in &lt;a href=&quot;https://www.haskell.org/&quot;&gt;Haskell&lt;/a&gt;, for a long time. I still write most of my code in either of these languages.&lt;/p&gt;

&lt;p&gt;I&amp;#39;ve also been a fan of &lt;a href=&quot;https://raku.org/&quot;&gt;Raku&lt;/a&gt; from long before it was called Raku, but I&amp;#39;d never used it much in real life. Recently though, I&amp;#39;ve been moving increasingly to Raku for code that I don&amp;#39;t have to share with other people. It&amp;#39;s a lovely language, and its functional heritage is very strong. It was therefore only natural to me to explore the limits of Raku&amp;#39;s type system. &lt;/p&gt;

&lt;h2&gt;Is this article for you?&lt;/h2&gt;

&lt;p&gt;In this article I will introduce &lt;a href=&quot;https://www.cs.kent.ac.uk/people/staff/dat/miranda/nancypaper.pdf&quot;&gt;algebraic data types&lt;/a&gt;, a kind of static type system used in functional languages like Haskell, and a powerful mechanism for creating complex data structures. I will show a way to implement them in Raku using &lt;em&gt;roles&lt;/em&gt;. You don&amp;#39;t need to know Haskell at all and I only assume a slight familiarity with Raku (I&amp;#39;ve added &lt;a href=&quot;#raku-intro&quot;&gt;a quick introduction&lt;/a&gt;), but I do assume you are familiar with basic programming. You may find this article interesting if you are curious about functional-style static typing or if your would like an alternative to object-oriented programming. &lt;/p&gt;

&lt;h2&gt;Algebraic Data Types&lt;/h2&gt;

&lt;p&gt;Datatypes (types for short) are just labels or containers for values in a program. Algebraic data types are composite types, they are formed by combining other types.
They are called algebraic because they consist of alternatives (sums, also called disjoint unions) and record (products) of types. For more details see &lt;a href=&quot;https://codewords.recurse.com/issues/three/algebra-and-calculus-of-algebraic-data-types&quot;&gt;[1]&lt;/a&gt; or &lt;a href=&quot;https://gist.github.com/gregberns/5e9da0c95a9a8d2b6338afe69310b945&quot;&gt;[2]&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;To give a rough intuition for the terms &amp;quot;sum type&amp;quot; and &amp;quot;product type&amp;quot;: in Raku,  with Booleans &lt;code&gt;$a&lt;/code&gt;, &lt;code&gt;$b&lt;/code&gt; and &lt;code&gt;$c&lt;/code&gt;, you can write &lt;code&gt;$a or $b or $c&lt;/code&gt; but you could also write &lt;code&gt;$a + $b + $c&lt;/code&gt; and evaluate it as &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;. Similarly, &lt;code&gt;$a and $b and $c&lt;/code&gt; can be written as &lt;code&gt;$a * $b * $c&lt;/code&gt;. In other words, &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; behave in the same way as &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt;. In a generalised way, the types in algebraic data type system can be composed using similar rules.&lt;/p&gt;

&lt;h3&gt;A few examples.&lt;/h3&gt;

&lt;p&gt;Let&amp;#39;s first give a few examples of algebraic data types. In this section I am not using a specific programming language syntax. Instead I use a minimal notation to illustrate the concepts. I use the &lt;code&gt;datatype&lt;/code&gt; keyword to indicate that what follows is a declaration for an algebraic data type; for a sum type, I&amp;#39;ll separate the alternatives with &amp;#39;|&amp;#39;; for a product type, I separate the components with a space. To declare a variable to be of some type, I will write the type name in front of it.&lt;/p&gt;

&lt;p&gt;We can define a Boolean value purely as a type:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;datatype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;True&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;False&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And we can use this as&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;True&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This means that &lt;code&gt;ok&lt;/code&gt; is a variable of type &lt;code&gt;Bool&lt;/code&gt; with a value of &lt;code&gt;True&lt;/code&gt;. In an algebraic data type, the labels are called &amp;#39;constructors&amp;#39;. So &lt;code&gt;True&lt;/code&gt; is a constructor that takes no arguments.&lt;/p&gt;

&lt;p&gt;For a product type, we could for example create a type for an RGB colour triplet:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;datatype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;RGBColour&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;RGB&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;RGB&lt;/code&gt; label on the right-hand side is the constructor of the type. It takes three arguments of type &lt;code&gt;Int&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;RGBColour&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aquamarine&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;RGB&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;127&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;212&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So &lt;code&gt;aquamarine&lt;/code&gt; is a variable of type &lt;code&gt;RGBColour&lt;/code&gt; with a value of &lt;code&gt;RGB 127 255 212&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;The constructor identifies the type. Suppose we also have an HSL colour type&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;datatype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;HSLColour&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;HSL&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;with a variable &lt;code&gt;chocolate&lt;/code&gt; of that type:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;HSLColour&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chocolate&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;HSL&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;75&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;47&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;then both &lt;code&gt;RGB&lt;/code&gt; and &lt;code&gt;HSL&lt;/code&gt; are triplets of &lt;code&gt;Int&lt;/code&gt; but because of the different type constructors they are not the same type. &lt;/p&gt;

&lt;p&gt;Let&amp;#39;s say we create an RGB Pixel type:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;datatype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;XYCoord&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;XY&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;datatype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;RGBPixel&lt;/span&gt;  &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Pixel&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;RGBColour&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;XYCoord&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;then &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;RGBPixel&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Pixel&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aquamarine&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;XY&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is fine but&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;RGBPixel&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Pixel&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chocolate&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;XY&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;will be a type error because &lt;code&gt;chocolate&lt;/code&gt; is of type &lt;code&gt;HSLColour&lt;/code&gt;, not &lt;code&gt;RGBColour&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;We could support both RGB and HSL using a sum type:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;datatype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Colour&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;HSL&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;HSLColour&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;RGB&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;RGBColour&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and change make a Pixel type definition:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;datatype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Pixel&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Pixel&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Colour&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;XYCoord&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And now we can say &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;Pixel&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p_rgb&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Pixel&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;RGB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aquamarine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;XY&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;Pixel&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p_hsl&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Pixel&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;HSL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chocolate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;XY&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Integers and strings, recursion and polymorphism&lt;/h3&gt;

&lt;p&gt;I can hear you say: but what about &lt;code&gt;Int&lt;/code&gt;, it doesn&amp;#39;t have constructors? And what about a string, how can that be an algebraic data type? These are interesting questions as they allow me to introduce two more concepts: &lt;em&gt;recursive&lt;/em&gt; and &lt;em&gt;polymorphic&lt;/em&gt; types.&lt;/p&gt;

&lt;h4&gt;The type of an integer and recursive types&lt;/h4&gt;

&lt;p&gt;From a type perspective, you can look at an integer in two ways: if it is a fixed-size integer then the &lt;code&gt;Int&lt;/code&gt; type can be seen as a sum type. For example, the type for an 8-bit unsigned integer could be&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;datatype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UInt8&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In other words, every number is actually the name of a type constructor, as a generalisation of the &lt;code&gt;Bool&lt;/code&gt; type.&lt;/p&gt;

&lt;p&gt;However, in the mathematical sense, integers are not finite. If we consider the case of the natural numbers, we can construct a type for them as follows:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;datatype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nat&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;Z&lt;/code&gt; stands for &amp;quot;zero&amp;quot;, the &lt;code&gt;S&lt;/code&gt; for &amp;quot;successor of&amp;quot;. This is a &lt;em&gt;recursive&lt;/em&gt; type, because the &lt;code&gt;S&lt;/code&gt; constructor takes a &lt;code&gt;Nat&lt;/code&gt; as argument. With this type, we can now create any natural number:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Z&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Z&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This way of constructing the natural numbers is called &lt;a href=&quot;https://www.britannica.com/science/Peano-axioms&quot;&gt;Peano numbers&lt;/a&gt;.&lt;/p&gt;

&lt;h4&gt;The type of a string and polymorphic types&lt;/h4&gt;

&lt;p&gt;Now, what about strings? Enumerating all possible strings of any length is not practical. But from a type perspective, a string is a list of characters. So the question is then: what is the type of a list? For one thing, a list must be able to contain values of any type. (In the context of algebraic datatypes, all values must be the same, so our list is more like a typed array in Raku.) But that means we need types that can be parameterised by other types. This is called &lt;em&gt;parametric polymorphism&lt;/em&gt;. So a list type must look something like&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;datatype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where &lt;code&gt;a&lt;/code&gt; is a type variable, i.e. it can be replaced by an arbitrary type. For example, assuming we define the &lt;code&gt;Char&lt;/code&gt; type simply by enumerating all characters in the alphabet (because of course, at machine level, every character is represented by an integer number):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;datatype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Char&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&amp;#39;b&amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&amp;#39;c&amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&amp;#39;z&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then we can type our string as: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But what about &lt;code&gt;List&lt;/code&gt;? We use a similar approach as for &lt;code&gt;Nat&lt;/code&gt; above, using a recursive sum type:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;datatype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;EmptyList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we can create a list of any length:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; 
         &lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&amp;#39;h&amp;#39;&lt;/span&gt; 
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&amp;#39;e&amp;#39;&lt;/span&gt; 
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&amp;#39;l&amp;#39;&lt;/span&gt; 
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&amp;#39;l&amp;#39;&lt;/span&gt; 
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&amp;#39;o&amp;#39;&lt;/span&gt; 
        &lt;span class=&quot;kt&quot;&gt;EmptyList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using the typical syntactic sugar for lists, we can write this as     &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&amp;#39;h&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&amp;#39;l&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&amp;#39;l&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&amp;#39;o&amp;#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If I now invent an alias &lt;code&gt;Str&lt;/code&gt; for &lt;code&gt;List Char&lt;/code&gt;, and use double quotes instead of list notation, I can write    &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;Str&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So integers and strings can be expressed as algebraic data types, and now we have introduced recursive and parameterised types.&lt;/p&gt;

&lt;h3&gt;What are algebraic data types good for?&lt;/h3&gt;

&lt;p&gt;These may seem like rather contrived examples, after all a language like Raku already has an &lt;code&gt;Int&lt;/code&gt; and a &lt;code&gt;Str&lt;/code&gt; type that work very well. So what is the use of these  algebraic data types? Of course the purpose of static types is to provide type safety and make debugging easier. But using algebraic data types also makes a different, more functional style of programming possible.&lt;/p&gt;

&lt;p&gt;One common use case is a list where you want to store values of different types: you can create a sum type that has an alternative for each of these types. Another common case is a recursive type, such as a tree. Finally, the polymorphism provides a convenient way to create custom containers. I will give examples of each of these in the next section. Time to move on to Raku!&lt;/p&gt;

&lt;h2&gt;Algebraic data types in Raku&lt;/h2&gt;

&lt;p&gt;As Raku is not a very well-known language (yet), here is a quick introduction of the features you&amp;#39;ll need to follow the discussion below. &lt;/p&gt;

&lt;p&gt;&lt;a name=&quot;raku-intro&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;A quick introduction to Raku&lt;/h3&gt;

&lt;p&gt;Before Raku went its own way, it was meant to be the next iteration of Perl (hence the original name Perl 6). It is therefore more similar to Perl than to any other language.&lt;/p&gt;

&lt;p&gt;Raku is syntactically similar to C/C++, Java and JavaScript: block-based, with statements separated by semicolons, blocks demarcated by braces, and argument lists in parentheses and separated by commas. The main feature it shares with Perl is the use of sigils (&amp;#39;funny characters&amp;#39;) which identify the type of a variable: &lt;code&gt;$&lt;/code&gt; for a scalar, &lt;code&gt;@&lt;/code&gt; for an array, &lt;code&gt;%&lt;/code&gt; for a hash (map) and &lt;code&gt;&amp;amp;&lt;/code&gt; for a subroutine. Variables also have keywords to identify their scope, I will only use &lt;code&gt;my&lt;/code&gt; which marks the variable as lexically scoped. A subroutine is declared with the &lt;code&gt;sub&lt;/code&gt; keyword, and subroutines can be named or anonymous:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;square&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt;) {
    &lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt;*&lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt;;
}
&lt;span class=&quot;c1&quot;&gt;# anonymous subroutine &lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$anon_square&lt;/span&gt; = &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; (&lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt;) {
    &lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt;*&lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Raku also has &lt;a href=&quot;https://docs.raku.org/language/variables#index-entry-Twigil&quot;&gt;twigils&lt;/a&gt;, secondary sigils that influence the scoping of a variable. For this article, the only twigil used in the code is &lt;code&gt;.&lt;/code&gt; which is used to declare a role or class attribute with automatically generated accessors (like &lt;code&gt;$.notes&lt;/code&gt; in the example below).&lt;/p&gt;

&lt;p&gt;Raku supports sigil-less variables, and uses the &lt;code&gt;\&lt;/code&gt; syntax to declare them. For more on the difference between ordinary and sigil-less variables, see &lt;a href=&quot;https://docs.raku.org/language/variables#Sigilless_variables&quot;&gt;the Raku documentation&lt;/a&gt;. For example (&lt;code&gt;say&lt;/code&gt; prints its argument followed by a newline):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; = &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$y&lt;/span&gt; = &lt;span class=&quot;mi&quot;&gt;43&lt;/span&gt;;
&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;x&lt;/span&gt; + &lt;span class=&quot;nv&quot;&gt;$y&lt;/span&gt;; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Raku has &lt;a href=&quot;https://raku.guide/&quot;&gt;gradual typing&lt;/a&gt;: it allows both static and dynamic typing. That&amp;#39;s a good start because we need static typing to support algebraic data types. It also has &lt;a href=&quot;https://docs.raku.org/language/variables&quot;&gt;immutable variables&lt;/a&gt; and &lt;a href=&quot;https://raku.guide/#_anonymous_functions&quot;&gt;anonymous functions&lt;/a&gt;, and even &lt;a href=&quot;https://docs.raku.org/language/list#index-entry-laziness_in_Iterable_objects&quot;&gt;(limited) laziness&lt;/a&gt;. And of course &lt;a href=&quot;https://raku.guide/#_functional_programming&quot;&gt;functions are first-class citizens&lt;/a&gt;, so we have everything we need for pure, statically-typed functional programming. But what about the algebraic data types?&lt;/p&gt;

&lt;p&gt;In Raku, &lt;code&gt;enum&lt;/code&gt;s are sum types:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;lt;False True&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, they are limited to type constructors that don&amp;#39;t take any arguments. &lt;/p&gt;

&lt;p&gt;Classes can be seen as product types:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BoolAndInt&lt;/span&gt; {
        &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.bool&lt;/span&gt;;
        &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.int&lt;/span&gt;;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, classes do not support parametric polymorphism. &lt;/p&gt;

&lt;p&gt;This is where &lt;em&gt;roles&lt;/em&gt; come in. According to the &lt;a href=&quot;https://docs.raku.org/language/objects#Roles&quot;&gt;Raku documentation&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
Roles are a collection of attributes and methods; however, unlike classes, roles are meant for describing only parts of an object's behavior; this is why, in general, roles are intended to be mixed in classes and objects. In general, classes are meant for managing objects and roles are meant for managing behavior and code reuse within objects.
&lt;/blockquote&gt;

&lt;p&gt;Roles use the keyword &lt;code&gt;role&lt;/code&gt; preceding the name of the role that is declared. Roles are mixed in using the &lt;code&gt;does&lt;/code&gt; keyword preceding the name of the role that is mixed in.  Roles are what in Python and Ruby is called &lt;em&gt;mixins&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;So roles are basically classes that you can use to add behaviours to other classes without using inheritance. Here is a stripped-down example take from the &lt;a href=&quot;https://docs.raku.org/language/objects#Roles&quot;&gt;Raku documentation&lt;/a&gt; (&lt;code&gt;has&lt;/code&gt; declares an attribute, &lt;code&gt;method&lt;/code&gt; a method)&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Notable&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.notes&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;rw&lt;/span&gt;;

    &lt;span class=&quot;k&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;notes&lt;/span&gt;() { ... }; 
}

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Journey&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Notable&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.origin&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.destination&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@.travelers&lt;/span&gt;;

    &lt;span class=&quot;k&quot;&gt;method&lt;/span&gt; { ... &lt;span class=&quot;s&quot;&gt;&amp;lt;implemented using notes()&amp;gt;&lt;/span&gt; ... };
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In particular, roles can be mixed into other roles, and that is one of the key features I will exploit. Furthermore, role constructors can take arguments &lt;em&gt;and&lt;/em&gt; they are parametric. So we have everything we need to create proper algebraic data types. Let&amp;#39;s look at a few examples.&lt;/p&gt;

&lt;h3&gt;A few simple examples&lt;/h3&gt;

&lt;h4&gt;An opinionated Boolean&lt;/h4&gt;

&lt;p&gt;This is the example of a sum type for a Boolean as above, but implemented with roles. The first line declares the type as an empty role, this corresponds to the data type name on the left-hand side. The next lines define the alternatives, each alternative uses &lt;code&gt;does OpinionatedBool&lt;/code&gt; to tie it to the &lt;code&gt;OpinionatedBool&lt;/code&gt; role which functions purely as the type name.  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OpinionatedBool&lt;/span&gt; {}
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AbsolutelyTrue&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OpinionatedBool&lt;/span&gt; {}
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TotallyFalse&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OpinionatedBool&lt;/span&gt; {}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In Raku, types are values; and for a role with an empty body, you don&amp;#39;t need the &lt;code&gt;.new&lt;/code&gt; constructor call. In a sum type, the alternatives usually are labelled containers for values, but they can be empty containers as well. When that is the case, there is no need to create separate instances of them because there is only one way to have an empty container.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OpinionatedBool&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;bt&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;AbsolutelyTrue&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Sum types can be used in combination with Raku&amp;#39;s &lt;code&gt;multi sub&lt;/code&gt; feature: Raku lets you provide several definitions for a function, with the same name but different signatures. With multi subs we can do what is known as pattern matching on types:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;AbsolutelyTrue&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$b&lt;/span&gt;) {
    &lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;True&amp;#39;&lt;/span&gt;;
}
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;TotallyFalse&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$b&lt;/span&gt;) {
    &lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;False&amp;#39;&lt;/span&gt;;
}

&lt;span class=&quot;c1&quot;&gt;# Trying it out:&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;bt&lt;/span&gt;); &lt;span class=&quot;c1&quot;&gt;# prints True&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Because we use a type as a value, to test if a value is &lt;code&gt;AbsolutelyTrue&lt;/code&gt; or &lt;code&gt;TotallyFalse&lt;/code&gt;, we can use either the smart match &lt;code&gt;~~&lt;/code&gt;, the container (type) identity &lt;code&gt;=:=&lt;/code&gt; or the value (instance) identity &lt;code&gt;===&lt;/code&gt; to test this (the smart match operator behaves like &lt;code&gt;=:=&lt;/code&gt; if the right-hand side is a type and as &lt;code&gt;===&lt;/code&gt; if it is an object instance). If we would create an instance like &lt;code&gt;AbsolutelyTrue.new&lt;/code&gt;, this would not be the case. See the &lt;a href=&quot;https://github.com/wimvanderbauwhede/raku-examples/blob/master/roles_types_and_instances.raku&quot;&gt;code example&lt;/a&gt; for more details.&lt;/p&gt;

&lt;h4&gt;The Colour, XYCoord and Pixel types&lt;/h4&gt;

&lt;p&gt;Here is the implementation of the &lt;code&gt;Colour&lt;/code&gt;, &lt;code&gt;XYCoord&lt;/code&gt; and &lt;code&gt;Pixel&lt;/code&gt; types from above. The &lt;code&gt;RGBColour&lt;/code&gt; type is an example of a product type. There are two differences with my notation from above:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;datatype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;RGBColour&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;RGB&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;Because the role serves both as the type (&lt;code&gt;RGBColour&lt;/code&gt;) and the instance constructor (&lt;code&gt;RGB&lt;/code&gt;), they must have the same name. I only named them differently to make it easier to distinguish them so this is not an issue.&lt;/li&gt;
&lt;li&gt;The types that make up each field must be named with unique names in the role&amp;#39;s argument list, and need to have a corresponding attributes declared. That is again not really a limitation, because accessors for record type fields are handy. So it looks like:&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RGBColour&lt;/span&gt;[&lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;] {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.r&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.g&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.b&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(the role&amp;#39;s parameters are in square brackets)&lt;/p&gt;

&lt;p&gt;And we create &lt;code&gt;aquamarine&lt;/code&gt; like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RGBColour&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;aquamarine&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;RGBColour&lt;/span&gt;[ &lt;span class=&quot;mi&quot;&gt;127&lt;/span&gt;, &lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;, &lt;span class=&quot;mi&quot;&gt;212&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The definitions of &lt;code&gt;HSLColour&lt;/code&gt; and &lt;code&gt;XYCoord&lt;/code&gt; are analogous, you can find them in the &lt;a href=&quot;https://github.com/wimvanderbauwhede/raku-examples/blob/master/role_as_adt_colour_example.raku&quot;&gt;code example&lt;/a&gt;. Let&amp;#39;s look at the sum type to combine the RGB and HSL colour types:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Colour&lt;/span&gt; {}
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HSL&lt;/span&gt;[ &lt;span class=&quot;n&quot;&gt;HSLColour&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;hsl&lt;/span&gt;] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Colour&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HSLColour&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.hsl&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;hsl&lt;/span&gt;;
};
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RGB&lt;/span&gt;[ &lt;span class=&quot;n&quot;&gt;RGBColour&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;rgb&lt;/span&gt;] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Colour&lt;/span&gt; {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RGBColour&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.rgb&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;rgb&lt;/span&gt;;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is essentially the same approach as for the opinionated Boolean, but we don&amp;#39;t have empty roles: the &lt;code&gt;HSL&lt;/code&gt; alternative takes an argument of type &lt;code&gt;HSLColour&lt;/code&gt;, and the &lt;code&gt;RGB&lt;/code&gt; alternative takes an argument of type &lt;code&gt;RGBColour&lt;/code&gt;.
As in the product type, we use the role as a container to hold the values. The &lt;code&gt;Pixel&lt;/code&gt; type from above looks like: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pixel&lt;/span&gt;[ &lt;span class=&quot;n&quot;&gt;Colour&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;XYCoord&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;xy&lt;/span&gt; ] {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Colour&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.c&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;XYCoord&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.xy&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;xy&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And now we can create pixels with RGB and HSL colours:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pixel&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;p_rgb&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;Pixel&lt;/span&gt;[ &lt;span class=&quot;n&quot;&gt;RGB&lt;/span&gt;[ &lt;span class=&quot;n&quot;&gt;aquamarine&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt; , &lt;span class=&quot;n&quot;&gt;XYCoord&lt;/span&gt;[ &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;, &lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt; ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pixel&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;p_hsl&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;Pixel&lt;/span&gt;[ &lt;span class=&quot;n&quot;&gt;HSL&lt;/span&gt;[ &lt;span class=&quot;n&quot;&gt;chocolate&lt;/span&gt; ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt; , &lt;span class=&quot;n&quot;&gt;XYCoord&lt;/span&gt;[ &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;, &lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt; ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Recursion and polymorphism&lt;/h4&gt;

&lt;p&gt;Above, I showed the Peano number type to illustrate type-level recursion. This works just fine with roles in Raku too:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Nat&lt;/span&gt;{}    
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Nat&lt;/span&gt; {}
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$n&lt;/span&gt;] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Nat&lt;/span&gt; {}  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And we can combine this with type parameters as in the list example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt;[::&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;] {}
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EmptyList&lt;/span&gt;[::&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;] {}
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Cons&lt;/span&gt;[ ::&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; ] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;] {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.elt&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;elt&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.lst&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(The prefix &lt;code&gt;::&lt;/code&gt; is the Raku syntax to declare type variables)&lt;/p&gt;

&lt;h5&gt;Issues with current raku&lt;/h5&gt;

&lt;p&gt;There are some issues here: &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;EmptyList&lt;/code&gt; alternative must either be declared as above, with a type parameter, or as&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EmptyList&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt; {}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where the type also doesn&amp;#39;t take a type variable. We can&amp;#39;t write&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EmptyList&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;List&lt;/span&gt;[::&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;] {}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is of course only a minor issue, resulting only in some redundancy.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A more serious issue is that the type of &lt;code&gt;lst&lt;/code&gt; must be &lt;code&gt;List&lt;/code&gt; (or &lt;code&gt;List[]&lt;/code&gt;) instead of &lt;code&gt;List[a]&lt;/code&gt;. That is actually a problem, as it weakens the type checking. So it must be a bug in the current version of &lt;code&gt;raku&lt;/code&gt; (2020.01). When I provide &lt;code&gt;List[a]&lt;/code&gt; I get the following error:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Could not instantiate role &amp;#39;Cons&amp;#39;:
    Internal error: inconsistent bind result
    in any protect at gen/moar/stage2/NQPCORE.setting line 1216
    in block &amp;lt;unit&amp;gt; at list-adt.raku line 12
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;A few more useful examples&lt;/h3&gt;

&lt;h4&gt;A multi-type array&lt;/h4&gt;

&lt;p&gt;For the first example, I want to store values of different types in a typed array. They elements can be strings, labeled lists of strings, or undefined. I call this type &lt;code&gt;Matches&lt;/code&gt;. Using the notation from above, it would be&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;datatype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Matches&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; 
      &lt;span class=&quot;kt&quot;&gt;Match&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Str&lt;/span&gt; 
    &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TaggedMatches&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Str&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Matches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UndefinedMatch&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In Raku, it is defined as follows:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Matches&lt;/span&gt; {}
    &lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UndefinedMatch&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Matches&lt;/span&gt; {}
    &lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Match&lt;/span&gt;[&lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Matches&lt;/span&gt; {
        &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.match&lt;/span&gt;=&lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;;
    } 
    &lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TaggedMatches&lt;/span&gt;[&lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$tag&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;Matches&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@ms&lt;/span&gt;] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Matches&lt;/span&gt; {
        &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.tag&lt;/span&gt; = &lt;span class=&quot;nv&quot;&gt;$tag&lt;/span&gt;;
        &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Matches&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@.matches&lt;/span&gt; = &lt;span class=&quot;nv&quot;&gt;@ms&lt;/span&gt;;
    } 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This type uses type constructors with 0 (&lt;code&gt;UndefinedMatch&lt;/code&gt;), 1 (&lt;code&gt;Match&lt;/code&gt;) and 2 (&lt;code&gt;TaggedMatches&lt;/code&gt;) arguments, and the latter is a recursive type: the second argument is a list of &lt;code&gt;Matches&lt;/code&gt;. With this definition, we can create an array of matches like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Matches&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@ms&lt;/span&gt; = &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;Matches&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;(
        &lt;span class=&quot;nb&quot;&gt;Match&lt;/span&gt;[&lt;span class=&quot;s&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;,
        &lt;span class=&quot;n&quot;&gt;TaggedMatches&lt;/span&gt;[
            &lt;span class=&quot;s&quot;&gt;&amp;quot;Adjectives&amp;quot;&lt;/span&gt;,
            &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;Matches&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;(
                &lt;span class=&quot;nb&quot;&gt;Match&lt;/span&gt;[&lt;span class=&quot;s&quot;&gt;&amp;quot;brave&amp;quot;&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;,
                &lt;span class=&quot;nb&quot;&gt;Match&lt;/span&gt;[&lt;span class=&quot;s&quot;&gt;&amp;quot;new&amp;quot;&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;) 
                ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;,
        &lt;span class=&quot;nb&quot;&gt;Match&lt;/span&gt;[&lt;span class=&quot;s&quot;&gt;&amp;quot;world&amp;quot;&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;
        );
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As you can see, the typed values are actually constructed by calling &lt;code&gt;.new&lt;/code&gt;. It is a bit nicer to create constructor functions, and once Raku has a more developped macro system, we might be able to generate these automatically.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Matches&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@ms&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;mkMatches&lt;/span&gt;(
        &lt;span class=&quot;n&quot;&gt;mkMatch&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;,
        &lt;span class=&quot;n&quot;&gt;mkTaggedMatches&lt;/span&gt;(
            &lt;span class=&quot;s&quot;&gt;&amp;quot;Adjectives&amp;quot;&lt;/span&gt;,
            &lt;span class=&quot;n&quot;&gt;mkMatches&lt;/span&gt;(
                &lt;span class=&quot;n&quot;&gt;mkMatch&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;brave&amp;quot;&lt;/span&gt;,
                &lt;span class=&quot;n&quot;&gt;mkMatch&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;new&amp;quot;&lt;/span&gt; 
                )
        ),
        &lt;span class=&quot;n&quot;&gt;mkMatch&lt;/span&gt; &amp;quot;&lt;span class=&quot;n&quot;&gt;world&lt;/span&gt;)
        );
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wimvanderbauwhede/raku-examples/blob/master/roles_as_types.raku&quot;&gt;Code for this example&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;A generic tuple&lt;/h4&gt;

&lt;p&gt;For the next example, I want to define a type called &lt;code&gt;Either&lt;/code&gt;. This is a parametric sum type with two parameters, so a kind of generic tuple:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;datatype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Left&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Right&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In Raku, this can be done through the use of type variables as parameters for the role:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Either&lt;/span&gt;[::&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;,::&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;] { }
    &lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Left&lt;/span&gt;[::&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;,::&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Either&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;] { 
        &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.left&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;;
    }
    &lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Right&lt;/span&gt;[::&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;,::&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Either&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;] { 
        &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.right&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Because Raku expects both type variables to be declared in each constructor, it is a little bit less nice than my more abstract notation. We can pattern match on this type with a &lt;code&gt;multi sub&lt;/code&gt;: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt; (&lt;span class=&quot;n&quot;&gt;Left&lt;/span&gt;[&lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt;,&lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt;] &lt;span class=&quot;nv&quot;&gt;$v&lt;/span&gt;) { &lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;Left: &amp;#39;&lt;/span&gt;~&lt;span class=&quot;nv&quot;&gt;$v&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; }
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt; (&lt;span class=&quot;n&quot;&gt;Right&lt;/span&gt;[&lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt;,&lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt;] &lt;span class=&quot;nv&quot;&gt;$v&lt;/span&gt;) {&lt;span class=&quot;nb&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;Right: &amp;#39;&lt;/span&gt;~&lt;span class=&quot;nv&quot;&gt;$v&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So we can write&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Either&lt;/span&gt;[&lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt;,&lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt;] \&lt;span class=&quot;n&quot;&gt;iv&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;Left&lt;/span&gt;[&lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;,&lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Either&lt;/span&gt;[&lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt;,&lt;span class=&quot;nb&quot;&gt;Str&lt;/span&gt;] \&lt;span class=&quot;n&quot;&gt;sv&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;Right&lt;/span&gt;[&lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt;,&lt;span class=&quot;s&quot;&gt;&amp;#39;forty-two&amp;#39;&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;

&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;iv&lt;/span&gt;); &lt;span class=&quot;c1&quot;&gt;# prints &amp;#39;Left: 42&amp;#39;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;sv&lt;/span&gt;); &lt;span class=&quot;c1&quot;&gt;# prints &amp;#39;Right: forty-two&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wimvanderbauwhede/raku-examples/blob/master/either.raku&quot;&gt;Code for this example&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;A parameterised binary tree&lt;/h4&gt;

&lt;p&gt;As a final example, here is a simple binary tree. First, let&amp;#39;s look at an example implementation using a role from the &lt;a href=&quot;https://docs.raku.org/language/objects#index-entry-Parameterized_Roles&quot;&gt;Raku documentation&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BinaryTree&lt;/span&gt;[::&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;] {
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BinaryTree&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;] &lt;span class=&quot;nv&quot;&gt;$.left&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BinaryTree&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;] &lt;span class=&quot;nv&quot;&gt;$.right&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.node&lt;/span&gt;;

    &lt;span class=&quot;k&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visit-preorder&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;&amp;amp;cb&lt;/span&gt;) {
        &lt;span class=&quot;n&quot;&gt;cb&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.node&lt;/span&gt;;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.left&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$.right&lt;/span&gt; -&amp;gt; &lt;span class=&quot;nv&quot;&gt;$branch&lt;/span&gt; {
            &lt;span class=&quot;nv&quot;&gt;$branch&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;visit-preorder&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;&amp;amp;cb&lt;/span&gt;) &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;defined&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$branch&lt;/span&gt;;
        }
    }
    &lt;span class=&quot;k&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visit-postorder&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;&amp;amp;cb&lt;/span&gt;) {
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.left&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$.right&lt;/span&gt; -&amp;gt; &lt;span class=&quot;nv&quot;&gt;$branch&lt;/span&gt; {
            &lt;span class=&quot;nv&quot;&gt;$branch&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;visit-postorder&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;&amp;amp;cb&lt;/span&gt;) &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;defined&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$branch&lt;/span&gt;;
        }
        &lt;span class=&quot;n&quot;&gt;cb&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.node&lt;/span&gt;;
    }
    &lt;span class=&quot;k&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new-from-list&lt;/span&gt;(&lt;span class=&quot;vg&quot;&gt;::?CLASS&lt;/span&gt;:&lt;span class=&quot;n&quot;&gt;U:&lt;/span&gt; *&lt;span class=&quot;nv&quot;&gt;@el&lt;/span&gt;) {
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$middle-index&lt;/span&gt; = &lt;span class=&quot;nv&quot;&gt;@el&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;elems&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;;
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@left&lt;/span&gt;         = &lt;span class=&quot;nv&quot;&gt;@el&lt;/span&gt;[&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; .. &lt;span class=&quot;nv&quot;&gt;$middle-index&lt;/span&gt; - &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;];
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$middle&lt;/span&gt;       = &lt;span class=&quot;nv&quot;&gt;@el&lt;/span&gt;[&lt;span class=&quot;nv&quot;&gt;$middle-index&lt;/span&gt;];
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@right&lt;/span&gt;        = &lt;span class=&quot;nv&quot;&gt;@el&lt;/span&gt;[&lt;span class=&quot;nv&quot;&gt;$middle-index&lt;/span&gt; + &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; .. *];
        &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;(
            &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;    =&amp;gt; &lt;span class=&quot;nv&quot;&gt;$middle&lt;/span&gt;,
            &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;    =&amp;gt; &lt;span class=&quot;nv&quot;&gt;@left&lt;/span&gt;  ?? &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;new-from-list&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;@left&lt;/span&gt;)  !! &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;,
            &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;   =&amp;gt; &lt;span class=&quot;nv&quot;&gt;@right&lt;/span&gt; ?? &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;new-from-list&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;@right&lt;/span&gt;) !! &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;,
        );
}

&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$t&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;BinaryTree&lt;/span&gt;[&lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt;].&lt;span class=&quot;n&quot;&gt;new-from-list&lt;/span&gt;(&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;);
&lt;span class=&quot;nv&quot;&gt;$t&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;visit-preorder&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;&amp;amp;say&lt;/span&gt;);    &lt;span class=&quot;c1&quot;&gt;# OUTPUT: «5␤4␤6␤» &lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$t&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;visit-postorder&lt;/span&gt;(&lt;span class=&quot;nv&quot;&gt;&amp;amp;say&lt;/span&gt;);   &lt;span class=&quot;c1&quot;&gt;# OUTPUT: «4␤6␤5␤» &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This example contains quite a bit of Raku syntax:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Raku allows dashes in names;&lt;/li&gt;
&lt;li&gt;the &lt;code&gt;-&amp;gt;&lt;/code&gt; syntax is a foreach loop, iterating over all elements of the preceding list;&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;..&lt;/code&gt; is array slicing;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;::?CLASS&lt;/code&gt; is a compile-time type variable populated with the class you&amp;#39;re in and &lt;code&gt;:U&lt;/code&gt; is a type constraint which specifies that it should be interpreted as a type object. Finally, the &lt;code&gt;:&lt;/code&gt; marks the argument to its left as the invocant. In other words, it allows us to write &lt;code&gt;BinaryTree[Int].new-from-list(4, 5, 6)&lt;/code&gt; where &lt;code&gt;BinaryTree[Int] is the value of&lt;/code&gt;::?CLASS`. This is the Raku way to create custom constructors.&lt;br&gt;&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;*&lt;/code&gt; in front of the &lt;code&gt;@el&lt;/code&gt; argument of &lt;code&gt;new-from-list&lt;/code&gt; makes this a variadic function where &lt;code&gt;@el&lt;/code&gt; contains all arguments;&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;=&amp;gt;&lt;/code&gt; syntax allows to assign arguments by name rather than by position;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;?? ... !! ...&lt;/code&gt; is Raku&amp;#39;s syntax for C&amp;#39;s ternary &lt;code&gt;? ... : ...&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This example is written in Raku&amp;#39;s object-oriented style, with methods acting on the attributes of the role. Let&amp;#39;s see how we can write this in a functional style.&lt;/p&gt;

&lt;p&gt;The algebraic data type for this binary tree is:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;datatype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BinaryTree&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; 
      &lt;span class=&quot;kt&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;BinaryTree&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;BinaryTree&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; 
    &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Tip&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;Tip&lt;/code&gt; alternative is for the empty leaf nodes of the tree, which in the above example are left undefined. In Raku, we can implement this type as: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BinaryTree&lt;/span&gt;[::&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;] { }
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;[::&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;,  \&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;,  \&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;, \&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BinaryTree&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;] { 
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BinaryTree&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;] &lt;span class=&quot;nv&quot;&gt;$.left&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BinaryTree&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;] &lt;span class=&quot;nv&quot;&gt;$.right&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$.node&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;;
}
&lt;span class=&quot;k&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tip&lt;/span&gt;[::&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;] &lt;span class=&quot;nb&quot;&gt;does&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BinaryTree&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;] { }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Instead of the methods we use functions, implemented as &lt;code&gt;multi sub&lt;/code&gt;s. Most of the code is of course identical, but there is no need for conditionals to check if a leaf node has been reached. I have also used sigil-less immutable variables.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl6&quot; data-lang=&quot;perl6&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visit-preorder&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;cb&lt;/span&gt;) {
    &lt;span class=&quot;n&quot;&gt;cb&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; -&amp;gt; \&lt;span class=&quot;n&quot;&gt;branch&lt;/span&gt; {
        &lt;span class=&quot;n&quot;&gt;visit-preorder&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;branch&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;cb&lt;/span&gt;)
    }
}
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visit-preorder&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Tip&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;cb&lt;/span&gt;) { }

&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visit-postorder&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;cb&lt;/span&gt;) {    
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;, &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; -&amp;gt; \&lt;span class=&quot;n&quot;&gt;branch&lt;/span&gt; {
        &lt;span class=&quot;n&quot;&gt;visit-postorder&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;branch&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;cb&lt;/span&gt;)
    }
    &lt;span class=&quot;n&quot;&gt;cb&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;.&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;;
}
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visit-postorder&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;Tip&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;cb&lt;/span&gt;) { }

&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new-from-list&lt;/span&gt;(::&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;,[]) {
    &lt;span class=&quot;n&quot;&gt;Tip&lt;/span&gt;[&lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt;].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;    
}
&lt;span class=&quot;k&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new-from-list&lt;/span&gt;(::&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;,\&lt;span class=&quot;n&quot;&gt;el&lt;/span&gt;) {
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;middle-index&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;el&lt;/span&gt;.&lt;span class=&quot;nb&quot;&gt;elems&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;         = &lt;span class=&quot;n&quot;&gt;el&lt;/span&gt;[&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; .. &lt;span class=&quot;n&quot;&gt;middle-index&lt;/span&gt; - &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;];
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;middle&lt;/span&gt;       = &lt;span class=&quot;n&quot;&gt;el&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;middle-index&lt;/span&gt;];
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; \&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;        = &lt;span class=&quot;n&quot;&gt;el&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;middle-index&lt;/span&gt; + &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; .. *];    
    &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;[&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;,
        &lt;span class=&quot;n&quot;&gt;new-from-list&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;),
        &lt;span class=&quot;n&quot;&gt;new-from-list&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;,&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;),
        &lt;span class=&quot;n&quot;&gt;middle&lt;/span&gt;            
    ].&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;;
}

&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BinaryTree&lt;/span&gt;[&lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt;] \&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; = &lt;span class=&quot;n&quot;&gt;new-from-list&lt;/span&gt;(&lt;span class=&quot;nb&quot;&gt;Int&lt;/span&gt;,[&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;]);
&lt;span class=&quot;n&quot;&gt;visit-preorder&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;say&lt;/span&gt;);    &lt;span class=&quot;c1&quot;&gt;# OUTPUT: «5␤4␤6␤» &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;visit-postorder&lt;/span&gt;(&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;&amp;amp;say&lt;/span&gt;);   &lt;span class=&quot;c1&quot;&gt;# OUTPUT: «4␤6␤5␤» &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;One thing to note is that in the &lt;code&gt;multi sub&lt;/code&gt;s we don&amp;#39;t have to match against the full type, for example in &lt;code&gt;visit-preorder&lt;/code&gt; we match against &lt;code&gt;Tip&lt;/code&gt; and &lt;code&gt;Node&lt;/code&gt; rather than the full &lt;code&gt;Tip[a]&lt;/code&gt; and &lt;code&gt;Node[::a,BinaryTree[a],BinaryTree[a],a]&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/wimvanderbauwhede/raku-examples/blob/master/binary_tree_2.p6&quot;&gt;Code for this example&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Wrap-up&lt;/h2&gt;

&lt;p&gt;Creating algebraic data types with Raku&amp;#39;s roles is very straightforward. Any product type is simply a role with a number of typed attributes. The key idea for the sum type is to create an empty role and mix it in with other roles that become the type constructors for your alternatives. Because roles accept type parameters, we can have parametric polymorphism. And because a role can have attributes of its own type, we have recursive types as well. Combined with Raku&amp;#39;s other functional programming features, this makes writing pure, statically typed functional code in Raku great fun.  &lt;/p&gt;

&lt;h3&gt;References&lt;/h3&gt;

&lt;p&gt;[1] &lt;a href=&quot;https://codewords.recurse.com/issues/three/algebra-and-calculus-of-algebraic-data-types&quot;&gt;&amp;quot;The algebra (and calculus!) of algebraic data types&amp;quot;, by Joel Burget&lt;/a&gt;
&lt;br/&gt;
[2] &lt;a href=&quot;https://gist.github.com/gregberns/5e9da0c95a9a8d2b6338afe69310b945&quot;&gt;&amp;quot;The Algebra of Algebraic Data Types, Part 1&amp;quot;, by Chris Taylor&lt;/a&gt;&lt;/p&gt;

        </content>
    </entry>
    
    <entry>
        <title>The Winds of Kyoto</title>
        <link href="https://wimvanderbauwhede.github.io/articles/the-winds-of-kyoto/"/>
        <updated>2020-03-28T00:00:00+00:00</updated>
        <id>https://wimvanderbauwhede.github.io/articles/the-winds-of-kyoto</id>
        <author>
					<name>Wim Vanderbauwhede</name>
					<uri>https://wimvanderbauwhede.github.io/</uri>
					
				</author>
        <content type="html">
        	&lt;img src=&quot;https://wimvanderbauwhede.github.io/images/the-winds-of-kyoto_1600x600.jpg&quot;&gt;&lt;br/&gt;
        	&lt;p&gt;I wrote a very short story for the &lt;a href=&quot;https://www.writersinkyoto.com/2019/12/writers-in-kyoto-present-the-fifth-annual-kyoto-writing-competition/&quot;&gt;Fifth Annual Kyoto Writing Competition&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;At the &lt;a href=&quot;www.dpri.kyoto-u.ac.jp/en/&quot;&gt;Disaster Prevention Research Institute&lt;/a&gt; of Kyoto University, researchers are modelling the flow of the wind over the city.&lt;/p&gt;

&lt;p&gt;The wind that blows over the tiny machiyas of Gion and around Kyoto station with its tall hotels and the Tower.&lt;/p&gt;

&lt;p&gt;In spring, it scatters a storm of sakura petals all over the city. In the rainy season, it blows down from Arashiyama along the waters of the Katsuragawa, and carries streams of clouds over the hills. When the temple ponds are full of lotus flowers, it stirs the lanterns and chases the incense smoke, and cools the faces of the teams that pull the Yamaboko along Shijou Doori. At the end of summer, when the higanbana is blooming, that same wind follows the railway line to Uji and blows in through the open window of the researchers’ offices, rifling the stacks of diagrams that reveal its very flow.&lt;/p&gt;

&lt;p&gt;But sometimes that flow gathers to a tremendous strength, and then a typhoon will lacerate the city. The models of the wind predicts this, to make sure the people of Kyoto are prepared.&lt;/p&gt;

&lt;p&gt;Then Kyoto hunkers down, and waits.&lt;/p&gt;

&lt;p&gt;When the storm has passed, the sky is a transparent clear and blue. The wind of Kyoto is once again cool and mild, blowing gently over the city.&lt;/p&gt;

&lt;figure&gt;
&lt;img src=&quot;https://wimvanderbauwhede.github.io/images/les-reynolds-stress.png&quot; alt=&quot;Reynolds stress of wind flow over Kyoto, at 4 different heights&quot;
title=&quot;Reynolds stress of wind flow over Kyoto, at 4 different heights&quot; /&gt;
&lt;figcaption&gt;Result of wind flow simulation over Kyoto,  from a paper [1] by  DPRI researchers&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;[1] &lt;a href=&quot;https://doi.org/10.1007/s10546-018-0344-8&quot;&gt;Yoshida, T., Takemi, T. &amp;amp; Horiguchi, M. Large-Eddy-Simulation Study of the Effects of Building-Height Variability on Turbulent Flows over an Actual Urban Area. Boundary-Layer Meteorol 168, 127–153 (2018). &lt;/a&gt;&lt;/p&gt;

        </content>
    </entry>
    
    <entry>
        <title>Writing faster Perl code</title>
        <link href="https://wimvanderbauwhede.github.io/articles/writing-faster-perl/"/>
        <updated>2019-04-27T00:00:00+01:00</updated>
        <id>https://wimvanderbauwhede.github.io/articles/writing-faster-perl</id>
        <author>
					<name>Wim Vanderbauwhede</name>
					<uri>https://wimvanderbauwhede.github.io/</uri>
					
				</author>
        <content type="html">
        	&lt;img src=&quot;https://wimvanderbauwhede.github.io/images/writing-faster-perl_1600x600.jpg&quot;&gt;&lt;br/&gt;
        	&lt;p&gt;As part of my research I have been developing a &lt;a href=&quot;https://github.com/wimvanderbauwhede/RefactorF4Acc&quot;&gt;Fortran source-to-source compiler&lt;/a&gt; &amp;mdash; in &lt;a href=&quot;https://www.perl.org/&quot;&gt;Perl&lt;/a&gt;. The compiler transforms legacy FORTRAN 77 scientific code into more modern Fortran 95. For the reasons to target FORTRAN 77, please read &lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/S0045793018302950&quot;&gt;my paper&lt;/a&gt;. The compiler is written in Perl because it is available on any Linux-like system and can be executed without the need for a build toolchain. The compiler has no external dependencies at all, so that it is very simple to install and run. This is crucial because my target users are weather and climate scientists, not programmers or computer scientists. Python would have been a viable alternative but I personally prefer Perl.&lt;/p&gt;

&lt;h2&gt;Perl performance as we know it&lt;/h2&gt;

&lt;p&gt;An often-made argument is that if you want performance, you should not write your code in Perl. And it is of course true that compiled code will almost always be faster. However, often rewriting in a compiled language is not an option, so it is important to know how to get the best possible performance in pure Perl. The Perl documentation has &lt;a href=&quot;https://perldoc.perl.org/perlperf.html&quot;&gt;perlperf&lt;/a&gt; which offers good advice and &lt;a href=&quot;http://makepp.sourceforge.net/2.0/perl_performance.html&quot;&gt;these tips&lt;/a&gt; provide some more detail. But for my needs I did not find the answers there, nor anywhere else. So I created some simple test cases to find out. I used Perl version &lt;code&gt;5.28&lt;/code&gt;, the most recent one, but the results should be quite similar for earlier versions.&lt;/p&gt;

&lt;h2&gt;Testing some hunches&lt;/h2&gt;

&lt;p&gt;Before going into the details on the performance bottleneck in my compiler, here are some results of performance comparisons that influenced design decisions for the compiler. The compiler is written in a functional style &amp;mdash; I am after all a Haskell programmer &amp;mdash; but performance matters more than functional purity. &lt;/p&gt;

&lt;h3&gt;Hash key testing is faster than regexp matching&lt;/h3&gt;

&lt;p&gt;Fortran code essentially consists of a list of statements which can contain expressions, and the parser labels each of the statements once using a hashmap, ever the workhorse data structure in Perl. Every parsed line of code is stored as a pair with this hashmap (which I call &lt;code&gt;$info&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl&quot; data-lang=&quot;perl&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$parsed_line&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$src_line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$info&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This means than in principle I can choose to match a pattern in $line using a regex or use one of the lables in &lt;code&gt;$info&lt;/code&gt;. So I tested the performance of hash key testing versus regexp matching, using some genuine FORTRAN 77 code:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl&quot; data-lang=&quot;perl&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;lc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;READ( 1, 2, ERR=8, END=9, IOSTAT=N ) X&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=~&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/read/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;ReadCall&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100_000_000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=~&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/read/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;$count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100_000_000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;exists&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;ReadCall&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;$count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Without the &lt;code&gt;if&lt;/code&gt;-condidion, the loop takes 3.1 s on my laptop. The loop with the regexp match condition takes 10.1 s; with the hash key existence test it takes 5.6 s. So the actual condition evaluation takes 7 s for regexp and 2.5 s for hash key existence check. So testing hash keys is alsmost three times faster than simple regexp matching. &lt;/p&gt;

&lt;h3&gt;Custom tree traversals are faster&lt;/h3&gt;

&lt;p&gt;I tested the cost of using higher-order functions for tree traversal. Basically, this is the choice between a generic traversal which takes an arbitrary function that operates on the tree nodes: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl&quot; data-lang=&quot;perl&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;_traverse_ast_with_action&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$ast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;&amp;lt;cond&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
        &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
     &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;scalar&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 
            &lt;span class=&quot;n&quot;&gt;_traverse_ast_with_action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;$ast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;or a custom traversal:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl&quot; data-lang=&quot;perl&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;_traverse_ast_custom&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$ast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;&amp;lt;cond&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
        &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;custom&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acting&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$ast&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
    &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;custom&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acting&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$ast&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;scalar&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 
            &lt;span class=&quot;n&quot;&gt;_traverse_ast_custom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;$ast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For the case of the tree data structures in my compiler, the higher-order implementation takes twice as long as the custom traversal, so for performance this is not a good choice. Therefore I don&amp;#39;t use higher-order functions in the parser, but I do use them in the later refactoring passes.&lt;/p&gt;

&lt;h3&gt;Maps are slower than for-loops, but not much&lt;/h3&gt;

&lt;p&gt;Finally I tested the cost of using &lt;code&gt;map&lt;/code&gt; instead of a &lt;code&gt;foreach&lt;/code&gt;-loop:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl&quot; data-lang=&quot;perl&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# map, so much more concise!&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@src&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10_000_000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# declarations for all for-loops&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@res&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# foreach-loop&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$elt&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10_000_000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$elt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$elt&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;@src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$elt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# index-based for-loop&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10_000_000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$elt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$elt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10_000_000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$elt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$elt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# C-style for-loop&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10_000_000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$elt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$elt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10_000_000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$elt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$elt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;foreach&lt;/code&gt;-loop version takes 2.6 s, the &lt;code&gt;map&lt;/code&gt; version 3.3 s, so the map is 25% slower. For reference, the index-based &lt;code&gt;for&lt;/code&gt;-loop version takes 3.8 s and the C-style &lt;code&gt;for&lt;/code&gt;-loop version 4.4 s &amp;mdash; don&amp;#39;t do that! &lt;/p&gt;

&lt;p&gt;Because the map is slower, again I did not use it in the parser, and I implemented my own higher-order functions which use foreach-loops internally for the refactoring passes.&lt;/p&gt;

&lt;h2&gt;Compiler bottleneck: expression parsing&lt;/h2&gt;

&lt;p&gt;As the compiler grew in capabilities, it became noticeably slower. Perl has a great profiling tool, &lt;a href=&quot;https://metacpan.org/pod/Devel::NYTProf&quot;&gt;Devel::NYTProf&lt;/a&gt;, and I used it to identify the bottleneck. As you can see from the flame graph in the banner image, it turned out to be the expression parser. This part of the code was based on &lt;a href=&quot;https://metacpan.org/pod/Math::Expression::Evaluator&quot;&gt;Math::Expression::Evaluator&lt;/a&gt; because it was convenient to reuse. But it was not built for performance, and also not to parse Fortran. So I finally bit the bullet and wrote my own.&lt;/p&gt;

&lt;p&gt;What I loosely call an expression parser is actually a combination of a lexer and a parser: it turns a string of source code into a tree-like datastructure which expresses the structure of the expression and the purpose of its constituents. For example if the expression is &lt;code&gt;2*v+1&lt;/code&gt;, the result of the expression parser will be a data structure which identifies the top-level expression as a sum of a multplication with  the integer constant &lt;code&gt;1&lt;/code&gt;, and the multiplication of an integer constant &lt;code&gt;2&lt;/code&gt; with a variable &lt;code&gt;v&lt;/code&gt;. So how do we build a fast expression parser? It is not my intention to go into the computing science details, but instead to discuss the choices to be considered.&lt;/p&gt;

&lt;h2&gt;Testing some more hunches&lt;/h2&gt;

&lt;p&gt;First, the choice of the data structure matters. As we need a tree-like ordered data structure, it would have to be either an object or a list. But objects in Perl are slow, so I use a nested list. As it happens, &lt;code&gt;Math::Expression&lt;/code&gt; already uses nested lists. Using the parser from &lt;code&gt;Math::Expression&lt;/code&gt;, the above expression would be turned into:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl&quot; data-lang=&quot;perl&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;+&amp;#39;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;*&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;v&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Integer comparison is faster than string comparison&lt;/h3&gt;

&lt;p&gt;This data structure is fine if you don&amp;#39;t need to do a lot of work on it. However, because every node is labeled with a string, testing against the node type is a string comparison. I did a quick test:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl&quot; data-lang=&quot;perl&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;*&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100_000_000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;eq&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;*&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;$count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100_000_000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;$count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;On my laptop, the version with string comparison takes 5.3 s, the integer comparison 4.6 s. Without the &lt;code&gt;if&lt;/code&gt;-statement, the code takes 3.1 s. In other words, the actual &lt;code&gt;if&lt;/code&gt; with string comparison takes 2.2 s, with integer comparison 1.5 s. So doing string comparisons is 50% slower than doing integer comparisons. Therefore my data structure uses integer labels. Also, I label the constants so that I can have different labels for string, integer and real constants, and because in this way all nodes are arrays. This avoids having to test if a node is an array or a scalar, which is a slow operation.&lt;/p&gt;

&lt;p&gt;So the example becomes :&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl&quot; data-lang=&quot;perl&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;29&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;2&amp;#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;v&amp;#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;29&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;1&amp;#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Less readable, but faster and easier to extend.&lt;/p&gt;

&lt;h3&gt;Regexes are faster than string comparisons&lt;/h3&gt;

&lt;p&gt;Then we have to decide how to parse the expression string. The traditional way to build an expression parser is using a Finite State Machine, consuming one character at a time (if needed with one or more characters look-ahead) and keeping track of the identified portion of the string. This is very fast in a language such as C but in Perl I was not too sure, because in Perl a character is actually a string of length one, so every test against a character is a string comparison. On the other hand, Perl has a famously efficient regular expression engine. So I created a little testbench to see which approach was faster:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl&quot; data-lang=&quot;perl&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;This means we need a stack per type of operation and run until the end of the expression&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@chrs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10_000_000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@words&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$word&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;@chrs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$chr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@chrs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$chr&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;ne&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nv&quot;&gt;$word&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$chr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nb&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@words&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;nv&quot;&gt;$word&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;nb&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@words&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10_000_000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@words&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
             &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;   &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=~&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;s/^(\w+)//&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nb&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@words&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=~&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;s/^\s+//&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;On my laptop, the FSM version takes 3.25 s, the regex version 1.45 s (mean over 10 runs), so the regexp version is twice as fast &amp;mdash; the choice is clear.&lt;/p&gt;

&lt;h2&gt;A faster expression parser&lt;/h2&gt;

&lt;p&gt;With the choices of string parsing and data structure made, I focused on the structure of the overall algorithm. The basic approach is to loop through a number of states and in every state perform a specific action. This is very simple because we use regular expressions to identify tokens, so most of the state transitions are implicit:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-perl&quot; data-lang=&quot;perl&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$prev_lev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$lev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;@ast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$op&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;c1&quot;&gt;# Match unary prefix operations&lt;/span&gt;
     &lt;span class=&quot;c1&quot;&gt;# Match terms&lt;/span&gt;
     &lt;span class=&quot;c1&quot;&gt;# Add prefix operations if matched&lt;/span&gt;
     &lt;span class=&quot;c1&quot;&gt;# Match binary operators&lt;/span&gt;
     &lt;span class=&quot;c1&quot;&gt;# Append to the AST&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The matching rules and operations are very simple (I use &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;integer&amp;gt;&lt;/code&gt; as placeholders for the actual values):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;prefix operations:
&lt;code&gt;perl
if ( $str=~s/^&amp;lt;pattern&amp;gt;// ) { $state=&amp;lt;integer&amp;gt;; } 
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;terms:
&lt;code&gt;perl
if ( $str=~s/^(&amp;lt;pattern&amp;gt;)// ) { $expr_ast=[&amp;lt;integer&amp;gt;,$1]; }
&lt;/code&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;operators:
&lt;code&gt;perl
$prev_lev=$lev;
if ( $str=~s/^&amp;lt;pattern&amp;gt;// ) { $lev=&amp;lt;integer&amp;gt;; $op=&amp;lt;integer&amp;gt;; }
&lt;/code&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Operators have precedence and associativity, and Fortran requires twelve precedence levels. In the &amp;quot;Append to AST&amp;quot; state, the parser uses &lt;code&gt;$lev&lt;/code&gt; and &lt;code&gt;$prev_lev&lt;/code&gt; to work out how the previously matched &lt;code&gt;$expr_ast&lt;/code&gt; and &lt;code&gt;$op&lt;/code&gt; should be appended to the &lt;code&gt;@ast&lt;/code&gt; array. The prefix operations are handled by setting a state which is checked after term matching. The actual code is a bit more complicated because we need to parse array index expressions and function calls as well. This is done recursively during term matching; if a function call has multiple arguments, the parser is put into a new &lt;code&gt;$state&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;So the end result is a minimally recursive parser, i.e. it only uses recursion when it is really necessary. This is because Perl is not efficient in doing recursive function calls (nor in fact for non-recursive ones).&lt;/p&gt;

&lt;p&gt;There is a lot of repetition of the patterns for matching terms and operators because if I would instead abstract the &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;integer&amp;gt;&lt;/code&gt; values by e.g. storing them in an array, the array accesses would considerably reduce the performance. I do store the precedence levels in an array because there are so many of them that the logic for appending terms to the AST would otherwise become very hard to read and update.&lt;/p&gt;

&lt;h2&gt;Expression parser performance&lt;/h2&gt;

&lt;p&gt;I tested the new expression parser on a set of 50 different expressions taken from a weather simulation code. The old expression parser takes 45 s to run this test a thousand times; the new expression parser takes only 2 s. In other words, the new parser is &lt;em&gt;more than twenty times faster&lt;/em&gt; than the old one. &lt;/p&gt;

&lt;p&gt;It is also quite easy to maintain and adapt despite its minimal use of abstractions, and because it is Fortran-specific, the rest of the code has become a lot cleaner too. You can find the code in &lt;a href=&quot;https://github.com/wimvanderbauwhede/RefactorF4Acc/blob/devel/RefactorF4Acc/Parser/Expressions.pm&quot;&gt;my GitHub repo&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Summary&lt;/h2&gt;

&lt;p&gt;Here is a summary of all optimisations I tested. The tests were run using Perl v5.28 on a MacBook Pro (late 2013), timings are averages over 5 runs and measured using &lt;code&gt;time&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;| --- | --- | 
| Optimisation | Speed-up |
| --- | --- | 
| Hash key testing is faster than regexp matching | 3&amp;times; |
| Custom tree traversals are faster than generic ones | 2&amp;times; |
| &lt;code&gt;foreach&lt;/code&gt; is faster than &lt;code&gt;map&lt;/code&gt; | 1.3&amp;times; |
| &lt;code&gt;foreach&lt;/code&gt; is faster than indexed &lt;code&gt;for&lt;/code&gt; | 1.4&amp;times; |
| &lt;code&gt;foreach&lt;/code&gt; is faster than C-style &lt;code&gt;for&lt;/code&gt; | 1.7&amp;times; | 
| Integer comparison is faster than string comparison | 1.5&amp;times; |
| Regexp matching is faster than successive string comparisons | 2.2&amp;times; |&lt;/p&gt;

        </content>
    </entry>
    
    <entry>
        <title>Why Europe needs hurricane contingency planning</title>
        <link href="https://wimvanderbauwhede.github.io/articles/prepare-for-hurricanes/"/>
        <updated>2018-10-21T00:00:00+01:00</updated>
        <id>https://wimvanderbauwhede.github.io/articles/prepare-for-hurricanes</id>
        <author>
					<name>Wim Vanderbauwhede</name>
					<uri>https://wimvanderbauwhede.github.io/</uri>
					
				</author>
        <content type="html">
        	&lt;img src=&quot;https://wimvanderbauwhede.github.io/images/prepare-for-hurricanes_1600x600.jpg&quot;&gt;&lt;br/&gt;
        	&lt;p&gt;As a result of global warming, hurricanes will become common in Europe in the next few decades. I discuss the evidence, the impact and the need for proper contingency planning.&lt;/p&gt;

&lt;h2&gt;Some terminology&lt;/h2&gt;

&lt;h3&gt;Tropical cyclones&lt;/h3&gt;

&lt;p&gt;A tropical cyclone is a rapidly rotating storm system with a low-pressure centre, strong winds, and a spiral arrangement of thunderstorms that produce heavy rain. They are called &amp;quot;tropical&amp;quot; because they form almost exclusively over tropical or sub-tropical waters. &amp;quot;Cyclone&amp;quot; refers to their winds moving in a circle, rotating around a central clear eye. The winds blow counterclockwise in the Northern Hemisphere and clockwise in the Southern Hemisphere. &lt;/p&gt;

&lt;p&gt;For completeness, an anticyclone is a large-scale circulation of winds around a central region of high atmospheric pressure, clockwise in the Northern Hemisphere, counterclockwise in the Southern Hemisphere&amp;quot;. Anticyclones are not storm systems, and in Belgium, where I used to live, the famous[^1] &lt;a href=&quot;https://en.wikipedia.org/wiki/Azores_High&quot;&gt;Azores Anticyclone&lt;/a&gt; usually lead to nice weather.&lt;/p&gt;

&lt;h3&gt;Storms, hurricanes and typhoons&lt;/h3&gt;

&lt;p&gt;The terms &amp;quot;hurricane&amp;quot; and &amp;quot;typhoon&amp;quot; refer both to powerful tropical cyclones. A hurricane[^2] occurs in the Atlantic Ocean and northeastern Pacific Ocean, and a typhoon[^3] occurs in the northwestern Pacific Ocean[^4].  The diameter of the hurricane is typically of the order of hundreds of kilometers. Last month&amp;#39;s hurricane Florence was over 600 km in diameter, and typhoon Trami about 500 km. A &amp;quot;tropical storm&amp;quot; is &amp;quot;tropical cyclone&amp;quot; that is less strong than a hurricane or typhoon. &lt;/p&gt;

&lt;h2&gt;Strength and potential damage&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&quot;https://www.nhc.noaa.gov/aboutsshws.php&quot;&gt;Saffir-Simpson Hurricane Wind Scale&lt;/a&gt; is a scale from 1 to 5 based on a hurricane&amp;#39;s sustained wind speed, used to estimate potential property damage. Hurricanes reaching Category 3 and higher are considered major hurricanes because of their potential for significant loss of life and damage. However, Category 1 and 2 hurricanes are still much more dangerous than ordinary tropical storms, and require preventive measures.&lt;/p&gt;

&lt;p&gt;The amount of energy in a hurricane is very large. &lt;a href=&quot;http://www.aoml.noaa.gov/hrd/tcfaq/D7.html&quot;&gt;NOAA&lt;/a&gt; (US National Oceanic and Atmospheric Administration) notes that the energy released by an average hurricane &amp;quot;is equivalent to 200 times the world-wide electrical generating capacity&amp;quot;.&lt;/p&gt;

&lt;p&gt;The table below is adapted from &lt;a href=&quot;https://www.nhc.noaa.gov/aboutsshws.php&quot;&gt;NOAA&lt;/a&gt; page linked above.&lt;/p&gt;

&lt;table&gt;
 &lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;
Category&lt;/th&gt;
&lt;th&gt;Sustained wind&amp;nbsp;speed&lt;/th&gt;
&lt;th&gt;Extent of damage&lt;/th&gt;
&lt;/tr&gt;
  &lt;/thead&gt;
   &lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;
1&lt;/td&gt;&lt;td&gt;119-153 km/h&lt;/td&gt;&lt;td&gt; &lt;em&gt;Very dangerous winds will produce some damage:&lt;/em&gt; &lt;br&gt;Houses could have damage to roof, shingles and gutters. Large branches of trees will snap and shallowly rooted trees may be toppled. Extensive damage to power lines and poles likely will result in power outages that could last a few to several days.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
2&lt;/td&gt;&lt;td&gt;154-177 km/h&lt;/td&gt;&lt;td&gt; &lt;em&gt;Extremely dangerous winds will cause extensive damage:&lt;/em&gt; &lt;br&gt;Houses could sustain major roof and siding damage. Many shallowly rooted trees will be snapped or uprooted and block numerous roads. Near-total power loss is expected with outages that could last from several days to weeks.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;
&lt;td&gt;
3&lt;/td&gt;&lt;td&gt;178-208 km/h&lt;/td&gt;&lt;td&gt; &lt;em&gt;Devastating damage will occur:&lt;/em&gt; &lt;br&gt;Houses may incur major damage or removal of roof decking and gable ends. Many trees will be snapped or uprooted, blocking numerous roads. Electricity and water will be unavailable for several days to weeks after the storm passes.&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
4&lt;/td&gt;&lt;td&gt;209-251 km/h&lt;/td&gt;&lt;td&gt; &lt;em&gt;Catastrophic damage will occur:&lt;/em&gt;&lt;br&gt;Houses can sustain severe damage with loss of most of the roof structure and/or some exterior walls. Most trees will be snapped or uprooted and electricity poles downed. Fallen trees and electricity poles will isolate residential areas. Power outages will last weeks to possibly months. Most of the area will be uninhabitable for weeks or months.&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
5&lt;/td&gt;&lt;td&gt;252 km/h or higher&lt;/td&gt;&lt;td&gt;&lt;em&gt;Catastrophic damage will occur:&lt;/em&gt;&lt;br&gt;A high percentage of houses will be destroyed, with total roof failure and wall collapse. Fallen trees and electricity poles will isolate residential areas. Power outages will last for weeks to possibly months. Most of the area will be uninhabitable for weeks or months.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Note that this table uses &lt;a href=&quot;http://www.aoml.noaa.gov/hrd/tcfaq/D4.html&quot;&gt;sustained wind speeds&lt;/a&gt;. The &lt;em&gt;gusts&lt;/em&gt; occuring during a tropical cyclone can be a lot stronger than this (typically about 30% stronger), and are usually what is quoted in the media.&lt;/p&gt;

&lt;h2&gt;Global warming causes hurricanes to get stronger&lt;/h2&gt;

&lt;p&gt;Slightly simplifying, hurricanes get their energy from the heat in the surface sea water. As the planet gets warmer, the sea surface gets warmer, which leads to stronger tropical cyclones.&lt;/p&gt;

&lt;p&gt;There is plenty evidence for this trend. For example, very recent work by my friend and colleague Prof. Takemi of the Disaster Prevention Research Institute (DPRI) of Kyoto University [1] used observation data of historical typhoons to reproduce them in simulation, and then simulated the effects of future warmer conditions. They conclude that both wind speed and precipitation would increase significantly. When I visited DPRI in September, a researcher explained me their latest simulations. With 2 degrees warming, wind speeds and rainfall during a typhoon could double.&lt;/p&gt;

&lt;p&gt;The recent Guardian article &lt;a href=&quot;https://www.theguardian.com/weather/ng-interactive/2018/sep/11/atlantic-hurricanes-are-storms-getting-worse&quot;&gt;&amp;quot;Is climate change making hurricanes worse?&amp;quot;&lt;/a&gt; provides a good overview. Note that this trend refers to &lt;em&gt;all&lt;/em&gt; tropical cyclones, not just these that made landfall.&lt;/p&gt;

&lt;h2&gt;Hurricanes are coming to Europe&lt;/h2&gt;

&lt;p&gt;Historically, &lt;em&gt;none of the tropical storms&lt;/em&gt; in Europe in the last century except &lt;a href=&quot;https://en.wikipedia.org/wiki/Hurricane_Vince&quot;&gt;hurricane Vince in 2005&lt;/a&gt; have been hurricanes, no matter how severe they might have seemed. However, this is about to change.&lt;/p&gt;

&lt;p&gt;As hurricanes get more powerful and last longer, the chance that they can reach Europe grows. Again, there is evidence for this. Already in 2013 Reindert Haarsma, Senior Scientist at the Royal Netherlands Meteorological Institute wrote the article &lt;a href=&quot;https://theconversation.com/the-future-will-bring-hurricanes-to-europe-16339&quot;&gt;&amp;quot;The future will bring hurricanes to Europe&amp;quot;&lt;/a&gt; which gives a good overview. The article is based on Haarsma&amp;#39;s scientific research [2]. Other researchers predict similar trends [3,4,5].&lt;/p&gt;

&lt;h2&gt;Impact and contingency planning&lt;/h2&gt;

&lt;p&gt;Hurricanes do not only cause damage because of the strong winds. They also lead to flash floods because of the very heavy rainfall that they cause (often 30-50 cm/h), and because of the &lt;a href=&quot;https://www.nhc.noaa.gov/surge/&quot;&gt;storm surges&lt;/a&gt; which are several meters in height (e.g. 5 m for hurricane Michael a few weeks ago). &lt;/p&gt;

&lt;p&gt;To put this into perspective, in December 2015 &lt;a href=&quot;https://en.wikipedia.org/wiki/2015%E2%80%9316_Great_Britain_and_Ireland_floods&quot;&gt;storm Desmond&lt;/a&gt; broke the United Kingdom&amp;#39;s 24-hour rainfall record with 34 cm of rainfall in 24 hours, and led to widespread flooding in the UK and Ireland.  The only storm surge on record comparable to those caused by hurricanes was the notorious &lt;a href=&quot;https://en.wikipedia.org/wiki/North_Sea_flood_of_1953&quot;&gt;Great Storm of 1953&lt;/a&gt;. In Scotland, where storms are common, this was the worst storm[^5] in 500 years.&lt;/p&gt;

&lt;p&gt;Better flood defenses are therefore absolutely crucial to deal with future hurricanes. As a result of the 1953 disaster, much was done in the UK, the Netherlands and Belgium to strenghten flood defenses, but these focus on the North Sea. Similar works on the coasts facing the Atlantic will be necessary. Furthermore because of the increased damage, power outages and disruption of supplies will last much longer than for the storms we have now and therefore contingency plans will have to be put in place. 
A capability for accurate forecasting of hurricane trajectories is necessary for timely evacuation of people in the affected areas.  &lt;/p&gt;

&lt;p&gt;The good news is that Europe can benefit from the extensive know-how developed for example in the US and Japan, both in predictions and in dealing with the effects of such severe weather events. &lt;/p&gt;

&lt;h3&gt;References&lt;/h3&gt;

&lt;p&gt;[1] Kanada S, Takemi T, Kato M, Yamasaki S, Fudeyasu H, Tsuboki K, Arakawa O, Takayabu I. A multimodel intercomparison of an intense typhoon in future, warmer climates by four 5-km-mesh models. &lt;em&gt;Journal of Climate.&lt;/em&gt; 2017 Aug;30(15):6017-36.&lt;/p&gt;

&lt;p&gt;[2] Haarsma RJ, Hazeleger W, Severijns C, De Vries H, Sterl A, Bintanja R, Van Oldenborgh GJ, van den Brink HW. More hurricanes to hit western Europe due to global warming. &lt;em&gt;Geophysical Research Letters.&lt;/em&gt; 2013 May 16;40(9):1783-8.&lt;/p&gt;

&lt;p&gt;[3] Baker A, Hodges K, Schiemann R, Vidale PL. North Atlantic post-tropical cyclones in reanalysis datasets. In &lt;em&gt;EGU General Assembly Conference Abstracts&lt;/em&gt;, 2018 Apr (Vol. 20, p. 14606).&lt;/p&gt;

&lt;p&gt;[4] Dekker MM, Haarsma RJ, de Vries H, Baatsen M, van Delden AJ. Characteristics and development of European cyclones with tropical origin in reanalysis data. &lt;em&gt;Climate Dynamics.&lt;/em&gt; 2018 Jan 1;50(1-2):445-55.&lt;/p&gt;

&lt;p&gt;[5] Mousavi ME, Irish JL, Frey AE, Olivera F, Edge BL. Global warming and hurricanes: the potential impact of hurricane intensification and sea level rise on coastal flooding. &lt;em&gt;Climatic Change.&lt;/em&gt; 2011 Feb 1;104(3-4):575-97.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The banner image shows typhoon Halong approaching Japan in September 2014, &amp;copy; NASA Terra/MODIS 2014&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;[^1]: It is so famous that a travel book shop in Brussels took it as its name.&lt;br&gt;
[^2]: The term &amp;quot;hurricane&amp;quot; derives from the Spanish word &lt;em&gt;huracán&lt;/em&gt;, which in turn probably derives from the Taino (an indigenous people of the Caribbean) word &lt;em&gt;hurakán&lt;/em&gt; &amp;quot;god of the storm&amp;quot;.&lt;br&gt;
[^3]: In Japan they are called 台風 (&lt;em&gt;taifuu&lt;/em&gt;) and are given numbers rather than names.&lt;br&gt;
[^4]: In the northwestern Pacific, the term &amp;quot;super typhoon&amp;quot; is used for tropical cyclones with sustained winds exceeding 240 km/h.&lt;br&gt;
[^5]: This was a &lt;a href=&quot;https://en.wikipedia.org/wiki/European_windstorm&quot;&gt;European windstorm&lt;/a&gt;, a type of extratropical cyclone, caused by different weather phenomena than hurricanes. There is evidence that this type of storms is also getting stronger [5].&lt;/p&gt;

        </content>
    </entry>
    
</feed>